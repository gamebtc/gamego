// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ddz.proto

package ddz

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Code int32

const (
	// 8400-8499(斗地主)
	Code_CodeNone          Code = 0
	Code_CodeActionReq     Code = 8400
	Code_CodeActionAck     Code = 8401
	Code_CodeGameInitAck   Code = 8403
	Code_CodeGameStartAck  Code = 8405
	Code_CodeGameResultAck Code = 8407
)

var Code_name = map[int32]string{
	0:    "CodeNone",
	8400: "CodeActionReq",
	8401: "CodeActionAck",
	8403: "CodeGameInitAck",
	8405: "CodeGameStartAck",
	8407: "CodeGameResultAck",
}

var Code_value = map[string]int32{
	"CodeNone":          0,
	"CodeActionReq":     8400,
	"CodeActionAck":     8401,
	"CodeGameInitAck":   8403,
	"CodeGameStartAck":  8405,
	"CodeGameResultAck": 8407,
}

func (x Code) String() string {
	return proto.EnumName(Code_name, int32(x))
}

func (Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{0}
}

type ActionType int32

const (
	ActionType_ActionNone ActionType = 0
	// 准备
	ActionType_ActionReady ActionType = 1
	// 叫地主
	ActionType_ActionCall ActionType = 2
	// 不抢
	ActionType_ActionNoRob ActionType = 3
	// 抢地主
	ActionType_ActionRob ActionType = 4
	// 不加倍
	ActionType_ActionOne ActionType = 5
	// 加倍
	ActionType_ActionDouble ActionType = 6
	// 定地主,显示底牌
	ActionType_ActionBottom ActionType = 7
	// 过
	ActionType_ActionPass ActionType = 8
	// 出牌
	ActionType_ActionPlay ActionType = 9
	// 无人叫牌,重新开始
	ActionType_ActionAbortion ActionType = 10
	// 换桌玩
	ActionType_ActionRenew ActionType = 11
	// 离开
	ActionType_ActionLeave ActionType = 12
)

var ActionType_name = map[int32]string{
	0:  "ActionNone",
	1:  "ActionReady",
	2:  "ActionCall",
	3:  "ActionNoRob",
	4:  "ActionRob",
	5:  "ActionOne",
	6:  "ActionDouble",
	7:  "ActionBottom",
	8:  "ActionPass",
	9:  "ActionPlay",
	10: "ActionAbortion",
	11: "ActionRenew",
	12: "ActionLeave",
}

var ActionType_value = map[string]int32{
	"ActionNone":     0,
	"ActionReady":    1,
	"ActionCall":     2,
	"ActionNoRob":    3,
	"ActionRob":      4,
	"ActionOne":      5,
	"ActionDouble":   6,
	"ActionBottom":   7,
	"ActionPass":     8,
	"ActionPlay":     9,
	"ActionAbortion": 10,
	"ActionRenew":    11,
	"ActionLeave":    12,
}

func (x ActionType) String() string {
	return proto.EnumName(ActionType_name, int32(x))
}

func (ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{1}
}

type Player_State int32

const (
	// 没有准备
	Player_None Player_State = 0
	// 已准备
	Player_Ready Player_State = 1
	// 游戏中
	Player_Playing Player_State = 2
	// 托管
	Player_Trust Player_State = 3
	// 离开
	Player_Leave Player_State = 7
)

var Player_State_name = map[int32]string{
	0: "None",
	1: "Ready",
	2: "Playing",
	3: "Trust",
	7: "Leave",
}

var Player_State_value = map[string]int32{
	"None":    0,
	"Ready":   1,
	"Playing": 2,
	"Trust":   3,
	"Leave":   7,
}

func (x Player_State) String() string {
	return proto.EnumName(Player_State_name, int32(x))
}

func (Player_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{0, 0}
}

// 玩家信息
type Player struct {
	// 玩家ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id" bson:"id" msg:"id"`
	// 玩家头像
	Icon int32 `protobuf:"varint,2,opt,name=icon,proto3" json:"icon" bson:"icon" msg:"icon"`
	// VIP等级
	Vip int32 `protobuf:"varint,3,opt,name=vip,proto3" json:"vip" bson:"vip" msg:"vip"`
	// 椅子号(从0开始)
	Chair int32 `protobuf:"varint,4,opt,name=chair,proto3" json:"chair" bson:"chair" msg:"chair"`
	// 玩家带的分
	Coin int64 `protobuf:"varint,5,opt,name=coin,proto3" json:"coin" bson:"coin" msg:"coin"`
	// 玩家的下注
	Bet int64 `protobuf:"varint,6,opt,name=bet,proto3" json:"bet" bson:"bet" msg:"bet"`
	// 玩家名称
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name" bson:"name" msg:"name"`
	// 游戏状态
	State Player_State `protobuf:"varint,8,opt,name=state,proto3,enum=ddz.Player_State" json:"state" bson:"state" msg:"state"`
	// 手上剩余牌的张数
	Hand int32 `protobuf:"varint,9,opt,name=hand,proto3" json:"hand" bson:"hand" msg:"hand"`
	// 倒计时(等待玩家命令倒计时)
	Down int32 `protobuf:"zigzag32,10,opt,name=down,proto3" json:"down" bson:"down" msg:"down"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{0}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetIcon() int32 {
	if m != nil {
		return m.Icon
	}
	return 0
}

func (m *Player) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *Player) GetChair() int32 {
	if m != nil {
		return m.Chair
	}
	return 0
}

func (m *Player) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *Player) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetState() Player_State {
	if m != nil {
		return m.State
	}
	return Player_None
}

func (m *Player) GetHand() int32 {
	if m != nil {
		return m.Hand
	}
	return 0
}

func (m *Player) GetDown() int32 {
	if m != nil {
		return m.Down
	}
	return 0
}

// 打牌请求
type ActionReq struct {
	// 动作类型
	Type ActionType `protobuf:"varint,1,opt,name=type,proto3,enum=ddz.ActionType" json:"type" bson:"type" msg:"type"`
	// 牌
	Poker []byte `protobuf:"bytes,2,opt,name=poker,proto3" json:"poker,omitempty" bson:"poker,omitempty" msg:"poker,omitempty"`
}

func (m *ActionReq) Reset()         { *m = ActionReq{} }
func (m *ActionReq) String() string { return proto.CompactTextString(m) }
func (*ActionReq) ProtoMessage()    {}
func (*ActionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{1}
}
func (m *ActionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionReq.Merge(m, src)
}
func (m *ActionReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionReq proto.InternalMessageInfo

func (m *ActionReq) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ActionType_ActionNone
}

func (m *ActionReq) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

type ActionAck struct {
	// 动作类型
	Type ActionType `protobuf:"varint,1,opt,name=type,proto3,enum=ddz.ActionType" json:"type" bson:"type" msg:"type"`
	// 牌
	Poker []byte `protobuf:"bytes,2,opt,name=poker,proto3" json:"poker,omitempty" bson:"poker,omitempty" msg:"poker,omitempty"`
	// 玩家ID
	Uid int32 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty" bson:"uid,omitempty" msg:"uid,omitempty"`
}

func (m *ActionAck) Reset()         { *m = ActionAck{} }
func (m *ActionAck) String() string { return proto.CompactTextString(m) }
func (*ActionAck) ProtoMessage()    {}
func (*ActionAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{2}
}
func (m *ActionAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionAck.Merge(m, src)
}
func (m *ActionAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionAck proto.InternalMessageInfo

func (m *ActionAck) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ActionType_ActionNone
}

func (m *ActionAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *ActionAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type GameInitAck struct {
	// 当前游戏ID
	Table int32 `protobuf:"varint,1,opt,name=table,proto3" json:"table" bson:"table" msg:"table"`
	// 当前游戏ID
	Id int32 `protobuf:"varint,2,opt,name=id,proto3" json:"id" bson:"id" msg:"id"`
	// 当前游戏状态
	State int32 `protobuf:"varint,4,opt,name=state,proto3" json:"state" bson:"state" msg:"state"`
	// 第几轮
	Ring int32 `protobuf:"varint,5,opt,name=ring,proto3" json:"ring" bson:"ring" msg:"ring"`
	// 玩家(第1个位置为先)
	Players []*Player `protobuf:"bytes,6,rep,name=players,proto3" json:"players" bson:"play" msg:"play"`
	// 我的牌,如果已看牌
	Poker []byte `protobuf:"bytes,7,opt,name=poker,proto3" json:"poker,omitempty" bson:"poker,omitempty" msg:"poker,omitempty"`
	// 已出的牌
	Use []byte `protobuf:"bytes,8,opt,name=use,proto3" json:"use,omitempty" bson:"use,omitempty" msg:"use,omitempty"`
}

func (m *GameInitAck) Reset()         { *m = GameInitAck{} }
func (m *GameInitAck) String() string { return proto.CompactTextString(m) }
func (*GameInitAck) ProtoMessage()    {}
func (*GameInitAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{3}
}
func (m *GameInitAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInitAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInitAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameInitAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInitAck.Merge(m, src)
}
func (m *GameInitAck) XXX_Size() int {
	return m.Size()
}
func (m *GameInitAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInitAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameInitAck proto.InternalMessageInfo

func (m *GameInitAck) GetTable() int32 {
	if m != nil {
		return m.Table
	}
	return 0
}

func (m *GameInitAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameInitAck) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *GameInitAck) GetRing() int32 {
	if m != nil {
		return m.Ring
	}
	return 0
}

func (m *GameInitAck) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *GameInitAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameInitAck) GetUse() []byte {
	if m != nil {
		return m.Use
	}
	return nil
}

// 游戏开始
type GameStartAck struct {
	// 当前游戏ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id" bson:"id" msg:"id"`
	// 彩池的钱
	Pool int64 `protobuf:"varint,2,opt,name=pool,proto3" json:"pool" bson:"pool" msg:"pool"`
	// 玩家(第1个位置为先)
	Players []*Player `protobuf:"bytes,3,rep,name=players,proto3" json:"play" bson:"play" msg:"play"`
}

func (m *GameStartAck) Reset()         { *m = GameStartAck{} }
func (m *GameStartAck) String() string { return proto.CompactTextString(m) }
func (*GameStartAck) ProtoMessage()    {}
func (*GameStartAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{4}
}
func (m *GameStartAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameStartAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameStartAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameStartAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameStartAck.Merge(m, src)
}
func (m *GameStartAck) XXX_Size() int {
	return m.Size()
}
func (m *GameStartAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameStartAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameStartAck proto.InternalMessageInfo

func (m *GameStartAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameStartAck) GetPool() int64 {
	if m != nil {
		return m.Pool
	}
	return 0
}

func (m *GameStartAck) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// 游戏结束
type GameResultAck struct {
	// 当前游戏ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id" bson:"id" msg:"id"`
	// 赢家
	Winner []int32 `protobuf:"varint,2,rep,packed,name=winner,proto3" json:"winner" bson:"winner" msg:"winner"`
	// 每个人的赢钱数
	Prize []int64 `protobuf:"varint,3,rep,packed,name=prize,proto3" json:"prize" bson:"prize" msg:"prize"`
	// 我的金币数
	Coin int64 `protobuf:"varint,4,opt,name=coin,proto3" json:"coin" bson:"coin" msg:"coin"`
	// 所有牌,不能看的为0
	Poker []byte `protobuf:"bytes,5,opt,name=poker,proto3" json:"poker" bson:"poker" msg:"poker"`
	// 喜钱，从彩池单独出
	Lucky int64 `protobuf:"varint,6,opt,name=lucky,proto3" json:"lucky,omitempty" bson:"lucky,omitempty" msg:"lucky,omitempty"`
}

func (m *GameResultAck) Reset()         { *m = GameResultAck{} }
func (m *GameResultAck) String() string { return proto.CompactTextString(m) }
func (*GameResultAck) ProtoMessage()    {}
func (*GameResultAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_329728c9c8fc6b4b, []int{5}
}
func (m *GameResultAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameResultAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameResultAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameResultAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameResultAck.Merge(m, src)
}
func (m *GameResultAck) XXX_Size() int {
	return m.Size()
}
func (m *GameResultAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameResultAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameResultAck proto.InternalMessageInfo

func (m *GameResultAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameResultAck) GetWinner() []int32 {
	if m != nil {
		return m.Winner
	}
	return nil
}

func (m *GameResultAck) GetPrize() []int64 {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *GameResultAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *GameResultAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameResultAck) GetLucky() int64 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func init() {
	proto.RegisterEnum("ddz.Code", Code_name, Code_value)
	proto.RegisterEnum("ddz.ActionType", ActionType_name, ActionType_value)
	proto.RegisterEnum("ddz.Player_State", Player_State_name, Player_State_value)
	proto.RegisterType((*Player)(nil), "ddz.Player")
	proto.RegisterType((*ActionReq)(nil), "ddz.ActionReq")
	proto.RegisterType((*ActionAck)(nil), "ddz.ActionAck")
	proto.RegisterType((*GameInitAck)(nil), "ddz.GameInitAck")
	proto.RegisterType((*GameStartAck)(nil), "ddz.GameStartAck")
	proto.RegisterType((*GameResultAck)(nil), "ddz.GameResultAck")
}

func init() { proto.RegisterFile("ddz.proto", fileDescriptor_329728c9c8fc6b4b) }

var fileDescriptor_329728c9c8fc6b4b = []byte{
	// 1001 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0xe3, 0x38, 0x69, 0x26, 0x69, 0x3b, 0x3b, 0x5a, 0x2a, 0xab, 0x5a, 0xe2, 0xc8, 0x12,
	0x28, 0xaa, 0x4a, 0x56, 0x0a, 0xd2, 0x1e, 0x40, 0x08, 0x25, 0x05, 0xad, 0x56, 0x42, 0xbb, 0xab,
	0xd9, 0xbd, 0x2c, 0x37, 0x3b, 0x1e, 0xd2, 0x51, 0x1d, 0x8f, 0xb1, 0x9d, 0x56, 0xe9, 0x09, 0xfe,
	0x01, 0xff, 0x84, 0x0b, 0x47, 0x24, 0xae, 0x1c, 0x8b, 0x10, 0x82, 0x93, 0x85, 0x5a, 0x89, 0x43,
	0xb8, 0xe5, 0x17, 0xa0, 0x79, 0x33, 0x8e, 0x9d, 0xec, 0x6a, 0xe9, 0x85, 0x03, 0xa7, 0x7c, 0xef,
	0x9b, 0x6f, 0x9e, 0xdf, 0xbc, 0xf7, 0xe6, 0x4d, 0x50, 0x2b, 0x08, 0xae, 0x06, 0x71, 0x22, 0x32,
	0x41, 0xcc, 0x20, 0xb8, 0x3a, 0xfa, 0x60, 0xca, 0xb3, 0xb3, 0xb9, 0x3f, 0x98, 0x88, 0xd9, 0xc3,
	0xa9, 0x98, 0x8a, 0x87, 0xb0, 0xe6, 0xcf, 0xbf, 0x02, 0x0b, 0x0c, 0x40, 0x6a, 0x8f, 0xfb, 0x43,
	0x1d, 0x35, 0x9e, 0x87, 0xde, 0x82, 0x25, 0xe4, 0x7d, 0x54, 0xe3, 0x81, 0x6d, 0xf4, 0x8c, 0xbe,
	0x35, 0x3e, 0x5c, 0xe5, 0x0e, 0xf1, 0x53, 0x11, 0x7d, 0xe4, 0xf2, 0xc0, 0xed, 0xcd, 0xd2, 0x29,
	0x00, 0x5a, 0xe3, 0x01, 0x19, 0xa0, 0x3a, 0x9f, 0x88, 0xc8, 0xae, 0x81, 0xf2, 0x68, 0x95, 0x3b,
	0x87, 0x5a, 0x39, 0x11, 0x51, 0xa1, 0x95, 0x90, 0x82, 0x8e, 0x1c, 0x23, 0xf3, 0x82, 0xc7, 0xb6,
	0x09, 0x72, 0x7b, 0x95, 0x3b, 0xf7, 0x95, 0xfc, 0x82, 0xc7, 0x5a, 0x2d, 0x11, 0x95, 0x22, 0x32,
	0x44, 0xd6, 0xe4, 0xcc, 0xe3, 0x89, 0x5d, 0x07, 0xf5, 0x83, 0x55, 0xee, 0xd8, 0x4a, 0x0d, 0xb4,
	0xd6, 0x2b, 0x4c, 0x95, 0x54, 0xc6, 0x33, 0x11, 0x3c, 0xb2, 0xad, 0x9e, 0xd1, 0x37, 0xab, 0xf1,
	0x48, 0xb6, 0xd8, 0x21, 0x21, 0x05, 0x9d, 0x8c, 0xc7, 0x67, 0x99, 0xdd, 0x00, 0x79, 0x25, 0x1e,
	0x9f, 0x65, 0x5a, 0x2d, 0x11, 0x95, 0x22, 0xe9, 0x3b, 0xf2, 0x66, 0xcc, 0x6e, 0xf6, 0x8c, 0x7e,
	0xab, 0xea, 0x5b, 0xb2, 0x5a, 0x0d, 0x90, 0x82, 0x8e, 0x7c, 0x8e, 0xac, 0x34, 0xf3, 0x32, 0x66,
	0xef, 0xf6, 0x8c, 0xfe, 0xfe, 0xf0, 0xde, 0x40, 0x56, 0x47, 0xe5, 0x77, 0xf0, 0x42, 0x2e, 0x54,
	0x8f, 0x04, 0x4a, 0xed, 0x44, 0x61, 0xaa, 0x76, 0xcb, 0xcf, 0x9e, 0x79, 0x51, 0x60, 0xb7, 0xb6,
	0x53, 0x2c, 0x59, 0xbd, 0x03, 0x20, 0x05, 0x9d, 0xd4, 0x07, 0xe2, 0x32, 0xb2, 0x51, 0xcf, 0xe8,
	0xdf, 0xab, 0xea, 0x25, 0xab, 0xf5, 0x00, 0x29, 0xe8, 0xdc, 0x4f, 0x91, 0x05, 0xd1, 0x90, 0x5d,
	0x54, 0x7f, 0x2a, 0x22, 0x86, 0x77, 0x48, 0x0b, 0x59, 0x94, 0x79, 0xc1, 0x02, 0x1b, 0xa4, 0x8d,
	0x9a, 0x32, 0x64, 0x1e, 0x4d, 0x71, 0x4d, 0xf2, 0x2f, 0x93, 0x79, 0x9a, 0x61, 0x53, 0xc2, 0x2f,
	0x98, 0x77, 0xc1, 0x70, 0xd3, 0xfd, 0xde, 0x40, 0xad, 0xd1, 0x24, 0xe3, 0x22, 0xa2, 0xec, 0x6b,
	0xf2, 0x18, 0xd5, 0xb3, 0x45, 0xcc, 0xa0, 0x77, 0xf6, 0x87, 0x07, 0x70, 0x68, 0xb5, 0xfa, 0x72,
	0x11, 0xb3, 0xb1, 0xbb, 0xcc, 0x1d, 0x10, 0x94, 0x71, 0x49, 0x4b, 0xc7, 0x05, 0x90, 0xc2, 0x3a,
	0x79, 0x85, 0xac, 0x58, 0x9c, 0xb3, 0x04, 0x7a, 0xab, 0x33, 0x3e, 0x5d, 0xe6, 0xce, 0x01, 0x10,
	0x27, 0x62, 0xc6, 0x33, 0x36, 0x8b, 0xb3, 0xc5, 0x2a, 0x77, 0x4e, 0x94, 0x8f, 0xad, 0x05, 0xed,
	0x6e, 0x9b, 0xa5, 0xca, 0xa3, 0xfb, 0x4d, 0xad, 0x88, 0x78, 0x34, 0x39, 0xff, 0x3f, 0x44, 0x4c,
	0x9e, 0x21, 0x73, 0xce, 0x03, 0x7d, 0x6f, 0x3e, 0x59, 0xe6, 0xce, 0xde, 0x9c, 0x07, 0x1b, 0x6e,
	0xfb, 0xca, 0xed, 0x06, 0xad, 0x9d, 0x6e, 0x72, 0x54, 0x7a, 0x72, 0x7f, 0x34, 0x51, 0xfb, 0xb1,
	0x37, 0x63, 0x4f, 0x22, 0x9e, 0xc9, 0x24, 0x0c, 0x91, 0x95, 0x79, 0x7e, 0xc8, 0xf4, 0x9d, 0xaf,
	0x74, 0x26, 0xd0, 0xc5, 0x69, 0x01, 0x53, 0x25, 0xd5, 0x43, 0xa2, 0xf6, 0xaf, 0x43, 0x62, 0x58,
	0x5c, 0x84, 0xd7, 0x2e, 0xf2, 0x5b, 0xbb, 0x3e, 0xe1, 0xd1, 0x14, 0x2e, 0xf2, 0x46, 0xd7, 0x4b,
	0x56, 0xef, 0x00, 0x48, 0x41, 0x47, 0x46, 0xa8, 0x19, 0xc3, 0xd5, 0x4a, 0xed, 0x46, 0xcf, 0xec,
	0xb7, 0x87, 0xed, 0xca, 0x75, 0xab, 0xee, 0x97, 0xaa, 0x22, 0xd9, 0x12, 0xd2, 0x62, 0x5f, 0x59,
	0xbe, 0xe6, 0x7f, 0x52, 0xbe, 0x54, 0x0d, 0x82, 0x8e, 0x2e, 0x5f, 0xca, 0xde, 0x58, 0xbe, 0x2a,
	0x5d, 0x94, 0x6f, 0x83, 0xa3, 0xd2, 0x93, 0xfb, 0x93, 0x81, 0x3a, 0xb2, 0x7c, 0x2f, 0x32, 0x2f,
	0x81, 0xfa, 0x9d, 0x54, 0x06, 0xf6, 0x83, 0x65, 0xee, 0xd4, 0x78, 0xf0, 0x96, 0x8a, 0x3c, 0x42,
	0xf5, 0x58, 0x88, 0x10, 0x6a, 0x67, 0xaa, 0x0e, 0x97, 0x76, 0x25, 0x4b, 0x42, 0x84, 0xeb, 0x33,
	0x89, 0xd0, 0xa5, 0xb0, 0x4e, 0x9e, 0x94, 0x59, 0x36, 0x5f, 0xcf, 0xb2, 0xf2, 0x13, 0x7a, 0x8b,
	0x3b, 0x64, 0xdb, 0xfd, 0xbb, 0x86, 0xf6, 0xe4, 0x09, 0x28, 0x4b, 0xe7, 0x21, 0x1c, 0xe1, 0xae,
	0x6f, 0xce, 0x23, 0xd4, 0xb8, 0xe4, 0x51, 0x04, 0xf7, 0xcc, 0xec, 0x5b, 0xe3, 0xee, 0x2a, 0x77,
	0x8e, 0x94, 0x56, 0xf1, 0x5a, 0xaf, 0x0d, 0xaa, 0xd5, 0xb2, 0x0d, 0xe3, 0x84, 0x5f, 0x31, 0x08,
	0xdd, 0xac, 0xb6, 0x21, 0xd0, 0x45, 0x98, 0x80, 0xa9, 0x92, 0xae, 0xdf, 0x93, 0xfa, 0x1d, 0xdf,
	0x93, 0x8f, 0x8b, 0x1e, 0xb2, 0xa0, 0xd4, 0xef, 0x2d, 0x73, 0x47, 0x11, 0x95, 0x8f, 0xc1, 0x08,
	0xaa, 0xf4, 0xcb, 0xba, 0x4b, 0x5e, 0x21, 0x2b, 0x9c, 0x4f, 0xce, 0x17, 0xfa, 0x39, 0x82, 0x06,
	0x04, 0xe2, 0x4d, 0x0d, 0xb8, 0xb5, 0xa0, 0x1d, 0x6e, 0xb3, 0x54, 0x79, 0x3c, 0xfe, 0xd6, 0x40,
	0xf5, 0x53, 0x11, 0x30, 0xd2, 0x41, 0xbb, 0xf2, 0x57, 0x0f, 0x7a, 0x82, 0xf6, 0xa4, 0xb5, 0x9e,
	0xde, 0xf8, 0x7a, 0xb4, 0xc9, 0x8d, 0x26, 0xe7, 0xf8, 0x97, 0x11, 0xb9, 0x8f, 0x0e, 0x24, 0x57,
	0x19, 0x18, 0xf8, 0xd7, 0x11, 0x79, 0x07, 0xe1, 0x82, 0x2d, 0xfa, 0x10, 0xff, 0x36, 0x22, 0x87,
	0xe8, 0x5e, 0x41, 0xaf, 0x8b, 0x8b, 0x7f, 0x1f, 0x1d, 0xff, 0x65, 0x20, 0x54, 0xce, 0x55, 0xb2,
	0x5f, 0x58, 0x3a, 0x96, 0x03, 0xd4, 0x2e, 0xe2, 0x50, 0x4f, 0xcf, 0x5a, 0x70, 0xea, 0x85, 0x21,
	0xae, 0x95, 0x82, 0xa7, 0x82, 0x0a, 0x1f, 0x9b, 0x64, 0x6f, 0xfd, 0xee, 0x08, 0x1f, 0xd7, 0x4b,
	0xf3, 0x59, 0xc4, 0xb0, 0x45, 0x30, 0xea, 0x28, 0xf3, 0x33, 0x31, 0xf7, 0x43, 0x86, 0x1b, 0x25,
	0x33, 0x16, 0x59, 0x26, 0x66, 0xb8, 0x59, 0x7e, 0xe2, 0xb9, 0x97, 0xa6, 0x78, 0xb7, 0x62, 0x87,
	0xde, 0x02, 0xb7, 0x08, 0x41, 0xfb, 0x3a, 0x0f, 0xbe, 0x48, 0xe4, 0x2f, 0x46, 0xd5, 0x38, 0x23,
	0x76, 0x89, 0xdb, 0x25, 0xa1, 0x1e, 0xc4, 0xce, 0xf8, 0xdd, 0x9f, 0x6f, 0xba, 0xc6, 0xf5, 0x4d,
	0xd7, 0xf8, 0xf3, 0xa6, 0x6b, 0x7c, 0x77, 0xdb, 0xdd, 0xb9, 0xbe, 0xed, 0xee, 0xfc, 0x71, 0xdb,
	0xdd, 0xf9, 0x52, 0xfe, 0x2b, 0xf3, 0x1b, 0xf0, 0x6f, 0xeb, 0xc3, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x11, 0xb1, 0x20, 0x81, 0xae, 0x09, 0x00, 0x00,
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Player) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Down != 0 {
		i = encodeVarintDdz(dAtA, i, uint64((uint32(m.Down)<<1)^uint32((m.Down>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.Hand != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Hand))
		i--
		dAtA[i] = 0x48
	}
	if m.State != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDdz(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Bet != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Bet))
		i--
		dAtA[i] = 0x30
	}
	if m.Coin != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Coin))
		i--
		dAtA[i] = 0x28
	}
	if m.Chair != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Chair))
		i--
		dAtA[i] = 0x20
	}
	if m.Vip != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Vip))
		i--
		dAtA[i] = 0x18
	}
	if m.Icon != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Icon))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Poker) > 0 {
		i -= len(m.Poker)
		copy(dAtA[i:], m.Poker)
		i = encodeVarintDdz(dAtA, i, uint64(len(m.Poker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Poker) > 0 {
		i -= len(m.Poker)
		copy(dAtA[i:], m.Poker)
		i = encodeVarintDdz(dAtA, i, uint64(len(m.Poker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameInitAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInitAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameInitAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Use) > 0 {
		i -= len(m.Use)
		copy(dAtA[i:], m.Use)
		i = encodeVarintDdz(dAtA, i, uint64(len(m.Use)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Poker) > 0 {
		i -= len(m.Poker)
		copy(dAtA[i:], m.Poker)
		i = encodeVarintDdz(dAtA, i, uint64(len(m.Poker)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDdz(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Ring != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Ring))
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Id != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Table != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Table))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameStartAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameStartAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameStartAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDdz(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Pool != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Pool))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameResultAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameResultAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameResultAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lucky != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Lucky))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Poker) > 0 {
		i -= len(m.Poker)
		copy(dAtA[i:], m.Poker)
		i = encodeVarintDdz(dAtA, i, uint64(len(m.Poker)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Coin != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Coin))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Prize) > 0 {
		dAtA2 := make([]byte, len(m.Prize)*10)
		var j1 int
		for _, num1 := range m.Prize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintDdz(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Winner) > 0 {
		dAtA4 := make([]byte, len(m.Winner)*10)
		var j3 int
		for _, num1 := range m.Winner {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintDdz(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintDdz(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDdz(dAtA []byte, offset int, v uint64) int {
	offset -= sovDdz(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDdz(uint64(m.Id))
	}
	if m.Icon != 0 {
		n += 1 + sovDdz(uint64(m.Icon))
	}
	if m.Vip != 0 {
		n += 1 + sovDdz(uint64(m.Vip))
	}
	if m.Chair != 0 {
		n += 1 + sovDdz(uint64(m.Chair))
	}
	if m.Coin != 0 {
		n += 1 + sovDdz(uint64(m.Coin))
	}
	if m.Bet != 0 {
		n += 1 + sovDdz(uint64(m.Bet))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDdz(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovDdz(uint64(m.State))
	}
	if m.Hand != 0 {
		n += 1 + sovDdz(uint64(m.Hand))
	}
	if m.Down != 0 {
		n += 1 + sozDdz(uint64(m.Down))
	}
	return n
}

func (m *ActionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDdz(uint64(m.Type))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovDdz(uint64(l))
	}
	return n
}

func (m *ActionAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovDdz(uint64(m.Type))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovDdz(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovDdz(uint64(m.Uid))
	}
	return n
}

func (m *GameInitAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Table != 0 {
		n += 1 + sovDdz(uint64(m.Table))
	}
	if m.Id != 0 {
		n += 1 + sovDdz(uint64(m.Id))
	}
	if m.State != 0 {
		n += 1 + sovDdz(uint64(m.State))
	}
	if m.Ring != 0 {
		n += 1 + sovDdz(uint64(m.Ring))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovDdz(uint64(l))
		}
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovDdz(uint64(l))
	}
	l = len(m.Use)
	if l > 0 {
		n += 1 + l + sovDdz(uint64(l))
	}
	return n
}

func (m *GameStartAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDdz(uint64(m.Id))
	}
	if m.Pool != 0 {
		n += 1 + sovDdz(uint64(m.Pool))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovDdz(uint64(l))
		}
	}
	return n
}

func (m *GameResultAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovDdz(uint64(m.Id))
	}
	if len(m.Winner) > 0 {
		l = 0
		for _, e := range m.Winner {
			l += sovDdz(uint64(e))
		}
		n += 1 + sovDdz(uint64(l)) + l
	}
	if len(m.Prize) > 0 {
		l = 0
		for _, e := range m.Prize {
			l += sovDdz(uint64(e))
		}
		n += 1 + sovDdz(uint64(l)) + l
	}
	if m.Coin != 0 {
		n += 1 + sovDdz(uint64(m.Coin))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovDdz(uint64(l))
	}
	if m.Lucky != 0 {
		n += 1 + sovDdz(uint64(m.Lucky))
	}
	return n
}

func sovDdz(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDdz(x uint64) (n int) {
	return sovDdz(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			m.Icon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chair", wireType)
			}
			m.Chair = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chair |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDdz
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDdz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Player_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hand", wireType)
			}
			m.Hand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Down = v
		default:
			iNdEx = preIndex
			skippy, err := skipDdz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDdz
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDdz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDdz
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDdz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDdz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInitAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInitAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInitAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			m.Ring = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ring |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDdz
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDdz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Use", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDdz
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDdz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Use = append(m.Use[:0], dAtA[iNdEx:postIndex]...)
			if m.Use == nil {
				m.Use = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameStartAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameStartAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameStartAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDdz
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDdz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDdz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameResultAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDdz
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameResultAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameResultAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDdz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winner = append(m.Winner, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDdz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDdz
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDdz
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Winner) == 0 {
					m.Winner = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDdz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Winner = append(m.Winner, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Winner", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDdz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Prize = append(m.Prize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDdz
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthDdz
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthDdz
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Prize) == 0 {
					m.Prize = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDdz
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Prize = append(m.Prize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDdz
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDdz
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDdz(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthDdz
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDdz(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDdz
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDdz
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDdz
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDdz
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDdz
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDdz        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDdz          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDdz = fmt.Errorf("proto: unexpected end of group")
)
