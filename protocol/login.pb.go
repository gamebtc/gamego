// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: login.proto

package protocol

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 握手返回
type Handshake struct {
	Code int32    `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty" bson:"code" msg:"code"`
	Seed int32    `protobuf:"varint,2,opt,name=seed,proto3" json:"seed,omitempty" bson:"seed" msg:"seed"`
	Msg  string   `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty" bson:"msg" msg:"msg"`
	Ip   []string `protobuf:"bytes,4,rep,name=ip,proto3" json:"ip,omitempty" bson:"ip" msg:"ip"`
}

func (m *Handshake) Reset()         { *m = Handshake{} }
func (m *Handshake) String() string { return proto.CompactTextString(m) }
func (*Handshake) ProtoMessage()    {}
func (*Handshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{0}
}
func (m *Handshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Handshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Handshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Handshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Handshake.Merge(dst, src)
}
func (m *Handshake) XXX_Size() int {
	return m.Size()
}
func (m *Handshake) XXX_DiscardUnknown() {
	xxx_messageInfo_Handshake.DiscardUnknown(m)
}

var xxx_messageInfo_Handshake proto.InternalMessageInfo

func (m *Handshake) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *Handshake) GetSeed() int32 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *Handshake) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Handshake) GetIp() []string {
	if m != nil {
		return m.Ip
	}
	return nil
}

// 心跳请求
type HeartBeatReq struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
}

func (m *HeartBeatReq) Reset()         { *m = HeartBeatReq{} }
func (m *HeartBeatReq) String() string { return proto.CompactTextString(m) }
func (*HeartBeatReq) ProtoMessage()    {}
func (*HeartBeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{1}
}
func (m *HeartBeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartBeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartBeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HeartBeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartBeatReq.Merge(dst, src)
}
func (m *HeartBeatReq) XXX_Size() int {
	return m.Size()
}
func (m *HeartBeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartBeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_HeartBeatReq proto.InternalMessageInfo

func (m *HeartBeatReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 心跳回复
type HeartBeatAck struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
}

func (m *HeartBeatAck) Reset()         { *m = HeartBeatAck{} }
func (m *HeartBeatAck) String() string { return proto.CompactTextString(m) }
func (*HeartBeatAck) ProtoMessage()    {}
func (*HeartBeatAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{2}
}
func (m *HeartBeatAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartBeatAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartBeatAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HeartBeatAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartBeatAck.Merge(dst, src)
}
func (m *HeartBeatAck) XXX_Size() int {
	return m.Size()
}
func (m *HeartBeatAck) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartBeatAck.DiscardUnknown(m)
}

var xxx_messageInfo_HeartBeatAck proto.InternalMessageInfo

func (m *HeartBeatAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

// 一般性错误回复,0代表成功
type ErrorInfo struct {
	ReqId int32  `protobuf:"varint,1,opt,name=reqId,proto3" json:"reqId,omitempty" bson:"reqId" msg:"reqId"`
	Code  int32  `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty" bson:"code" msg:"code"`
	Msg   string `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty" bson:"msg" msg:"msg"`
	Key   string `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty" bson:"key" msg:"key"`
}

func (m *ErrorInfo) Reset()         { *m = ErrorInfo{} }
func (m *ErrorInfo) String() string { return proto.CompactTextString(m) }
func (*ErrorInfo) ProtoMessage()    {}
func (*ErrorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{3}
}
func (m *ErrorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ErrorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ErrorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ErrorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ErrorInfo.Merge(dst, src)
}
func (m *ErrorInfo) XXX_Size() int {
	return m.Size()
}
func (m *ErrorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ErrorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ErrorInfo proto.InternalMessageInfo

func (m *ErrorInfo) GetReqId() int32 {
	if m != nil {
		return m.ReqId
	}
	return 0
}

func (m *ErrorInfo) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ErrorInfo) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ErrorInfo) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// 严重错误回复,0代表成功
type FatalInfo struct {
	ReqId int32  `protobuf:"varint,1,opt,name=reqId,proto3" json:"reqId,omitempty" bson:"reqId" msg:"reqId"`
	Code  int32  `protobuf:"varint,2,opt,name=code,proto3" json:"code,omitempty" bson:"code" msg:"code"`
	Msg   string `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty" bson:"msg" msg:"msg"`
	Key   string `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty" bson:"key" msg:"key"`
}

func (m *FatalInfo) Reset()         { *m = FatalInfo{} }
func (m *FatalInfo) String() string { return proto.CompactTextString(m) }
func (*FatalInfo) ProtoMessage()    {}
func (*FatalInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{4}
}
func (m *FatalInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FatalInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FatalInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FatalInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FatalInfo.Merge(dst, src)
}
func (m *FatalInfo) XXX_Size() int {
	return m.Size()
}
func (m *FatalInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FatalInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FatalInfo proto.InternalMessageInfo

func (m *FatalInfo) GetReqId() int32 {
	if m != nil {
		return m.ReqId
	}
	return 0
}

func (m *FatalInfo) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FatalInfo) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *FatalInfo) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// 设备信息
type DeviceInfo struct {
	Id     string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	Vend   string `protobuf:"bytes,2,opt,name=vend,proto3" json:"vend,omitempty" bson:"vend" msg:"vend"`
	Name   string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty" bson:"name" msg:"name"`
	Mac    string `protobuf:"bytes,4,opt,name=mac,proto3" json:"mac,omitempty" bson:"mac" msg:"mac"`
	Imei   string `protobuf:"bytes,5,opt,name=imei,proto3" json:"imei,omitempty" bson:"imei" msg:"imei"`
	Emid   string `protobuf:"bytes,6,opt,name=emid,proto3" json:"emid,omitempty" bson:"emid" msg:"emid"`
	Sn     string `protobuf:"bytes,7,opt,name=sn,proto3" json:"sn,omitempty" bson:"sn" msg:"sn"`
	OsLang string `protobuf:"bytes,8,opt,name=osLang,proto3" json:"osLang,omitempty" bson:"osLang" msg:"osLang"`
	OsVer  string `protobuf:"bytes,9,opt,name=osVer,proto3" json:"osVer,omitempty" bson:"osVer" msg:"osVer"`
	Other  string `protobuf:"bytes,10,opt,name=other,proto3" json:"other,omitempty" bson:"other" msg:"other"`
}

func (m *DeviceInfo) Reset()         { *m = DeviceInfo{} }
func (m *DeviceInfo) String() string { return proto.CompactTextString(m) }
func (*DeviceInfo) ProtoMessage()    {}
func (*DeviceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{5}
}
func (m *DeviceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DeviceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceInfo.Merge(dst, src)
}
func (m *DeviceInfo) XXX_Size() int {
	return m.Size()
}
func (m *DeviceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceInfo proto.InternalMessageInfo

func (m *DeviceInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeviceInfo) GetVend() string {
	if m != nil {
		return m.Vend
	}
	return ""
}

func (m *DeviceInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceInfo) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *DeviceInfo) GetImei() string {
	if m != nil {
		return m.Imei
	}
	return ""
}

func (m *DeviceInfo) GetEmid() string {
	if m != nil {
		return m.Emid
	}
	return ""
}

func (m *DeviceInfo) GetSn() string {
	if m != nil {
		return m.Sn
	}
	return ""
}

func (m *DeviceInfo) GetOsLang() string {
	if m != nil {
		return m.OsLang
	}
	return ""
}

func (m *DeviceInfo) GetOsVer() string {
	if m != nil {
		return m.OsVer
	}
	return ""
}

func (m *DeviceInfo) GetOther() string {
	if m != nil {
		return m.Other
	}
	return ""
}

// 应用环境信息
type Envirnment struct {
	App   int32  `protobuf:"varint,1,opt,name=app,proto3" json:"app,omitempty" bson:"app" msg:"app"`
	Pack  int32  `protobuf:"varint,2,opt,name=pack,proto3" json:"pack,omitempty" bson:"pack" msg:"pack"`
	Ver   string `protobuf:"bytes,3,opt,name=ver,proto3" json:"ver,omitempty" bson:"ver" msg:"ver"`
	Chan  string `protobuf:"bytes,4,opt,name=chan,proto3" json:"chan,omitempty" bson:"chan" msg:"chan"`
	Refer string `protobuf:"bytes,5,opt,name=refer,proto3" json:"refer,omitempty" bson:"refer" msg:"refer"`
	Other string `protobuf:"bytes,6,opt,name=other,proto3" json:"other,omitempty" bson:"other" msg:"other"`
}

func (m *Envirnment) Reset()         { *m = Envirnment{} }
func (m *Envirnment) String() string { return proto.CompactTextString(m) }
func (*Envirnment) ProtoMessage()    {}
func (*Envirnment) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{6}
}
func (m *Envirnment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Envirnment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Envirnment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Envirnment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Envirnment.Merge(dst, src)
}
func (m *Envirnment) XXX_Size() int {
	return m.Size()
}
func (m *Envirnment) XXX_DiscardUnknown() {
	xxx_messageInfo_Envirnment.DiscardUnknown(m)
}

var xxx_messageInfo_Envirnment proto.InternalMessageInfo

func (m *Envirnment) GetApp() int32 {
	if m != nil {
		return m.App
	}
	return 0
}

func (m *Envirnment) GetPack() int32 {
	if m != nil {
		return m.Pack
	}
	return 0
}

func (m *Envirnment) GetVer() string {
	if m != nil {
		return m.Ver
	}
	return ""
}

func (m *Envirnment) GetChan() string {
	if m != nil {
		return m.Chan
	}
	return ""
}

func (m *Envirnment) GetRefer() string {
	if m != nil {
		return m.Refer
	}
	return ""
}

func (m *Envirnment) GetOther() string {
	if m != nil {
		return m.Other
	}
	return ""
}

// 检查版本
type VerCheckReq struct {
	Env   *Envirnment `protobuf:"bytes,1,opt,name=env,proto3" json:"env,omitempty" bson:"env" msg:"env"`
	Time  int32       `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty" bson:"time" msg:"time"`
	Check int32       `protobuf:"varint,3,opt,name=check,proto3" json:"check,omitempty" bson:"check" msg:"check"`
}

func (m *VerCheckReq) Reset()         { *m = VerCheckReq{} }
func (m *VerCheckReq) String() string { return proto.CompactTextString(m) }
func (*VerCheckReq) ProtoMessage()    {}
func (*VerCheckReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{7}
}
func (m *VerCheckReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerCheckReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerCheckReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerCheckReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerCheckReq.Merge(dst, src)
}
func (m *VerCheckReq) XXX_Size() int {
	return m.Size()
}
func (m *VerCheckReq) XXX_DiscardUnknown() {
	xxx_messageInfo_VerCheckReq.DiscardUnknown(m)
}

var xxx_messageInfo_VerCheckReq proto.InternalMessageInfo

func (m *VerCheckReq) GetEnv() *Envirnment {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *VerCheckReq) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *VerCheckReq) GetCheck() int32 {
	if m != nil {
		return m.Check
	}
	return 0
}

// 检查版本
type VerCheckAck struct {
	Code     int32             `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty" bson:"code" msg:"code"`
	Msg      string            `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty" bson:"msg" msg:"msg"`
	CanReg   int32             `protobuf:"varint,3,opt,name=canReg,proto3" json:"canReg,omitempty" bson:"canReg" msg:"canReg"`
	CanLogin int32             `protobuf:"varint,4,opt,name=canLogin,proto3" json:"canLogin,omitempty" bson:"canLogin" msg:"canLogin"`
	Url      string            `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty" bson:"url" msg:"url"`
	Country  string            `protobuf:"bytes,6,opt,name=country,proto3" json:"country,omitempty" bson:"country" msg:"country"`
	Region   string            `protobuf:"bytes,7,opt,name=region,proto3" json:"region,omitempty" bson:"region" msg:"region"`
	City     string            `protobuf:"bytes,8,opt,name=city,proto3" json:"city,omitempty" bson:"city" msg:"city"`
	Conf     map[string]string `protobuf:"bytes,9,rep,name=conf,proto3" json:"conf,omitempty" bson:"conf" msg:"conf" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *VerCheckAck) Reset()         { *m = VerCheckAck{} }
func (m *VerCheckAck) String() string { return proto.CompactTextString(m) }
func (*VerCheckAck) ProtoMessage()    {}
func (*VerCheckAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{8}
}
func (m *VerCheckAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerCheckAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerCheckAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VerCheckAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerCheckAck.Merge(dst, src)
}
func (m *VerCheckAck) XXX_Size() int {
	return m.Size()
}
func (m *VerCheckAck) XXX_DiscardUnknown() {
	xxx_messageInfo_VerCheckAck.DiscardUnknown(m)
}

var xxx_messageInfo_VerCheckAck proto.InternalMessageInfo

func (m *VerCheckAck) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *VerCheckAck) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *VerCheckAck) GetCanReg() int32 {
	if m != nil {
		return m.CanReg
	}
	return 0
}

func (m *VerCheckAck) GetCanLogin() int32 {
	if m != nil {
		return m.CanLogin
	}
	return 0
}

func (m *VerCheckAck) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *VerCheckAck) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *VerCheckAck) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *VerCheckAck) GetCity() string {
	if m != nil {
		return m.City
	}
	return ""
}

func (m *VerCheckAck) GetConf() map[string]string {
	if m != nil {
		return m.Conf
	}
	return nil
}

// 用户登录请求
type LoginReq struct {
	Type int32       `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty" bson:"type" msg:"type"`
	Name string      `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" bson:"name" msg:"name"`
	Pwd  string      `protobuf:"bytes,3,opt,name=pwd,proto3" json:"pwd,omitempty" bson:"pwd" msg:"pwd"`
	Udid string      `protobuf:"bytes,4,opt,name=udid,proto3" json:"udid,omitempty" bson:"udid" msg:"udid"`
	Uid  int32       `protobuf:"varint,5,opt,name=uid,proto3" json:"uid,omitempty" bson:"uid" msg:"uid"`
	Time int32       `protobuf:"varint,6,opt,name=time,proto3" json:"time,omitempty" bson:"time" msg:"time"`
	Dev  *DeviceInfo `protobuf:"bytes,7,opt,name=dev,proto3" json:"dev,omitempty" bson:"dev" msg:"dev"`
	Env  *Envirnment `protobuf:"bytes,8,opt,name=env,proto3" json:"env,omitempty" bson:"env" msg:"env"`
}

func (m *LoginReq) Reset()         { *m = LoginReq{} }
func (m *LoginReq) String() string { return proto.CompactTextString(m) }
func (*LoginReq) ProtoMessage()    {}
func (*LoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{9}
}
func (m *LoginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginReq.Merge(dst, src)
}
func (m *LoginReq) XXX_Size() int {
	return m.Size()
}
func (m *LoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_LoginReq proto.InternalMessageInfo

func (m *LoginReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *LoginReq) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoginReq) GetPwd() string {
	if m != nil {
		return m.Pwd
	}
	return ""
}

func (m *LoginReq) GetUdid() string {
	if m != nil {
		return m.Udid
	}
	return ""
}

func (m *LoginReq) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LoginReq) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *LoginReq) GetDev() *DeviceInfo {
	if m != nil {
		return m.Dev
	}
	return nil
}

func (m *LoginReq) GetEnv() *Envirnment {
	if m != nil {
		return m.Env
	}
	return nil
}

// 用户登录成功消息
type LoginSuccessAck struct {
	Id    int32            `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"_id" msg:"id"`
	Agent int64            `protobuf:"varint,2,opt,name=agent,proto3" json:"agent,omitempty" bson:"agent" msg:"agent"`
	Icon  int32            `protobuf:"varint,3,opt,name=icon,proto3" json:"icon,omitempty" bson:"icon" msg:"icon"`
	Sex   int32            `protobuf:"varint,4,opt,name=sex,proto3" json:"sex,omitempty" bson:"sex" msg:"sex"`
	Vip   int32            `protobuf:"varint,5,opt,name=vip,proto3" json:"vip,omitempty" bson:"vip" msg:"vip"`
	Act   string           `protobuf:"bytes,6,opt,name=act,proto3" json:"act,omitempty" bson:"act" msg:"act"`
	Name  string           `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty" bson:"name" msg:"name"`
	Phone string           `protobuf:"bytes,8,opt,name=phone,proto3" json:"phone,omitempty" bson:"phone" msg:"phone"`
	Bag   map[string]int64 `protobuf:"bytes,9,rep,name=bag,proto3" json:"bag,omitempty" bson:"bag" msg:"bag" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Kind  int32            `protobuf:"varint,10,opt,name=kind,proto3" json:"kind,omitempty" bson:"kind" msg:"kind"`
	Level int32            `protobuf:"varint,11,opt,name=level,proto3" json:"level,omitempty" bson:"level" msg:"level"`
	Room  int32            `protobuf:"varint,12,opt,name=room,proto3" json:"room,omitempty" bson:"room" msg:"room"`
}

func (m *LoginSuccessAck) Reset()         { *m = LoginSuccessAck{} }
func (m *LoginSuccessAck) String() string { return proto.CompactTextString(m) }
func (*LoginSuccessAck) ProtoMessage()    {}
func (*LoginSuccessAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{10}
}
func (m *LoginSuccessAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginSuccessAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginSuccessAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LoginSuccessAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginSuccessAck.Merge(dst, src)
}
func (m *LoginSuccessAck) XXX_Size() int {
	return m.Size()
}
func (m *LoginSuccessAck) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginSuccessAck.DiscardUnknown(m)
}

var xxx_messageInfo_LoginSuccessAck proto.InternalMessageInfo

func (m *LoginSuccessAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LoginSuccessAck) GetAgent() int64 {
	if m != nil {
		return m.Agent
	}
	return 0
}

func (m *LoginSuccessAck) GetIcon() int32 {
	if m != nil {
		return m.Icon
	}
	return 0
}

func (m *LoginSuccessAck) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *LoginSuccessAck) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *LoginSuccessAck) GetAct() string {
	if m != nil {
		return m.Act
	}
	return ""
}

func (m *LoginSuccessAck) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoginSuccessAck) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *LoginSuccessAck) GetBag() map[string]int64 {
	if m != nil {
		return m.Bag
	}
	return nil
}

func (m *LoginSuccessAck) GetKind() int32 {
	if m != nil {
		return m.Kind
	}
	return 0
}

func (m *LoginSuccessAck) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *LoginSuccessAck) GetRoom() int32 {
	if m != nil {
		return m.Room
	}
	return 0
}

// 用户登录失败消息
type LoginFailAck struct {
	Code int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty" bson:"code" msg:"code"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty" bson:"msg" msg:"msg"`
}

func (m *LoginFailAck) Reset()         { *m = LoginFailAck{} }
func (m *LoginFailAck) String() string { return proto.CompactTextString(m) }
func (*LoginFailAck) ProtoMessage()    {}
func (*LoginFailAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_login_10172a2dcd465d5d, []int{11}
}
func (m *LoginFailAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginFailAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginFailAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LoginFailAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginFailAck.Merge(dst, src)
}
func (m *LoginFailAck) XXX_Size() int {
	return m.Size()
}
func (m *LoginFailAck) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginFailAck.DiscardUnknown(m)
}

var xxx_messageInfo_LoginFailAck proto.InternalMessageInfo

func (m *LoginFailAck) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *LoginFailAck) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*Handshake)(nil), "protocol.Handshake")
	proto.RegisterType((*HeartBeatReq)(nil), "protocol.HeartBeatReq")
	proto.RegisterType((*HeartBeatAck)(nil), "protocol.HeartBeatAck")
	proto.RegisterType((*ErrorInfo)(nil), "protocol.ErrorInfo")
	proto.RegisterType((*FatalInfo)(nil), "protocol.FatalInfo")
	proto.RegisterType((*DeviceInfo)(nil), "protocol.DeviceInfo")
	proto.RegisterType((*Envirnment)(nil), "protocol.Envirnment")
	proto.RegisterType((*VerCheckReq)(nil), "protocol.VerCheckReq")
	proto.RegisterType((*VerCheckAck)(nil), "protocol.VerCheckAck")
	proto.RegisterMapType((map[string]string)(nil), "protocol.VerCheckAck.ConfEntry")
	proto.RegisterType((*LoginReq)(nil), "protocol.LoginReq")
	proto.RegisterType((*LoginSuccessAck)(nil), "protocol.LoginSuccessAck")
	proto.RegisterMapType((map[string]int64)(nil), "protocol.LoginSuccessAck.BagEntry")
	proto.RegisterType((*LoginFailAck)(nil), "protocol.LoginFailAck")
}
func (m *Handshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Handshake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Code))
	}
	if m.Seed != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Seed))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *HeartBeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartBeatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *HeartBeatAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartBeatAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *ErrorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ErrorInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReqId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.ReqId))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *FatalInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FatalInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReqId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.ReqId))
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *DeviceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Vend) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Vend)))
		i += copy(dAtA[i:], m.Vend)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Mac) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Mac)))
		i += copy(dAtA[i:], m.Mac)
	}
	if len(m.Imei) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Imei)))
		i += copy(dAtA[i:], m.Imei)
	}
	if len(m.Emid) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Emid)))
		i += copy(dAtA[i:], m.Emid)
	}
	if len(m.Sn) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Sn)))
		i += copy(dAtA[i:], m.Sn)
	}
	if len(m.OsLang) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.OsLang)))
		i += copy(dAtA[i:], m.OsLang)
	}
	if len(m.OsVer) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.OsVer)))
		i += copy(dAtA[i:], m.OsVer)
	}
	if len(m.Other) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Other)))
		i += copy(dAtA[i:], m.Other)
	}
	return i, nil
}

func (m *Envirnment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Envirnment) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.App != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.App))
	}
	if m.Pack != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Pack))
	}
	if len(m.Ver) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Ver)))
		i += copy(dAtA[i:], m.Ver)
	}
	if len(m.Chan) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Chan)))
		i += copy(dAtA[i:], m.Chan)
	}
	if len(m.Refer) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Refer)))
		i += copy(dAtA[i:], m.Refer)
	}
	if len(m.Other) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Other)))
		i += copy(dAtA[i:], m.Other)
	}
	return i, nil
}

func (m *VerCheckReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerCheckReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Env != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Env.Size()))
		n1, err := m.Env.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Time))
	}
	if m.Check != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Check))
	}
	return i, nil
}

func (m *VerCheckAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerCheckAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.CanReg != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.CanReg))
	}
	if m.CanLogin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.CanLogin))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.Conf) > 0 {
		for k, _ := range m.Conf {
			dAtA[i] = 0x4a
			i++
			v := m.Conf[k]
			mapSize := 1 + len(k) + sovLogin(uint64(len(k))) + 1 + len(v) + sovLogin(uint64(len(v)))
			i = encodeVarintLogin(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLogin(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintLogin(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *LoginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Pwd) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Pwd)))
		i += copy(dAtA[i:], m.Pwd)
	}
	if len(m.Udid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Udid)))
		i += copy(dAtA[i:], m.Udid)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Uid))
	}
	if m.Time != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Time))
	}
	if m.Dev != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Dev.Size()))
		n2, err := m.Dev.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Env != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Env.Size()))
		n3, err := m.Env.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *LoginSuccessAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginSuccessAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Id))
	}
	if m.Agent != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Agent))
	}
	if m.Icon != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Icon))
	}
	if m.Sex != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Sex))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Vip))
	}
	if len(m.Act) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Act)))
		i += copy(dAtA[i:], m.Act)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if len(m.Bag) > 0 {
		for k, _ := range m.Bag {
			dAtA[i] = 0x4a
			i++
			v := m.Bag[k]
			mapSize := 1 + len(k) + sovLogin(uint64(len(k))) + 1 + sovLogin(uint64(v))
			i = encodeVarintLogin(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintLogin(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintLogin(dAtA, i, uint64(v))
		}
	}
	if m.Kind != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Kind))
	}
	if m.Level != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Level))
	}
	if m.Room != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Room))
	}
	return i, nil
}

func (m *LoginFailAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginFailAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintLogin(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintLogin(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func encodeVarintLogin(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Handshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovLogin(uint64(m.Code))
	}
	if m.Seed != 0 {
		n += 1 + sovLogin(uint64(m.Seed))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			l = len(s)
			n += 1 + l + sovLogin(uint64(l))
		}
	}
	return n
}

func (m *HeartBeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLogin(uint64(m.Id))
	}
	return n
}

func (m *HeartBeatAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLogin(uint64(m.Id))
	}
	return n
}

func (m *ErrorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqId != 0 {
		n += 1 + sovLogin(uint64(m.ReqId))
	}
	if m.Code != 0 {
		n += 1 + sovLogin(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	return n
}

func (m *FatalInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqId != 0 {
		n += 1 + sovLogin(uint64(m.ReqId))
	}
	if m.Code != 0 {
		n += 1 + sovLogin(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	return n
}

func (m *DeviceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Vend)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Imei)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Emid)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Sn)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.OsLang)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.OsVer)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Other)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	return n
}

func (m *Envirnment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.App != 0 {
		n += 1 + sovLogin(uint64(m.App))
	}
	if m.Pack != 0 {
		n += 1 + sovLogin(uint64(m.Pack))
	}
	l = len(m.Ver)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Chan)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Refer)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Other)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	return n
}

func (m *VerCheckReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Env != nil {
		l = m.Env.Size()
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovLogin(uint64(m.Time))
	}
	if m.Check != 0 {
		n += 1 + sovLogin(uint64(m.Check))
	}
	return n
}

func (m *VerCheckAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovLogin(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.CanReg != 0 {
		n += 1 + sovLogin(uint64(m.CanReg))
	}
	if m.CanLogin != 0 {
		n += 1 + sovLogin(uint64(m.CanLogin))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	if len(m.Conf) > 0 {
		for k, v := range m.Conf {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLogin(uint64(len(k))) + 1 + len(v) + sovLogin(uint64(len(v)))
			n += mapEntrySize + 1 + sovLogin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *LoginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovLogin(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Pwd)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Udid)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovLogin(uint64(m.Uid))
	}
	if m.Time != 0 {
		n += 1 + sovLogin(uint64(m.Time))
	}
	if m.Dev != nil {
		l = m.Dev.Size()
		n += 1 + l + sovLogin(uint64(l))
	}
	if m.Env != nil {
		l = m.Env.Size()
		n += 1 + l + sovLogin(uint64(l))
	}
	return n
}

func (m *LoginSuccessAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovLogin(uint64(m.Id))
	}
	if m.Agent != 0 {
		n += 1 + sovLogin(uint64(m.Agent))
	}
	if m.Icon != 0 {
		n += 1 + sovLogin(uint64(m.Icon))
	}
	if m.Sex != 0 {
		n += 1 + sovLogin(uint64(m.Sex))
	}
	if m.Vip != 0 {
		n += 1 + sovLogin(uint64(m.Vip))
	}
	l = len(m.Act)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	if len(m.Bag) > 0 {
		for k, v := range m.Bag {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovLogin(uint64(len(k))) + 1 + sovLogin(uint64(v))
			n += mapEntrySize + 1 + sovLogin(uint64(mapEntrySize))
		}
	}
	if m.Kind != 0 {
		n += 1 + sovLogin(uint64(m.Kind))
	}
	if m.Level != 0 {
		n += 1 + sovLogin(uint64(m.Level))
	}
	if m.Room != 0 {
		n += 1 + sovLogin(uint64(m.Room))
	}
	return n
}

func (m *LoginFailAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovLogin(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovLogin(uint64(l))
	}
	return n
}

func sovLogin(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozLogin(x uint64) (n int) {
	return sovLogin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Handshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Handshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Handshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartBeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartBeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartBeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartBeatAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartBeatAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartBeatAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ErrorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ErrorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ErrorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			m.ReqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FatalInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FatalInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FatalInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			m.ReqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vend", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vend = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imei", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imei = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsLang", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsLang = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Other = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Envirnment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Envirnment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Envirnment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			m.App = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.App |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pack", wireType)
			}
			m.Pack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pack |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chan", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chan = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Other", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Other = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerCheckReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerCheckReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerCheckReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = &Envirnment{}
			}
			if err := m.Env.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Check", wireType)
			}
			m.Check = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Check |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerCheckAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerCheckAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerCheckAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanReg", wireType)
			}
			m.CanReg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanReg |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanLogin", wireType)
			}
			m.CanLogin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanLogin |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLogin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLogin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLogin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthLogin
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLogin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLogin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Conf[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pwd = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Udid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Udid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dev", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dev == nil {
				m.Dev = &DeviceInfo{}
			}
			if err := m.Dev.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = &Envirnment{}
			}
			if err := m.Env.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginSuccessAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginSuccessAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginSuccessAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agent", wireType)
			}
			m.Agent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Agent |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			m.Icon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icon |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Act", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Act = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Bag == nil {
				m.Bag = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowLogin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLogin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthLogin
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowLogin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipLogin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthLogin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Bag[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			m.Room = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Room |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginFailAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginFailAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginFailAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogin
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthLogin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLogin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLogin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthLogin
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowLogin
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipLogin(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthLogin = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLogin   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("login.proto", fileDescriptor_login_10172a2dcd465d5d) }

var fileDescriptor_login_10172a2dcd465d5d = []byte{
	// 1224 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x96, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0xc0, 0x9b, 0x78, 0x93, 0x26, 0xb3, 0x2b, 0x81, 0xcc, 0xaa, 0x58, 0xab, 0x2a, 0x89, 0x7c,
	0x80, 0x55, 0x25, 0x52, 0x69, 0x91, 0x16, 0xb4, 0x07, 0x54, 0x52, 0xb6, 0x6a, 0xa5, 0x0a, 0xa4,
	0x41, 0xea, 0x15, 0x4d, 0xc6, 0x13, 0x67, 0x48, 0x3c, 0x76, 0x6d, 0xc7, 0xdd, 0xfd, 0x16, 0x7c,
	0x06, 0x0e, 0x9c, 0xb8, 0x71, 0xe4, 0xc0, 0x11, 0x8e, 0x3d, 0x72, 0x8a, 0xd0, 0xee, 0x85, 0x73,
	0x3e, 0x01, 0x7a, 0x6f, 0x66, 0x9c, 0x49, 0x52, 0x41, 0x8a, 0xc4, 0x81, 0x53, 0xde, 0xbc, 0xfc,
	0x9e, 0xfd, 0xe6, 0xfd, 0x35, 0x39, 0x9c, 0xa7, 0xb1, 0x54, 0xc3, 0x2c, 0x4f, 0xcb, 0xd4, 0xef,
	0xe0, 0x0f, 0x4f, 0xe7, 0x27, 0x1f, 0xc5, 0xb2, 0x9c, 0x2e, 0xc6, 0x43, 0x9e, 0x26, 0x0f, 0xe3,
	0x34, 0x4e, 0x1f, 0xe2, 0x3f, 0xe3, 0xc5, 0x04, 0x4f, 0x78, 0x40, 0x49, 0x1b, 0x86, 0xbf, 0x34,
	0x48, 0xf7, 0x29, 0x53, 0x51, 0x31, 0x65, 0x33, 0xe1, 0x0f, 0xc9, 0x01, 0x4f, 0x23, 0x11, 0x34,
	0x06, 0x8d, 0xd3, 0xd6, 0xe8, 0x64, 0xb5, 0xec, 0xdf, 0x1b, 0x17, 0xa9, 0xba, 0x08, 0x41, 0x1b,
	0x0e, 0x92, 0x22, 0x36, 0x22, 0x45, 0x0e, 0xf8, 0x42, 0x88, 0x28, 0x68, 0x6e, 0xf3, 0xa0, 0x35,
	0x3c, 0x8a, 0x14, 0x39, 0xff, 0x01, 0xf1, 0x92, 0x22, 0x0e, 0xbc, 0x41, 0xe3, 0xb4, 0x3b, 0x0a,
	0x56, 0xcb, 0xfe, 0xb1, 0xc6, 0x93, 0x22, 0x36, 0x34, 0x48, 0x14, 0x20, 0xff, 0x03, 0xd2, 0x94,
	0x59, 0x70, 0x30, 0xf0, 0x4e, 0xbb, 0xa3, 0x7b, 0xab, 0x65, 0xdf, 0xd7, 0xa8, 0xcc, 0x0c, 0x29,
	0xb3, 0x90, 0x36, 0x65, 0x16, 0x9e, 0x93, 0xa3, 0xa7, 0x82, 0xe5, 0xe5, 0x48, 0xb0, 0x92, 0x8a,
	0x97, 0x68, 0x17, 0x99, 0x1b, 0xb8, 0x76, 0xd6, 0x1f, 0x19, 0x81, 0x5d, 0xb4, 0x61, 0xf7, 0x39,
	0x9f, 0xed, 0x6d, 0xf7, 0x6b, 0x83, 0x74, 0x2f, 0xf3, 0x3c, 0xcd, 0x9f, 0xa9, 0x49, 0xea, 0x9f,
	0x91, 0x56, 0x2e, 0x5e, 0x3e, 0xb3, 0x86, 0xf7, 0x57, 0xcb, 0x7e, 0xa0, 0x0d, 0x51, 0x6d, 0x6c,
	0xb5, 0x4c, 0x35, 0x5a, 0x47, 0xb9, 0xb9, 0x67, 0x94, 0xdf, 0x26, 0x6a, 0x0f, 0x88, 0x37, 0x13,
	0xd7, 0xc1, 0xc1, 0x36, 0x3b, 0x13, 0xd7, 0x86, 0x05, 0x89, 0x02, 0x84, 0x37, 0x79, 0xc2, 0x4a,
	0x36, 0xff, 0xdf, 0xdf, 0xe4, 0x4f, 0x8f, 0x90, 0x2f, 0x44, 0x25, 0xb9, 0xc0, 0xab, 0xac, 0x53,
	0xd9, 0xfd, 0xbb, 0x54, 0x82, 0xfb, 0x95, 0x50, 0xba, 0x7c, 0xbb, 0xae, 0xfb, 0xa0, 0x35, 0x2c,
	0x8a, 0x14, 0x39, 0xe0, 0x15, 0x4b, 0x84, 0xf1, 0xdf, 0xe1, 0x41, 0x6b, 0x78, 0x14, 0x29, 0x72,
	0x78, 0x5d, 0xc6, 0x77, 0xaf, 0x90, 0x30, 0x6e, 0xaf, 0xcb, 0x38, 0x5c, 0x97, 0x71, 0x78, 0xb6,
	0x4c, 0x84, 0x0c, 0x5a, 0xdb, 0xcf, 0x06, 0xad, 0xf5, 0x1b, 0x44, 0x8a, 0x1c, 0xf0, 0x22, 0x91,
	0x51, 0xd0, 0xde, 0xe6, 0x41, 0x6b, 0x78, 0x14, 0x29, 0x72, 0x10, 0x93, 0x42, 0x05, 0x77, 0xb7,
	0x63, 0x52, 0x28, 0xdb, 0xa6, 0x2a, 0xa4, 0xcd, 0x42, 0xf9, 0xe7, 0xa4, 0x9d, 0x16, 0xcf, 0x99,
	0x8a, 0x83, 0x0e, 0xb2, 0xbd, 0xd5, 0xb2, 0x7f, 0xa2, 0x59, 0xad, 0x37, 0xbc, 0x39, 0x50, 0x43,
	0x43, 0xf9, 0xa4, 0xc5, 0x0b, 0x91, 0x07, 0x5d, 0x34, 0x73, 0xca, 0x07, 0xd5, 0xb5, 0x15, 0xc8,
	0x54, 0xa3, 0x68, 0x53, 0x4e, 0x45, 0x1e, 0x90, 0x1d, 0x1b, 0x50, 0x5b, 0x1b, 0x94, 0xa9, 0x46,
	0xc3, 0x1f, 0x9b, 0x84, 0x5c, 0xaa, 0x4a, 0xe6, 0x2a, 0x11, 0xaa, 0x84, 0x10, 0xb3, 0x2c, 0x33,
	0x35, 0xeb, 0x84, 0x98, 0x65, 0x76, 0x4e, 0x80, 0x44, 0x01, 0x82, 0x90, 0x65, 0x8c, 0xcf, 0x76,
	0xab, 0x15, 0xb4, 0x86, 0x46, 0x91, 0x22, 0x07, 0xcf, 0xae, 0x44, 0xbe, 0x5b, 0xad, 0x55, 0xed,
	0x1a, 0x48, 0x14, 0x20, 0xec, 0x84, 0x29, 0x53, 0x26, 0xd7, 0x6e, 0x27, 0x4c, 0x99, 0x0d, 0x31,
	0x8a, 0x14, 0x39, 0xdd, 0x6d, 0x13, 0x91, 0x9b, 0x7c, 0x6f, 0x74, 0xdb, 0xa4, 0x7e, 0xbe, 0x96,
	0xa9, 0x46, 0xd7, 0xe1, 0x6a, 0xef, 0x1f, 0xae, 0x9f, 0x1a, 0xe4, 0xf0, 0x85, 0xc8, 0x1f, 0x4f,
	0x05, 0x9f, 0xc1, 0x74, 0x7c, 0x44, 0x3c, 0xa1, 0x2a, 0x8c, 0xd7, 0xe1, 0xd9, 0xf1, 0xd0, 0xae,
	0x8d, 0xe1, 0x3a, 0xa4, 0xee, 0x4d, 0x85, 0xaa, 0x6c, 0x29, 0xa9, 0x2a, 0xa4, 0x60, 0x0a, 0x37,
	0x2d, 0x65, 0xf2, 0x86, 0x9e, 0x07, 0xad, 0xa1, 0x51, 0xa4, 0xc8, 0x81, 0xd7, 0x1c, 0xde, 0x8e,
	0x71, 0xdc, 0x98, 0x2b, 0xa8, 0xae, 0x63, 0x03, 0x32, 0xd5, 0x68, 0xf8, 0xf3, 0xc1, 0xda, 0x6b,
	0x98, 0xcd, 0x6f, 0xbb, 0x97, 0xcc, 0x9c, 0x69, 0xee, 0x33, 0x67, 0xce, 0x49, 0x9b, 0x33, 0x45,
	0x45, 0x6c, 0x1c, 0x74, 0x0a, 0x5e, 0xeb, 0xed, 0xf3, 0xf5, 0x81, 0x1a, 0xda, 0xff, 0x8c, 0x74,
	0x38, 0x53, 0xcf, 0x61, 0x09, 0x63, 0xd6, 0x5b, 0xa3, 0x70, 0xb5, 0xec, 0xf7, 0x6a, 0x4b, 0xfc,
	0x67, 0x6d, 0xab, 0x8f, 0xb4, 0xb6, 0x01, 0x1f, 0x17, 0xf9, 0xdc, 0xe4, 0xdf, 0xf1, 0x71, 0x91,
	0xcf, 0x8d, 0x15, 0x48, 0x14, 0x20, 0xff, 0x82, 0xdc, 0xe5, 0xe9, 0x42, 0x95, 0xf9, 0xb5, 0xc9,
	0xfd, 0x60, 0xb5, 0xec, 0xdf, 0xb7, 0x21, 0xc0, 0x3f, 0xea, 0x28, 0xe8, 0x13, 0xb5, 0x06, 0x70,
	0xbf, 0x5c, 0xc4, 0x32, 0xb5, 0xcd, 0xef, 0xdc, 0x4f, 0xeb, 0xeb, 0x5a, 0xc3, 0x03, 0x35, 0x34,
	0xc6, 0x5c, 0x96, 0xd7, 0x66, 0x0c, 0xb8, 0x31, 0x97, 0x65, 0xfd, 0x36, 0x10, 0x29, 0x72, 0xfe,
	0x57, 0x90, 0x23, 0x35, 0x09, 0xba, 0x03, 0xef, 0xf4, 0xf0, 0xac, 0xbf, 0x2e, 0x2d, 0x27, 0x91,
	0xc3, 0xc7, 0xa9, 0x9a, 0x5c, 0x82, 0x5b, 0x9b, 0x49, 0x54, 0x93, 0xda, 0x7d, 0x35, 0xc1, 0x24,
	0xaa, 0xc9, 0xc9, 0x27, 0xa4, 0x5b, 0xe3, 0xfe, 0xbb, 0x7a, 0x1b, 0xe0, 0x4c, 0xc7, 0x99, 0xef,
	0x1f, 0x93, 0x56, 0xc5, 0xe6, 0x0b, 0x5d, 0x88, 0x5d, 0xaa, 0x0f, 0x17, 0xcd, 0x4f, 0x1b, 0xe1,
	0x0f, 0x1e, 0xe9, 0x60, 0x8c, 0xa1, 0xe0, 0xa1, 0x5c, 0xaf, 0xb3, 0x37, 0x94, 0x0e, 0x68, 0x6d,
	0xb9, 0x82, 0x48, 0x91, 0xab, 0x67, 0x7c, 0x73, 0xff, 0x19, 0x9f, 0xbd, 0x8a, 0x76, 0x87, 0x44,
	0xf6, 0xca, 0x4e, 0x61, 0x90, 0x28, 0x40, 0xf0, 0xec, 0x45, 0x24, 0xa3, 0xdd, 0x21, 0x01, 0x5a,
	0x9b, 0xf4, 0x08, 0x67, 0x36, 0xfc, 0x60, 0x89, 0xc8, 0x08, 0x4b, 0x64, 0x63, 0xb8, 0x2d, 0xd6,
	0x34, 0xc0, 0x00, 0xd5, 0x6d, 0xd9, 0xde, 0xb3, 0x2d, 0x1f, 0x11, 0x2f, 0x12, 0x15, 0xd6, 0xc4,
	0xc6, 0x20, 0x58, 0xaf, 0x51, 0xf7, 0x8d, 0x91, 0xb0, 0x83, 0x00, 0x24, 0x0a, 0xa6, 0x76, 0x94,
	0x74, 0xfe, 0xf5, 0x28, 0x09, 0xbf, 0x6f, 0x91, 0x77, 0x30, 0x51, 0x5f, 0x2f, 0x38, 0x17, 0x45,
	0x01, 0xad, 0xfe, 0xa1, 0xf3, 0x19, 0xf6, 0xfe, 0x6a, 0xd9, 0x7f, 0x4f, 0x9b, 0x7f, 0xb3, 0xb3,
	0xbc, 0xcf, 0x48, 0x8b, 0xc5, 0x42, 0x95, 0x98, 0x29, 0xcf, 0x9d, 0x2b, 0xa8, 0xb6, 0xd3, 0x1f,
	0x65, 0xaa, 0x51, 0x5c, 0xb2, 0x3c, 0x55, 0xa6, 0xd3, 0xdd, 0x25, 0xcb, 0xeb, 0x3e, 0x40, 0x91,
	0x22, 0x07, 0x09, 0x28, 0xc4, 0x95, 0x69, 0x6f, 0xe7, 0x32, 0x85, 0xb8, 0xaa, 0xbf, 0x6e, 0xaf,
	0x42, 0x0a, 0x10, 0x6e, 0x0b, 0x99, 0xed, 0x26, 0xab, 0xaa, 0xbf, 0x58, 0x41, 0xa2, 0x00, 0xe1,
	0xd6, 0xe2, 0xa5, 0xe9, 0x65, 0x77, 0x6b, 0xf1, 0xda, 0x6f, 0x5e, 0xc2, 0xd6, 0xe2, 0x65, 0x5d,
	0x90, 0x77, 0xf7, 0x2c, 0xc8, 0x33, 0xd2, 0xca, 0xa6, 0xa9, 0x12, 0xa6, 0x71, 0x9d, 0xb8, 0xa0,
	0xda, 0x16, 0x25, 0xca, 0x54, 0xa3, 0xfe, 0x97, 0xc4, 0x1b, 0xb3, 0xd8, 0xb4, 0x6e, 0xb8, 0x4e,
	0xe5, 0x56, 0x72, 0x86, 0x23, 0x16, 0xeb, 0xee, 0x75, 0x7c, 0x1e, 0x33, 0x3b, 0x21, 0x41, 0xa2,
	0xf0, 0x20, 0xf0, 0x79, 0x26, 0x55, 0x84, 0x7b, 0x7d, 0x23, 0xce, 0xa0, 0xb5, 0x5f, 0x6f, 0x12,
	0x3f, 0xac, 0xe0, 0x07, 0x7c, 0x9e, 0x8b, 0x4a, 0xcc, 0x83, 0xc3, 0xed, 0x1d, 0x81, 0x6a, 0x63,
	0xa1, 0x65, 0xaa, 0x51, 0x78, 0x47, 0x9e, 0xa6, 0x49, 0x70, 0xb4, 0xfd, 0x0e, 0xd0, 0xda, 0x99,
	0x06, 0x22, 0x45, 0xee, 0xe4, 0x9c, 0x74, 0xac, 0xfb, 0xff, 0x34, 0x4d, 0x3c, 0x77, 0x9a, 0x7c,
	0x4b, 0x8e, 0x30, 0x0c, 0x4f, 0x98, 0x9c, 0xff, 0xc7, 0xbb, 0x68, 0x14, 0xfc, 0x76, 0xd3, 0x6b,
	0xbc, 0xbe, 0xe9, 0x35, 0xfe, 0xb8, 0xe9, 0x35, 0xbe, 0xbb, 0xed, 0xdd, 0x79, 0x7d, 0xdb, 0xbb,
	0xf3, 0xfb, 0x6d, 0xef, 0xce, 0xb8, 0x8d, 0x39, 0xf9, 0xf8, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x60, 0xd5, 0x18, 0x68, 0xf6, 0x0d, 0x00, 0x00,
}
