package fish

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	_ "github.com/gogo/protobuf/gogoproto"
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Bullet) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "uid":
			z.Uid, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Uid")
				return
			}
		case "client":
			z.Client, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Client")
				return
			}
		case "created":
			z.Created, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Created")
				return
			}
		case "bet":
			z.Bet, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Bet")
				return
			}
		case "direction":
			z.Direction, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Direction")
				return
			}
		case "x":
			z.X, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "X")
				return
			}
		case "y":
			z.Y, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Y")
				return
			}
		case "fish":
			z.Fish, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Fish")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Bullet) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "id"
	err = en.Append(0x89, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Id)
	if err != nil {
		err = msgp.WrapError(err, "Id")
		return
	}
	// write "uid"
	err = en.Append(0xa3, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Uid)
	if err != nil {
		err = msgp.WrapError(err, "Uid")
		return
	}
	// write "client"
	err = en.Append(0xa6, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Client)
	if err != nil {
		err = msgp.WrapError(err, "Client")
		return
	}
	// write "created"
	err = en.Append(0xa7, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Created)
	if err != nil {
		err = msgp.WrapError(err, "Created")
		return
	}
	// write "bet"
	err = en.Append(0xa3, 0x62, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Bet)
	if err != nil {
		err = msgp.WrapError(err, "Bet")
		return
	}
	// write "direction"
	err = en.Append(0xa9, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Direction)
	if err != nil {
		err = msgp.WrapError(err, "Direction")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.X)
	if err != nil {
		err = msgp.WrapError(err, "X")
		return
	}
	// write "y"
	err = en.Append(0xa1, 0x79)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Y)
	if err != nil {
		err = msgp.WrapError(err, "Y")
		return
	}
	// write "fish"
	err = en.Append(0xa4, 0x66, 0x69, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Fish)
	if err != nil {
		err = msgp.WrapError(err, "Fish")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Bullet) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "id"
	o = append(o, 0x89, 0xa2, 0x69, 0x64)
	o = msgp.AppendInt32(o, z.Id)
	// string "uid"
	o = append(o, 0xa3, 0x75, 0x69, 0x64)
	o = msgp.AppendInt32(o, z.Uid)
	// string "client"
	o = append(o, 0xa6, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt32(o, z.Client)
	// string "created"
	o = append(o, 0xa7, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.Created)
	// string "bet"
	o = append(o, 0xa3, 0x62, 0x65, 0x74)
	o = msgp.AppendInt32(o, z.Bet)
	// string "direction"
	o = append(o, 0xa9, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendFloat64(o, z.Direction)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendFloat64(o, z.X)
	// string "y"
	o = append(o, 0xa1, 0x79)
	o = msgp.AppendFloat64(o, z.Y)
	// string "fish"
	o = append(o, 0xa4, 0x66, 0x69, 0x73, 0x68)
	o = msgp.AppendInt32(o, z.Fish)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Bullet) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "uid":
			z.Uid, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Uid")
				return
			}
		case "client":
			z.Client, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Client")
				return
			}
		case "created":
			z.Created, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Created")
				return
			}
		case "bet":
			z.Bet, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bet")
				return
			}
		case "direction":
			z.Direction, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Direction")
				return
			}
		case "x":
			z.X, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "X")
				return
			}
		case "y":
			z.Y, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Y")
				return
			}
		case "fish":
			z.Fish, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Fish")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Bullet) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int32Size + 4 + msgp.Int32Size + 7 + msgp.Int32Size + 8 + msgp.Int64Size + 4 + msgp.Int32Size + 10 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 5 + msgp.Int32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Code) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 int32
		zb0001, err = dc.ReadInt32()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Code(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Code) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteInt32(int32(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Code) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendInt32(o, int32(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Code) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 int32
		zb0001, bts, err = msgp.ReadInt32Bytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = Code(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Code) Msgsize() (s int) {
	s = msgp.Int32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Fish) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "tmpId":
			z.TmpId, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "TmpId")
				return
			}
		case "pathId":
			z.PathId, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "PathId")
				return
			}
		case "boxId":
			z.BoxId, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "BoxId")
				return
			}
		case "speed":
			z.Speed, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Speed")
				return
			}
		case "created":
			z.Created, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Created")
				return
			}
		case "direction":
			z.Direction, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Direction")
				return
			}
		case "x":
			z.X, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "X")
				return
			}
		case "y":
			z.Y, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Y")
				return
			}
		case "troop":
			z.Troop, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Troop")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Fish) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "id"
	err = en.Append(0x8a, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Id)
	if err != nil {
		err = msgp.WrapError(err, "Id")
		return
	}
	// write "tmpId"
	err = en.Append(0xa5, 0x74, 0x6d, 0x70, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.TmpId)
	if err != nil {
		err = msgp.WrapError(err, "TmpId")
		return
	}
	// write "pathId"
	err = en.Append(0xa6, 0x70, 0x61, 0x74, 0x68, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.PathId)
	if err != nil {
		err = msgp.WrapError(err, "PathId")
		return
	}
	// write "boxId"
	err = en.Append(0xa5, 0x62, 0x6f, 0x78, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.BoxId)
	if err != nil {
		err = msgp.WrapError(err, "BoxId")
		return
	}
	// write "speed"
	err = en.Append(0xa5, 0x73, 0x70, 0x65, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Speed)
	if err != nil {
		err = msgp.WrapError(err, "Speed")
		return
	}
	// write "created"
	err = en.Append(0xa7, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Created)
	if err != nil {
		err = msgp.WrapError(err, "Created")
		return
	}
	// write "direction"
	err = en.Append(0xa9, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Direction)
	if err != nil {
		err = msgp.WrapError(err, "Direction")
		return
	}
	// write "x"
	err = en.Append(0xa1, 0x78)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.X)
	if err != nil {
		err = msgp.WrapError(err, "X")
		return
	}
	// write "y"
	err = en.Append(0xa1, 0x79)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Y)
	if err != nil {
		err = msgp.WrapError(err, "Y")
		return
	}
	// write "troop"
	err = en.Append(0xa5, 0x74, 0x72, 0x6f, 0x6f, 0x70)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Troop)
	if err != nil {
		err = msgp.WrapError(err, "Troop")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Fish) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "id"
	o = append(o, 0x8a, 0xa2, 0x69, 0x64)
	o = msgp.AppendInt32(o, z.Id)
	// string "tmpId"
	o = append(o, 0xa5, 0x74, 0x6d, 0x70, 0x49, 0x64)
	o = msgp.AppendInt32(o, z.TmpId)
	// string "pathId"
	o = append(o, 0xa6, 0x70, 0x61, 0x74, 0x68, 0x49, 0x64)
	o = msgp.AppendInt32(o, z.PathId)
	// string "boxId"
	o = append(o, 0xa5, 0x62, 0x6f, 0x78, 0x49, 0x64)
	o = msgp.AppendInt32(o, z.BoxId)
	// string "speed"
	o = append(o, 0xa5, 0x73, 0x70, 0x65, 0x65, 0x64)
	o = msgp.AppendFloat64(o, z.Speed)
	// string "created"
	o = append(o, 0xa7, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.Created)
	// string "direction"
	o = append(o, 0xa9, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendFloat64(o, z.Direction)
	// string "x"
	o = append(o, 0xa1, 0x78)
	o = msgp.AppendFloat64(o, z.X)
	// string "y"
	o = append(o, 0xa1, 0x79)
	o = msgp.AppendFloat64(o, z.Y)
	// string "troop"
	o = append(o, 0xa5, 0x74, 0x72, 0x6f, 0x6f, 0x70)
	o = msgp.AppendBool(o, z.Troop)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Fish) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "tmpId":
			z.TmpId, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TmpId")
				return
			}
		case "pathId":
			z.PathId, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PathId")
				return
			}
		case "boxId":
			z.BoxId, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BoxId")
				return
			}
		case "speed":
			z.Speed, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Speed")
				return
			}
		case "created":
			z.Created, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Created")
				return
			}
		case "direction":
			z.Direction, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Direction")
				return
			}
		case "x":
			z.X, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "X")
				return
			}
		case "y":
			z.Y, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Y")
				return
			}
		case "troop":
			z.Troop, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Troop")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Fish) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int32Size + 6 + msgp.Int32Size + 7 + msgp.Int32Size + 6 + msgp.Int32Size + 6 + msgp.Float64Size + 8 + msgp.Int64Size + 10 + msgp.Float64Size + 2 + msgp.Float64Size + 2 + msgp.Float64Size + 6 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *FishSeed) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "speed":
			z.Speed, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Speed")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z FishSeed) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "id"
	err = en.Append(0x82, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Id)
	if err != nil {
		err = msgp.WrapError(err, "Id")
		return
	}
	// write "speed"
	err = en.Append(0xa5, 0x73, 0x70, 0x65, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Speed)
	if err != nil {
		err = msgp.WrapError(err, "Speed")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z FishSeed) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "id"
	o = append(o, 0x82, 0xa2, 0x69, 0x64)
	o = msgp.AppendInt32(o, z.Id)
	// string "speed"
	o = append(o, 0xa5, 0x73, 0x70, 0x65, 0x65, 0x64)
	o = msgp.AppendFloat64(o, z.Speed)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FishSeed) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "speed":
			z.Speed, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Speed")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z FishSeed) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int32Size + 6 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GameInitAck) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "table":
			z.Table, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Table")
				return
			}
		case "tick":
			z.Tick, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Tick")
				return
			}
		case "scene":
			z.Scene, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Scene")
				return
			}
		case "play":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0002) {
				z.Players = (z.Players)[:zb0002]
			} else {
				z.Players = make([]*Player, zb0002)
			}
			for za0001 := range z.Players {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Players", za0001)
						return
					}
					z.Players[za0001] = nil
				} else {
					if z.Players[za0001] == nil {
						z.Players[za0001] = new(Player)
					}
					err = z.Players[za0001].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Players", za0001)
						return
					}
				}
			}
		case "fishes":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Fishes")
				return
			}
			if cap(z.Fishes) >= int(zb0003) {
				z.Fishes = (z.Fishes)[:zb0003]
			} else {
				z.Fishes = make([]*Fish, zb0003)
			}
			for za0002 := range z.Fishes {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Fishes", za0002)
						return
					}
					z.Fishes[za0002] = nil
				} else {
					if z.Fishes[za0002] == nil {
						z.Fishes[za0002] = new(Fish)
					}
					err = z.Fishes[za0002].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Fishes", za0002)
						return
					}
				}
			}
		case "bull":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Bullets")
				return
			}
			if cap(z.Bullets) >= int(zb0004) {
				z.Bullets = (z.Bullets)[:zb0004]
			} else {
				z.Bullets = make([]*Bullet, zb0004)
			}
			for za0003 := range z.Bullets {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Bullets", za0003)
						return
					}
					z.Bullets[za0003] = nil
				} else {
					if z.Bullets[za0003] == nil {
						z.Bullets[za0003] = new(Bullet)
					}
					err = z.Bullets[za0003].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Bullets", za0003)
						return
					}
				}
			}
		case "maxBullet":
			z.MaxBullet, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "MaxBullet")
				return
			}
		case "fireInterval":
			z.FireInterval, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "FireInterval")
				return
			}
		case "stopFire":
			z.StopFire, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "StopFire")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GameInitAck) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 9
	// write "table"
	err = en.Append(0x89, 0xa5, 0x74, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Table)
	if err != nil {
		err = msgp.WrapError(err, "Table")
		return
	}
	// write "tick"
	err = en.Append(0xa4, 0x74, 0x69, 0x63, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Tick)
	if err != nil {
		err = msgp.WrapError(err, "Tick")
		return
	}
	// write "scene"
	err = en.Append(0xa5, 0x73, 0x63, 0x65, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Scene)
	if err != nil {
		err = msgp.WrapError(err, "Scene")
		return
	}
	// write "play"
	err = en.Append(0xa4, 0x70, 0x6c, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Players)))
	if err != nil {
		err = msgp.WrapError(err, "Players")
		return
	}
	for za0001 := range z.Players {
		if z.Players[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Players[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Players", za0001)
				return
			}
		}
	}
	// write "fishes"
	err = en.Append(0xa6, 0x66, 0x69, 0x73, 0x68, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Fishes)))
	if err != nil {
		err = msgp.WrapError(err, "Fishes")
		return
	}
	for za0002 := range z.Fishes {
		if z.Fishes[za0002] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Fishes[za0002].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Fishes", za0002)
				return
			}
		}
	}
	// write "bull"
	err = en.Append(0xa4, 0x62, 0x75, 0x6c, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Bullets)))
	if err != nil {
		err = msgp.WrapError(err, "Bullets")
		return
	}
	for za0003 := range z.Bullets {
		if z.Bullets[za0003] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bullets[za0003].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Bullets", za0003)
				return
			}
		}
	}
	// write "maxBullet"
	err = en.Append(0xa9, 0x6d, 0x61, 0x78, 0x42, 0x75, 0x6c, 0x6c, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.MaxBullet)
	if err != nil {
		err = msgp.WrapError(err, "MaxBullet")
		return
	}
	// write "fireInterval"
	err = en.Append(0xac, 0x66, 0x69, 0x72, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.FireInterval)
	if err != nil {
		err = msgp.WrapError(err, "FireInterval")
		return
	}
	// write "stopFire"
	err = en.Append(0xa8, 0x73, 0x74, 0x6f, 0x70, 0x46, 0x69, 0x72, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.StopFire)
	if err != nil {
		err = msgp.WrapError(err, "StopFire")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GameInitAck) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 9
	// string "table"
	o = append(o, 0x89, 0xa5, 0x74, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendInt32(o, z.Table)
	// string "tick"
	o = append(o, 0xa4, 0x74, 0x69, 0x63, 0x6b)
	o = msgp.AppendInt64(o, z.Tick)
	// string "scene"
	o = append(o, 0xa5, 0x73, 0x63, 0x65, 0x6e, 0x65)
	o = msgp.AppendInt32(o, z.Scene)
	// string "play"
	o = append(o, 0xa4, 0x70, 0x6c, 0x61, 0x79)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Players)))
	for za0001 := range z.Players {
		if z.Players[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Players[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Players", za0001)
				return
			}
		}
	}
	// string "fishes"
	o = append(o, 0xa6, 0x66, 0x69, 0x73, 0x68, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Fishes)))
	for za0002 := range z.Fishes {
		if z.Fishes[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Fishes[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Fishes", za0002)
				return
			}
		}
	}
	// string "bull"
	o = append(o, 0xa4, 0x62, 0x75, 0x6c, 0x6c)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Bullets)))
	for za0003 := range z.Bullets {
		if z.Bullets[za0003] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bullets[za0003].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Bullets", za0003)
				return
			}
		}
	}
	// string "maxBullet"
	o = append(o, 0xa9, 0x6d, 0x61, 0x78, 0x42, 0x75, 0x6c, 0x6c, 0x65, 0x74)
	o = msgp.AppendInt32(o, z.MaxBullet)
	// string "fireInterval"
	o = append(o, 0xac, 0x66, 0x69, 0x72, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c)
	o = msgp.AppendInt32(o, z.FireInterval)
	// string "stopFire"
	o = append(o, 0xa8, 0x73, 0x74, 0x6f, 0x70, 0x46, 0x69, 0x72, 0x65)
	o = msgp.AppendBool(o, z.StopFire)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GameInitAck) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "table":
			z.Table, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Table")
				return
			}
		case "tick":
			z.Tick, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tick")
				return
			}
		case "scene":
			z.Scene, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Scene")
				return
			}
		case "play":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0002) {
				z.Players = (z.Players)[:zb0002]
			} else {
				z.Players = make([]*Player, zb0002)
			}
			for za0001 := range z.Players {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Players[za0001] = nil
				} else {
					if z.Players[za0001] == nil {
						z.Players[za0001] = new(Player)
					}
					bts, err = z.Players[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Players", za0001)
						return
					}
				}
			}
		case "fishes":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Fishes")
				return
			}
			if cap(z.Fishes) >= int(zb0003) {
				z.Fishes = (z.Fishes)[:zb0003]
			} else {
				z.Fishes = make([]*Fish, zb0003)
			}
			for za0002 := range z.Fishes {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Fishes[za0002] = nil
				} else {
					if z.Fishes[za0002] == nil {
						z.Fishes[za0002] = new(Fish)
					}
					bts, err = z.Fishes[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fishes", za0002)
						return
					}
				}
			}
		case "bull":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bullets")
				return
			}
			if cap(z.Bullets) >= int(zb0004) {
				z.Bullets = (z.Bullets)[:zb0004]
			} else {
				z.Bullets = make([]*Bullet, zb0004)
			}
			for za0003 := range z.Bullets {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Bullets[za0003] = nil
				} else {
					if z.Bullets[za0003] == nil {
						z.Bullets[za0003] = new(Bullet)
					}
					bts, err = z.Bullets[za0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Bullets", za0003)
						return
					}
				}
			}
		case "maxBullet":
			z.MaxBullet, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxBullet")
				return
			}
		case "fireInterval":
			z.FireInterval, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FireInterval")
				return
			}
		case "stopFire":
			z.StopFire, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StopFire")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GameInitAck) Msgsize() (s int) {
	s = 1 + 6 + msgp.Int32Size + 5 + msgp.Int64Size + 6 + msgp.Int32Size + 5 + msgp.ArrayHeaderSize
	for za0001 := range z.Players {
		if z.Players[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Players[za0001].Msgsize()
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0002 := range z.Fishes {
		if z.Fishes[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Fishes[za0002].Msgsize()
		}
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0003 := range z.Bullets {
		if z.Bullets[za0003] == nil {
			s += msgp.NilSize
		} else {
			s += z.Bullets[za0003].Msgsize()
		}
	}
	s += 10 + msgp.Int32Size + 13 + msgp.Int32Size + 9 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GameUpdateAck) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "stopFire":
			z.StopFire, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "StopFire")
				return
			}
		case "tick":
			z.Tick, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Tick")
				return
			}
		case "switchScene":
			z.SwitchScene, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "SwitchScene")
				return
			}
		case "play":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0002) {
				z.Players = (z.Players)[:zb0002]
			} else {
				z.Players = make([]*Player, zb0002)
			}
			for za0001 := range z.Players {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Players", za0001)
						return
					}
					z.Players[za0001] = nil
				} else {
					if z.Players[za0001] == nil {
						z.Players[za0001] = new(Player)
					}
					err = z.Players[za0001].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Players", za0001)
						return
					}
				}
			}
		case "fishes":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Fishes")
				return
			}
			if cap(z.Fishes) >= int(zb0003) {
				z.Fishes = (z.Fishes)[:zb0003]
			} else {
				z.Fishes = make([]*Fish, zb0003)
			}
			for za0002 := range z.Fishes {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Fishes", za0002)
						return
					}
					z.Fishes[za0002] = nil
				} else {
					if z.Fishes[za0002] == nil {
						z.Fishes[za0002] = new(Fish)
					}
					err = z.Fishes[za0002].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Fishes", za0002)
						return
					}
				}
			}
		case "bull":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Bullets")
				return
			}
			if cap(z.Bullets) >= int(zb0004) {
				z.Bullets = (z.Bullets)[:zb0004]
			} else {
				z.Bullets = make([]*Bullet, zb0004)
			}
			for za0003 := range z.Bullets {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Bullets", za0003)
						return
					}
					z.Bullets[za0003] = nil
				} else {
					if z.Bullets[za0003] == nil {
						z.Bullets[za0003] = new(Bullet)
					}
					err = z.Bullets[za0003].DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Bullets", za0003)
						return
					}
				}
			}
		case "dieBullets":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DieBullets")
				return
			}
			if cap(z.DieBullets) >= int(zb0005) {
				z.DieBullets = (z.DieBullets)[:zb0005]
			} else {
				z.DieBullets = make([]int32, zb0005)
			}
			for za0004 := range z.DieBullets {
				z.DieBullets[za0004], err = dc.ReadInt32()
				if err != nil {
					err = msgp.WrapError(err, "DieBullets", za0004)
					return
				}
			}
		case "dieFishes":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "DieFishes")
				return
			}
			if cap(z.DieFishes) >= int(zb0006) {
				z.DieFishes = (z.DieFishes)[:zb0006]
			} else {
				z.DieFishes = make([]int32, zb0006)
			}
			for za0005 := range z.DieFishes {
				z.DieFishes[za0005], err = dc.ReadInt32()
				if err != nil {
					err = msgp.WrapError(err, "DieFishes", za0005)
					return
				}
			}
		case "kills":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Kills")
				return
			}
			if cap(z.Kills) >= int(zb0007) {
				z.Kills = (z.Kills)[:zb0007]
			} else {
				z.Kills = make([]*KillFish, zb0007)
			}
			for za0006 := range z.Kills {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Kills", za0006)
						return
					}
					z.Kills[za0006] = nil
				} else {
					if z.Kills[za0006] == nil {
						z.Kills[za0006] = new(KillFish)
					}
					var zb0008 uint32
					zb0008, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Kills", za0006)
						return
					}
					for zb0008 > 0 {
						zb0008--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Kills", za0006)
							return
						}
						switch msgp.UnsafeString(field) {
						case "id":
							z.Kills[za0006].Id, err = dc.ReadInt32()
							if err != nil {
								err = msgp.WrapError(err, "Kills", za0006, "Id")
								return
							}
						case "uid":
							z.Kills[za0006].Uid, err = dc.ReadInt32()
							if err != nil {
								err = msgp.WrapError(err, "Kills", za0006, "Uid")
								return
							}
						case "score":
							z.Kills[za0006].Score, err = dc.ReadInt64()
							if err != nil {
								err = msgp.WrapError(err, "Kills", za0006, "Score")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Kills", za0006)
								return
							}
						}
					}
				}
			}
		case "seed":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Seed")
				return
			}
			if cap(z.Seed) >= int(zb0009) {
				z.Seed = (z.Seed)[:zb0009]
			} else {
				z.Seed = make([]*FishSeed, zb0009)
			}
			for za0007 := range z.Seed {
				if dc.IsNil() {
					err = dc.ReadNil()
					if err != nil {
						err = msgp.WrapError(err, "Seed", za0007)
						return
					}
					z.Seed[za0007] = nil
				} else {
					if z.Seed[za0007] == nil {
						z.Seed[za0007] = new(FishSeed)
					}
					var zb0010 uint32
					zb0010, err = dc.ReadMapHeader()
					if err != nil {
						err = msgp.WrapError(err, "Seed", za0007)
						return
					}
					for zb0010 > 0 {
						zb0010--
						field, err = dc.ReadMapKeyPtr()
						if err != nil {
							err = msgp.WrapError(err, "Seed", za0007)
							return
						}
						switch msgp.UnsafeString(field) {
						case "id":
							z.Seed[za0007].Id, err = dc.ReadInt32()
							if err != nil {
								err = msgp.WrapError(err, "Seed", za0007, "Id")
								return
							}
						case "speed":
							z.Seed[za0007].Speed, err = dc.ReadFloat64()
							if err != nil {
								err = msgp.WrapError(err, "Seed", za0007, "Speed")
								return
							}
						default:
							err = dc.Skip()
							if err != nil {
								err = msgp.WrapError(err, "Seed", za0007)
								return
							}
						}
					}
				}
			}
		case "offline":
			var zb0011 uint32
			zb0011, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
			if cap(z.Offline) >= int(zb0011) {
				z.Offline = (z.Offline)[:zb0011]
			} else {
				z.Offline = make([]int32, zb0011)
			}
			for za0008 := range z.Offline {
				z.Offline[za0008], err = dc.ReadInt32()
				if err != nil {
					err = msgp.WrapError(err, "Offline", za0008)
					return
				}
			}
		case "describe":
			var zb0012 uint32
			zb0012, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Describe")
				return
			}
			if cap(z.Describe) >= int(zb0012) {
				z.Describe = (z.Describe)[:zb0012]
			} else {
				z.Describe = make([]string, zb0012)
			}
			for za0009 := range z.Describe {
				z.Describe[za0009], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Describe", za0009)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GameUpdateAck) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 12
	// write "stopFire"
	err = en.Append(0x8c, 0xa8, 0x73, 0x74, 0x6f, 0x70, 0x46, 0x69, 0x72, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.StopFire)
	if err != nil {
		err = msgp.WrapError(err, "StopFire")
		return
	}
	// write "tick"
	err = en.Append(0xa4, 0x74, 0x69, 0x63, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Tick)
	if err != nil {
		err = msgp.WrapError(err, "Tick")
		return
	}
	// write "switchScene"
	err = en.Append(0xab, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x53, 0x63, 0x65, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.SwitchScene)
	if err != nil {
		err = msgp.WrapError(err, "SwitchScene")
		return
	}
	// write "play"
	err = en.Append(0xa4, 0x70, 0x6c, 0x61, 0x79)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Players)))
	if err != nil {
		err = msgp.WrapError(err, "Players")
		return
	}
	for za0001 := range z.Players {
		if z.Players[za0001] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Players[za0001].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Players", za0001)
				return
			}
		}
	}
	// write "fishes"
	err = en.Append(0xa6, 0x66, 0x69, 0x73, 0x68, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Fishes)))
	if err != nil {
		err = msgp.WrapError(err, "Fishes")
		return
	}
	for za0002 := range z.Fishes {
		if z.Fishes[za0002] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Fishes[za0002].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Fishes", za0002)
				return
			}
		}
	}
	// write "bull"
	err = en.Append(0xa4, 0x62, 0x75, 0x6c, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Bullets)))
	if err != nil {
		err = msgp.WrapError(err, "Bullets")
		return
	}
	for za0003 := range z.Bullets {
		if z.Bullets[za0003] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Bullets[za0003].EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Bullets", za0003)
				return
			}
		}
	}
	// write "dieBullets"
	err = en.Append(0xaa, 0x64, 0x69, 0x65, 0x42, 0x75, 0x6c, 0x6c, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DieBullets)))
	if err != nil {
		err = msgp.WrapError(err, "DieBullets")
		return
	}
	for za0004 := range z.DieBullets {
		err = en.WriteInt32(z.DieBullets[za0004])
		if err != nil {
			err = msgp.WrapError(err, "DieBullets", za0004)
			return
		}
	}
	// write "dieFishes"
	err = en.Append(0xa9, 0x64, 0x69, 0x65, 0x46, 0x69, 0x73, 0x68, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.DieFishes)))
	if err != nil {
		err = msgp.WrapError(err, "DieFishes")
		return
	}
	for za0005 := range z.DieFishes {
		err = en.WriteInt32(z.DieFishes[za0005])
		if err != nil {
			err = msgp.WrapError(err, "DieFishes", za0005)
			return
		}
	}
	// write "kills"
	err = en.Append(0xa5, 0x6b, 0x69, 0x6c, 0x6c, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Kills)))
	if err != nil {
		err = msgp.WrapError(err, "Kills")
		return
	}
	for za0006 := range z.Kills {
		if z.Kills[za0006] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 3
			// write "id"
			err = en.Append(0x83, 0xa2, 0x69, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt32(z.Kills[za0006].Id)
			if err != nil {
				err = msgp.WrapError(err, "Kills", za0006, "Id")
				return
			}
			// write "uid"
			err = en.Append(0xa3, 0x75, 0x69, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt32(z.Kills[za0006].Uid)
			if err != nil {
				err = msgp.WrapError(err, "Kills", za0006, "Uid")
				return
			}
			// write "score"
			err = en.Append(0xa5, 0x73, 0x63, 0x6f, 0x72, 0x65)
			if err != nil {
				return
			}
			err = en.WriteInt64(z.Kills[za0006].Score)
			if err != nil {
				err = msgp.WrapError(err, "Kills", za0006, "Score")
				return
			}
		}
	}
	// write "seed"
	err = en.Append(0xa4, 0x73, 0x65, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Seed)))
	if err != nil {
		err = msgp.WrapError(err, "Seed")
		return
	}
	for za0007 := range z.Seed {
		if z.Seed[za0007] == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			// map header, size 2
			// write "id"
			err = en.Append(0x82, 0xa2, 0x69, 0x64)
			if err != nil {
				return
			}
			err = en.WriteInt32(z.Seed[za0007].Id)
			if err != nil {
				err = msgp.WrapError(err, "Seed", za0007, "Id")
				return
			}
			// write "speed"
			err = en.Append(0xa5, 0x73, 0x70, 0x65, 0x65, 0x64)
			if err != nil {
				return
			}
			err = en.WriteFloat64(z.Seed[za0007].Speed)
			if err != nil {
				err = msgp.WrapError(err, "Seed", za0007, "Speed")
				return
			}
		}
	}
	// write "offline"
	err = en.Append(0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Offline)))
	if err != nil {
		err = msgp.WrapError(err, "Offline")
		return
	}
	for za0008 := range z.Offline {
		err = en.WriteInt32(z.Offline[za0008])
		if err != nil {
			err = msgp.WrapError(err, "Offline", za0008)
			return
		}
	}
	// write "describe"
	err = en.Append(0xa8, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Describe)))
	if err != nil {
		err = msgp.WrapError(err, "Describe")
		return
	}
	for za0009 := range z.Describe {
		err = en.WriteString(z.Describe[za0009])
		if err != nil {
			err = msgp.WrapError(err, "Describe", za0009)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GameUpdateAck) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "stopFire"
	o = append(o, 0x8c, 0xa8, 0x73, 0x74, 0x6f, 0x70, 0x46, 0x69, 0x72, 0x65)
	o = msgp.AppendBool(o, z.StopFire)
	// string "tick"
	o = append(o, 0xa4, 0x74, 0x69, 0x63, 0x6b)
	o = msgp.AppendInt64(o, z.Tick)
	// string "switchScene"
	o = append(o, 0xab, 0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x53, 0x63, 0x65, 0x6e, 0x65)
	o = msgp.AppendInt32(o, z.SwitchScene)
	// string "play"
	o = append(o, 0xa4, 0x70, 0x6c, 0x61, 0x79)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Players)))
	for za0001 := range z.Players {
		if z.Players[za0001] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Players[za0001].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Players", za0001)
				return
			}
		}
	}
	// string "fishes"
	o = append(o, 0xa6, 0x66, 0x69, 0x73, 0x68, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Fishes)))
	for za0002 := range z.Fishes {
		if z.Fishes[za0002] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Fishes[za0002].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Fishes", za0002)
				return
			}
		}
	}
	// string "bull"
	o = append(o, 0xa4, 0x62, 0x75, 0x6c, 0x6c)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Bullets)))
	for za0003 := range z.Bullets {
		if z.Bullets[za0003] == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Bullets[za0003].MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Bullets", za0003)
				return
			}
		}
	}
	// string "dieBullets"
	o = append(o, 0xaa, 0x64, 0x69, 0x65, 0x42, 0x75, 0x6c, 0x6c, 0x65, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DieBullets)))
	for za0004 := range z.DieBullets {
		o = msgp.AppendInt32(o, z.DieBullets[za0004])
	}
	// string "dieFishes"
	o = append(o, 0xa9, 0x64, 0x69, 0x65, 0x46, 0x69, 0x73, 0x68, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.DieFishes)))
	for za0005 := range z.DieFishes {
		o = msgp.AppendInt32(o, z.DieFishes[za0005])
	}
	// string "kills"
	o = append(o, 0xa5, 0x6b, 0x69, 0x6c, 0x6c, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Kills)))
	for za0006 := range z.Kills {
		if z.Kills[za0006] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 3
			// string "id"
			o = append(o, 0x83, 0xa2, 0x69, 0x64)
			o = msgp.AppendInt32(o, z.Kills[za0006].Id)
			// string "uid"
			o = append(o, 0xa3, 0x75, 0x69, 0x64)
			o = msgp.AppendInt32(o, z.Kills[za0006].Uid)
			// string "score"
			o = append(o, 0xa5, 0x73, 0x63, 0x6f, 0x72, 0x65)
			o = msgp.AppendInt64(o, z.Kills[za0006].Score)
		}
	}
	// string "seed"
	o = append(o, 0xa4, 0x73, 0x65, 0x65, 0x64)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Seed)))
	for za0007 := range z.Seed {
		if z.Seed[za0007] == nil {
			o = msgp.AppendNil(o)
		} else {
			// map header, size 2
			// string "id"
			o = append(o, 0x82, 0xa2, 0x69, 0x64)
			o = msgp.AppendInt32(o, z.Seed[za0007].Id)
			// string "speed"
			o = append(o, 0xa5, 0x73, 0x70, 0x65, 0x65, 0x64)
			o = msgp.AppendFloat64(o, z.Seed[za0007].Speed)
		}
	}
	// string "offline"
	o = append(o, 0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Offline)))
	for za0008 := range z.Offline {
		o = msgp.AppendInt32(o, z.Offline[za0008])
	}
	// string "describe"
	o = append(o, 0xa8, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Describe)))
	for za0009 := range z.Describe {
		o = msgp.AppendString(o, z.Describe[za0009])
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GameUpdateAck) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "stopFire":
			z.StopFire, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StopFire")
				return
			}
		case "tick":
			z.Tick, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tick")
				return
			}
		case "switchScene":
			z.SwitchScene, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SwitchScene")
				return
			}
		case "play":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Players")
				return
			}
			if cap(z.Players) >= int(zb0002) {
				z.Players = (z.Players)[:zb0002]
			} else {
				z.Players = make([]*Player, zb0002)
			}
			for za0001 := range z.Players {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Players[za0001] = nil
				} else {
					if z.Players[za0001] == nil {
						z.Players[za0001] = new(Player)
					}
					bts, err = z.Players[za0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Players", za0001)
						return
					}
				}
			}
		case "fishes":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Fishes")
				return
			}
			if cap(z.Fishes) >= int(zb0003) {
				z.Fishes = (z.Fishes)[:zb0003]
			} else {
				z.Fishes = make([]*Fish, zb0003)
			}
			for za0002 := range z.Fishes {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Fishes[za0002] = nil
				} else {
					if z.Fishes[za0002] == nil {
						z.Fishes[za0002] = new(Fish)
					}
					bts, err = z.Fishes[za0002].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Fishes", za0002)
						return
					}
				}
			}
		case "bull":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bullets")
				return
			}
			if cap(z.Bullets) >= int(zb0004) {
				z.Bullets = (z.Bullets)[:zb0004]
			} else {
				z.Bullets = make([]*Bullet, zb0004)
			}
			for za0003 := range z.Bullets {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Bullets[za0003] = nil
				} else {
					if z.Bullets[za0003] == nil {
						z.Bullets[za0003] = new(Bullet)
					}
					bts, err = z.Bullets[za0003].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Bullets", za0003)
						return
					}
				}
			}
		case "dieBullets":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DieBullets")
				return
			}
			if cap(z.DieBullets) >= int(zb0005) {
				z.DieBullets = (z.DieBullets)[:zb0005]
			} else {
				z.DieBullets = make([]int32, zb0005)
			}
			for za0004 := range z.DieBullets {
				z.DieBullets[za0004], bts, err = msgp.ReadInt32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DieBullets", za0004)
					return
				}
			}
		case "dieFishes":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DieFishes")
				return
			}
			if cap(z.DieFishes) >= int(zb0006) {
				z.DieFishes = (z.DieFishes)[:zb0006]
			} else {
				z.DieFishes = make([]int32, zb0006)
			}
			for za0005 := range z.DieFishes {
				z.DieFishes[za0005], bts, err = msgp.ReadInt32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DieFishes", za0005)
					return
				}
			}
		case "kills":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Kills")
				return
			}
			if cap(z.Kills) >= int(zb0007) {
				z.Kills = (z.Kills)[:zb0007]
			} else {
				z.Kills = make([]*KillFish, zb0007)
			}
			for za0006 := range z.Kills {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Kills[za0006] = nil
				} else {
					if z.Kills[za0006] == nil {
						z.Kills[za0006] = new(KillFish)
					}
					var zb0008 uint32
					zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Kills", za0006)
						return
					}
					for zb0008 > 0 {
						zb0008--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Kills", za0006)
							return
						}
						switch msgp.UnsafeString(field) {
						case "id":
							z.Kills[za0006].Id, bts, err = msgp.ReadInt32Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Kills", za0006, "Id")
								return
							}
						case "uid":
							z.Kills[za0006].Uid, bts, err = msgp.ReadInt32Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Kills", za0006, "Uid")
								return
							}
						case "score":
							z.Kills[za0006].Score, bts, err = msgp.ReadInt64Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Kills", za0006, "Score")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Kills", za0006)
								return
							}
						}
					}
				}
			}
		case "seed":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Seed")
				return
			}
			if cap(z.Seed) >= int(zb0009) {
				z.Seed = (z.Seed)[:zb0009]
			} else {
				z.Seed = make([]*FishSeed, zb0009)
			}
			for za0007 := range z.Seed {
				if msgp.IsNil(bts) {
					bts, err = msgp.ReadNilBytes(bts)
					if err != nil {
						return
					}
					z.Seed[za0007] = nil
				} else {
					if z.Seed[za0007] == nil {
						z.Seed[za0007] = new(FishSeed)
					}
					var zb0010 uint32
					zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Seed", za0007)
						return
					}
					for zb0010 > 0 {
						zb0010--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Seed", za0007)
							return
						}
						switch msgp.UnsafeString(field) {
						case "id":
							z.Seed[za0007].Id, bts, err = msgp.ReadInt32Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Seed", za0007, "Id")
								return
							}
						case "speed":
							z.Seed[za0007].Speed, bts, err = msgp.ReadFloat64Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Seed", za0007, "Speed")
								return
							}
						default:
							bts, err = msgp.Skip(bts)
							if err != nil {
								err = msgp.WrapError(err, "Seed", za0007)
								return
							}
						}
					}
				}
			}
		case "offline":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Offline")
				return
			}
			if cap(z.Offline) >= int(zb0011) {
				z.Offline = (z.Offline)[:zb0011]
			} else {
				z.Offline = make([]int32, zb0011)
			}
			for za0008 := range z.Offline {
				z.Offline[za0008], bts, err = msgp.ReadInt32Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Offline", za0008)
					return
				}
			}
		case "describe":
			var zb0012 uint32
			zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Describe")
				return
			}
			if cap(z.Describe) >= int(zb0012) {
				z.Describe = (z.Describe)[:zb0012]
			} else {
				z.Describe = make([]string, zb0012)
			}
			for za0009 := range z.Describe {
				z.Describe[za0009], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Describe", za0009)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GameUpdateAck) Msgsize() (s int) {
	s = 1 + 9 + msgp.BoolSize + 5 + msgp.Int64Size + 12 + msgp.Int32Size + 5 + msgp.ArrayHeaderSize
	for za0001 := range z.Players {
		if z.Players[za0001] == nil {
			s += msgp.NilSize
		} else {
			s += z.Players[za0001].Msgsize()
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0002 := range z.Fishes {
		if z.Fishes[za0002] == nil {
			s += msgp.NilSize
		} else {
			s += z.Fishes[za0002].Msgsize()
		}
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0003 := range z.Bullets {
		if z.Bullets[za0003] == nil {
			s += msgp.NilSize
		} else {
			s += z.Bullets[za0003].Msgsize()
		}
	}
	s += 11 + msgp.ArrayHeaderSize + (len(z.DieBullets) * (msgp.Int32Size)) + 10 + msgp.ArrayHeaderSize + (len(z.DieFishes) * (msgp.Int32Size)) + 6 + msgp.ArrayHeaderSize
	for za0006 := range z.Kills {
		if z.Kills[za0006] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 3 + msgp.Int32Size + 4 + msgp.Int32Size + 6 + msgp.Int64Size
		}
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0007 := range z.Seed {
		if z.Seed[za0007] == nil {
			s += msgp.NilSize
		} else {
			s += 1 + 3 + msgp.Int32Size + 6 + msgp.Float64Size
		}
	}
	s += 8 + msgp.ArrayHeaderSize + (len(z.Offline) * (msgp.Int32Size)) + 9 + msgp.ArrayHeaderSize
	for za0009 := range z.Describe {
		s += msgp.StringPrefixSize + len(z.Describe[za0009])
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *HitReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bulletId":
			z.BulletId, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "BulletId")
				return
			}
		case "fishId":
			z.FishId, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "FishId")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z HitReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "bulletId"
	err = en.Append(0x82, 0xa8, 0x62, 0x75, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.BulletId)
	if err != nil {
		err = msgp.WrapError(err, "BulletId")
		return
	}
	// write "fishId"
	err = en.Append(0xa6, 0x66, 0x69, 0x73, 0x68, 0x49, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.FishId)
	if err != nil {
		err = msgp.WrapError(err, "FishId")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z HitReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "bulletId"
	o = append(o, 0x82, 0xa8, 0x62, 0x75, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x64)
	o = msgp.AppendInt32(o, z.BulletId)
	// string "fishId"
	o = append(o, 0xa6, 0x66, 0x69, 0x73, 0x68, 0x49, 0x64)
	o = msgp.AppendInt32(o, z.FishId)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *HitReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "bulletId":
			z.BulletId, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BulletId")
				return
			}
		case "fishId":
			z.FishId, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FishId")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z HitReq) Msgsize() (s int) {
	s = 1 + 9 + msgp.Int32Size + 7 + msgp.Int32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *KillFish) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "uid":
			z.Uid, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Uid")
				return
			}
		case "score":
			z.Score, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Score")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z KillFish) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "id"
	err = en.Append(0x83, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Id)
	if err != nil {
		err = msgp.WrapError(err, "Id")
		return
	}
	// write "uid"
	err = en.Append(0xa3, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Uid)
	if err != nil {
		err = msgp.WrapError(err, "Uid")
		return
	}
	// write "score"
	err = en.Append(0xa5, 0x73, 0x63, 0x6f, 0x72, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Score)
	if err != nil {
		err = msgp.WrapError(err, "Score")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z KillFish) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "id"
	o = append(o, 0x83, 0xa2, 0x69, 0x64)
	o = msgp.AppendInt32(o, z.Id)
	// string "uid"
	o = append(o, 0xa3, 0x75, 0x69, 0x64)
	o = msgp.AppendInt32(o, z.Uid)
	// string "score"
	o = append(o, 0xa5, 0x73, 0x63, 0x6f, 0x72, 0x65)
	o = msgp.AppendInt64(o, z.Score)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *KillFish) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "uid":
			z.Uid, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Uid")
				return
			}
		case "score":
			z.Score, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Score")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z KillFish) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int32Size + 4 + msgp.Int32Size + 6 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Player) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "icon":
			z.Icon, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Icon")
				return
			}
		case "vip":
			z.Vip, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Vip")
				return
			}
		case "chair":
			z.Chair, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Chair")
				return
			}
		case "coin":
			z.Coin, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Coin")
				return
			}
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Player) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "id"
	err = en.Append(0x86, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Id)
	if err != nil {
		err = msgp.WrapError(err, "Id")
		return
	}
	// write "icon"
	err = en.Append(0xa4, 0x69, 0x63, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Icon)
	if err != nil {
		err = msgp.WrapError(err, "Icon")
		return
	}
	// write "vip"
	err = en.Append(0xa3, 0x76, 0x69, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Vip)
	if err != nil {
		err = msgp.WrapError(err, "Vip")
		return
	}
	// write "chair"
	err = en.Append(0xa5, 0x63, 0x68, 0x61, 0x69, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Chair)
	if err != nil {
		err = msgp.WrapError(err, "Chair")
		return
	}
	// write "coin"
	err = en.Append(0xa4, 0x63, 0x6f, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Coin)
	if err != nil {
		err = msgp.WrapError(err, "Coin")
		return
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Player) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "id"
	o = append(o, 0x86, 0xa2, 0x69, 0x64)
	o = msgp.AppendInt32(o, z.Id)
	// string "icon"
	o = append(o, 0xa4, 0x69, 0x63, 0x6f, 0x6e)
	o = msgp.AppendInt32(o, z.Icon)
	// string "vip"
	o = append(o, 0xa3, 0x76, 0x69, 0x70)
	o = msgp.AppendInt32(o, z.Vip)
	// string "chair"
	o = append(o, 0xa5, 0x63, 0x68, 0x61, 0x69, 0x72)
	o = msgp.AppendInt32(o, z.Chair)
	// string "coin"
	o = append(o, 0xa4, 0x63, 0x6f, 0x69, 0x6e)
	o = msgp.AppendInt64(o, z.Coin)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Player) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.Id, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Id")
				return
			}
		case "icon":
			z.Icon, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Icon")
				return
			}
		case "vip":
			z.Vip, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Vip")
				return
			}
		case "chair":
			z.Chair, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Chair")
				return
			}
		case "coin":
			z.Coin, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Coin")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Player) Msgsize() (s int) {
	s = 1 + 3 + msgp.Int32Size + 5 + msgp.Int32Size + 4 + msgp.Int32Size + 6 + msgp.Int32Size + 5 + msgp.Int64Size + 5 + msgp.StringPrefixSize + len(z.Name)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ShootReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "fish":
			z.Fish, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Fish")
				return
			}
		case "client":
			z.Client, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Client")
				return
			}
		case "bet":
			z.Bet, err = dc.ReadInt32()
			if err != nil {
				err = msgp.WrapError(err, "Bet")
				return
			}
		case "direction":
			z.Direction, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Direction")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ShootReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "fish"
	err = en.Append(0x84, 0xa4, 0x66, 0x69, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Fish)
	if err != nil {
		err = msgp.WrapError(err, "Fish")
		return
	}
	// write "client"
	err = en.Append(0xa6, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Client)
	if err != nil {
		err = msgp.WrapError(err, "Client")
		return
	}
	// write "bet"
	err = en.Append(0xa3, 0x62, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt32(z.Bet)
	if err != nil {
		err = msgp.WrapError(err, "Bet")
		return
	}
	// write "direction"
	err = en.Append(0xa9, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Direction)
	if err != nil {
		err = msgp.WrapError(err, "Direction")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ShootReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "fish"
	o = append(o, 0x84, 0xa4, 0x66, 0x69, 0x73, 0x68)
	o = msgp.AppendInt32(o, z.Fish)
	// string "client"
	o = append(o, 0xa6, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt32(o, z.Client)
	// string "bet"
	o = append(o, 0xa3, 0x62, 0x65, 0x74)
	o = msgp.AppendInt32(o, z.Bet)
	// string "direction"
	o = append(o, 0xa9, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendFloat64(o, z.Direction)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ShootReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "fish":
			z.Fish, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Fish")
				return
			}
		case "client":
			z.Client, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Client")
				return
			}
		case "bet":
			z.Bet, bts, err = msgp.ReadInt32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Bet")
				return
			}
		case "direction":
			z.Direction, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Direction")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ShootReq) Msgsize() (s int) {
	s = 1 + 5 + msgp.Int32Size + 7 + msgp.Int32Size + 4 + msgp.Int32Size + 10 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TimeSyncAck) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Client":
			z.Client, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Client")
				return
			}
		case "Server":
			z.Server, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Server")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TimeSyncAck) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Client"
	err = en.Append(0x82, 0xa6, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Client)
	if err != nil {
		err = msgp.WrapError(err, "Client")
		return
	}
	// write "Server"
	err = en.Append(0xa6, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Server)
	if err != nil {
		err = msgp.WrapError(err, "Server")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TimeSyncAck) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Client"
	o = append(o, 0x82, 0xa6, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt64(o, z.Client)
	// string "Server"
	o = append(o, 0xa6, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72)
	o = msgp.AppendInt64(o, z.Server)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TimeSyncAck) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Client":
			z.Client, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Client")
				return
			}
		case "Server":
			z.Server, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Server")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TimeSyncAck) Msgsize() (s int) {
	s = 1 + 7 + msgp.Int64Size + 7 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TimeSyncReq) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Tick":
			z.Tick, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Tick")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TimeSyncReq) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "Tick"
	err = en.Append(0x81, 0xa4, 0x54, 0x69, 0x63, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Tick)
	if err != nil {
		err = msgp.WrapError(err, "Tick")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TimeSyncReq) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Tick"
	o = append(o, 0x81, 0xa4, 0x54, 0x69, 0x63, 0x6b)
	o = msgp.AppendInt64(o, z.Tick)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TimeSyncReq) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Tick":
			z.Tick, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tick")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TimeSyncReq) Msgsize() (s int) {
	s = 1 + 5 + msgp.Int64Size
	return
}
