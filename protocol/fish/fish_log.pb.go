// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: fish_log.proto

package fish

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 捕鱼日志
type GameRound struct {
	// 全局唯一游戏ID(i有建立索引，不要更改名称)
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"i" bson:"i" msg:"i"`
	// 玩家ID
	Uid int32 `protobuf:"varint,2,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	// 游戏开始时间(s有建立索引，不要更改名称)
	Start int64 `protobuf:"varint,3,opt,name=start,proto3" json:"s" bson:"s" msg:"s"`
	// 游戏结束时间
	End int64 `protobuf:"varint,4,opt,name=end,proto3" json:"e" bson:"e" msg:"e"`
	// 房间ID
	Room int32 `protobuf:"varint,5,opt,name=room,proto3" json:"r" bson:"r" msg:"r"`
	// 桌子ID
	Tab int32 `protobuf:"varint,6,opt,name=tab,proto3" json:"t" bson:"t" msg:"t"`
	// 开始游戏时带的钱
	OldCoin int64 `protobuf:"varint,7,opt,name=oldCoin,proto3" json:"c" bson:"c" msg:"c"`
	// 下注总金币
	Bet int64 `protobuf:"varint,8,opt,name=bet,proto3" json:"m" bson:"m" msg:"m"`
	// 玩家输赢
	Win int64 `protobuf:"zigzag64,9,opt,name=win,proto3" json:"w" bson:"w" msg:"w"`
	// 动作日志(子弹消耗的钱/击中的鱼/得分)
	Log []int32 `protobuf:"varint,11,rep,packed,name=log,proto3" json:"l" bson:"l" msg:"l"`
	// 备注
	Note string `protobuf:"bytes,12,opt,name=note,proto3" json:"n,omitempty" bson:"n,omitempty" msg:"n,omitempty"`
}

func (m *GameRound) Reset()         { *m = GameRound{} }
func (m *GameRound) String() string { return proto.CompactTextString(m) }
func (*GameRound) ProtoMessage()    {}
func (*GameRound) Descriptor() ([]byte, []int) {
	return fileDescriptor_6003c6f775c9819e, []int{0}
}
func (m *GameRound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameRound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameRound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameRound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameRound.Merge(m, src)
}
func (m *GameRound) XXX_Size() int {
	return m.Size()
}
func (m *GameRound) XXX_DiscardUnknown() {
	xxx_messageInfo_GameRound.DiscardUnknown(m)
}

var xxx_messageInfo_GameRound proto.InternalMessageInfo

func (m *GameRound) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameRound) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GameRound) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *GameRound) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *GameRound) GetRoom() int32 {
	if m != nil {
		return m.Room
	}
	return 0
}

func (m *GameRound) GetTab() int32 {
	if m != nil {
		return m.Tab
	}
	return 0
}

func (m *GameRound) GetOldCoin() int64 {
	if m != nil {
		return m.OldCoin
	}
	return 0
}

func (m *GameRound) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *GameRound) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameRound) GetLog() []int32 {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *GameRound) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func init() {
	proto.RegisterType((*GameRound)(nil), "fish.GameRound")
}

func init() { proto.RegisterFile("fish_log.proto", fileDescriptor_6003c6f775c9819e) }

var fileDescriptor_6003c6f775c9819e = []byte{
	// 385 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x4c, 0xd2, 0xb1, 0x8e, 0xda, 0x30,
	0x18, 0x07, 0x70, 0x4c, 0x02, 0x14, 0x53, 0x55, 0x95, 0x27, 0xb7, 0x43, 0x12, 0x59, 0x1d, 0x52,
	0xb5, 0xc0, 0xc0, 0x50, 0xa9, 0x23, 0x37, 0xdc, 0x70, 0x9b, 0xc7, 0x5b, 0x4e, 0x24, 0x31, 0xc1,
	0x52, 0x1c, 0xa3, 0xc4, 0x51, 0x74, 0x6f, 0x71, 0x4f, 0x71, 0xcf, 0x72, 0x23, 0xe3, 0x4d, 0xd1,
	0x09, 0x36, 0x46, 0x9e, 0xe0, 0x64, 0xc7, 0xc8, 0x4c, 0xc9, 0xe7, 0xfc, 0xfe, 0xff, 0x7c, 0x83,
	0xe1, 0xb7, 0x2d, 0xaf, 0x77, 0x4f, 0x85, 0xcc, 0x17, 0xfb, 0x4a, 0x2a, 0x89, 0x7c, 0x3d, 0xff,
	0x9c, 0xe7, 0x5c, 0xed, 0x9a, 0x64, 0x91, 0x4a, 0xb1, 0xcc, 0x65, 0x2e, 0x97, 0xe6, 0x63, 0xd2,
	0x6c, 0xcd, 0x64, 0x06, 0xf3, 0xd6, 0x87, 0xc8, 0xab, 0x0f, 0xa7, 0xf7, 0x1b, 0xc1, 0xa8, 0x6c,
	0xca, 0x0c, 0xfd, 0x86, 0x43, 0x9e, 0x61, 0x10, 0x81, 0xd8, 0x5b, 0xff, 0x38, 0x77, 0x21, 0xe0,
	0x97, 0x2e, 0xfc, 0x9e, 0xd4, 0xb2, 0xfc, 0x4f, 0x38, 0x89, 0x44, 0x9d, 0xeb, 0x27, 0x1d, 0xf2,
	0x0c, 0xfd, 0x81, 0x5e, 0xc3, 0x33, 0x3c, 0x8c, 0x40, 0x3c, 0xea, 0x6d, 0xe3, 0x6c, 0x63, 0x6d,
	0x43, 0xa8, 0x56, 0x68, 0x09, 0x47, 0xb5, 0xda, 0x54, 0x0a, 0x7b, 0xae, 0xba, 0x76, 0xbc, 0xb6,
	0xbc, 0x26, 0xb4, 0x77, 0xba, 0x9d, 0x95, 0x19, 0xf6, 0x1d, 0x67, 0x8e, 0x33, 0xcb, 0x19, 0xa1,
	0x5a, 0xa1, 0x39, 0xf4, 0x2b, 0x29, 0x05, 0x1e, 0xb9, 0x5d, 0x2a, 0xa7, 0x2b, 0xab, 0x2b, 0x42,
	0x0d, 0xd3, 0xdd, 0x6a, 0x93, 0xe0, 0xb1, 0xd3, 0xca, 0x69, 0x65, 0xb5, 0x22, 0x54, 0x2b, 0xb4,
	0x82, 0x13, 0x59, 0x64, 0x77, 0x92, 0x97, 0x78, 0xe2, 0x96, 0x49, 0x5d, 0x20, 0xb5, 0x81, 0x94,
	0xd0, 0xab, 0xd4, 0x7f, 0x48, 0x98, 0xc2, 0x5f, 0x5c, 0x40, 0xb8, 0x80, 0xb0, 0x01, 0x41, 0xa8,
	0x56, 0x1a, 0xb7, 0xbc, 0xc4, 0xd3, 0x08, 0xc4, 0xa8, 0xc7, 0xad, 0xc3, 0xad, 0xc5, 0x2d, 0xa1,
	0x5a, 0x69, 0x5c, 0xc8, 0x1c, 0xcf, 0x22, 0xef, 0xba, 0x7b, 0xe1, 0x70, 0x61, 0x71, 0x41, 0xa8,
	0x56, 0xe8, 0x01, 0xfa, 0xa5, 0x54, 0x0c, 0x7f, 0x8d, 0x40, 0x3c, 0x5d, 0xff, 0x3b, 0x77, 0xe1,
	0xac, 0xfc, 0x2b, 0x05, 0x57, 0x4c, 0xec, 0xd5, 0xf3, 0xa5, 0x0b, 0x7f, 0xf5, 0xb9, 0x9b, 0x43,
	0xdb, 0x70, 0x7b, 0x42, 0x4d, 0xc9, 0x3a, 0x78, 0x3b, 0x06, 0xe0, 0x70, 0x0c, 0xc0, 0xc7, 0x31,
	0x00, 0x2f, 0xa7, 0x60, 0x70, 0x38, 0x05, 0x83, 0xf7, 0x53, 0x30, 0x78, 0x34, 0xf7, 0x2e, 0x19,
	0x9b, 0xfb, 0xb4, 0xfa, 0x0c, 0x00, 0x00, 0xff, 0xff, 0x5c, 0xf5, 0x8b, 0x2b, 0x96, 0x02, 0x00,
	0x00,
}

func (m *GameRound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameRound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(m.Id))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(m.Uid))
	}
	if m.Start != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(m.End))
	}
	if m.Room != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(m.Room))
	}
	if m.Tab != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(m.Tab))
	}
	if m.OldCoin != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(m.OldCoin))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(m.Bet))
	}
	if m.Win != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintFishLog(dAtA, i, uint64((uint64(m.Win)<<1)^uint64((m.Win>>63))))
	}
	if len(m.Log) > 0 {
		dAtA2 := make([]byte, len(m.Log)*10)
		var j1 int
		for _, num1 := range m.Log {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Note) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintFishLog(dAtA, i, uint64(len(m.Note)))
		i += copy(dAtA[i:], m.Note)
	}
	return i, nil
}

func encodeVarintFishLog(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GameRound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovFishLog(uint64(m.Id))
	}
	if m.Uid != 0 {
		n += 1 + sovFishLog(uint64(m.Uid))
	}
	if m.Start != 0 {
		n += 1 + sovFishLog(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovFishLog(uint64(m.End))
	}
	if m.Room != 0 {
		n += 1 + sovFishLog(uint64(m.Room))
	}
	if m.Tab != 0 {
		n += 1 + sovFishLog(uint64(m.Tab))
	}
	if m.OldCoin != 0 {
		n += 1 + sovFishLog(uint64(m.OldCoin))
	}
	if m.Bet != 0 {
		n += 1 + sovFishLog(uint64(m.Bet))
	}
	if m.Win != 0 {
		n += 1 + sozFishLog(uint64(m.Win))
	}
	if len(m.Log) > 0 {
		l = 0
		for _, e := range m.Log {
			l += sovFishLog(uint64(e))
		}
		n += 1 + sovFishLog(uint64(l)) + l
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovFishLog(uint64(l))
	}
	return n
}

func sovFishLog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFishLog(x uint64) (n int) {
	return sovFishLog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GameRound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFishLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameRound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameRound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			m.Room = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Room |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tab", wireType)
			}
			m.Tab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tab |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldCoin", wireType)
			}
			m.OldCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldCoin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Win = int64(v)
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Log = append(m.Log, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFishLog
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFishLog
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFishLog
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Log) == 0 {
					m.Log = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFishLog
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Log = append(m.Log, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFishLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFishLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFishLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFishLog
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFishLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFishLog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFishLog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFishLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFishLog
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthFishLog
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFishLog
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFishLog(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthFishLog
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFishLog = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFishLog   = fmt.Errorf("proto: integer overflow")
)
