// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: zjh.proto

package zjh

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Code int32

const (
	// 8300-8399(炸金花)
	Code_CodeNone          Code = 0
	Code_CodeActionReq     Code = 8300
	Code_CodeActionAck     Code = 8301
	Code_CodeGameInitAck   Code = 8303
	Code_CodeGameStartAck  Code = 8305
	Code_CodeGameResultAck Code = 8307
)

var Code_name = map[int32]string{
	0:    "CodeNone",
	8300: "CodeActionReq",
	8301: "CodeActionAck",
	8303: "CodeGameInitAck",
	8305: "CodeGameStartAck",
	8307: "CodeGameResultAck",
}

var Code_value = map[string]int32{
	"CodeNone":          0,
	"CodeActionReq":     8300,
	"CodeActionAck":     8301,
	"CodeGameInitAck":   8303,
	"CodeGameStartAck":  8305,
	"CodeGameResultAck": 8307,
}

func (x Code) String() string {
	return proto.EnumName(Code_name, int32(x))
}

func (Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{0}
}

type ActionType int32

const (
	ActionType_ActionNone ActionType = 0
	// 准备
	ActionType_ActionReady ActionType = 1
	// 看牌
	ActionType_ActionLook ActionType = 2
	// 主动弃牌
	ActionType_ActionDiscard ActionType = 3
	// 超时弃牌
	ActionType_ActionOvertime ActionType = 4
	// 比牌
	ActionType_ActionCompare ActionType = 5
	// 下注(跟注+加注)
	ActionType_ActionAddBet ActionType = 6
	// 全压
	ActionType_ActionAllin ActionType = 7
	// 全压比牌
	ActionType_ActionAllinCompare ActionType = 9
	// 自动比牌
	ActionType_ActionAutoCompare ActionType = 10
	// 换桌玩
	ActionType_ActionRenew ActionType = 11
	// 离开
	ActionType_ActionLeave ActionType = 12
)

var ActionType_name = map[int32]string{
	0:  "ActionNone",
	1:  "ActionReady",
	2:  "ActionLook",
	3:  "ActionDiscard",
	4:  "ActionOvertime",
	5:  "ActionCompare",
	6:  "ActionAddBet",
	7:  "ActionAllin",
	9:  "ActionAllinCompare",
	10: "ActionAutoCompare",
	11: "ActionRenew",
	12: "ActionLeave",
}

var ActionType_value = map[string]int32{
	"ActionNone":         0,
	"ActionReady":        1,
	"ActionLook":         2,
	"ActionDiscard":      3,
	"ActionOvertime":     4,
	"ActionCompare":      5,
	"ActionAddBet":       6,
	"ActionAllin":        7,
	"ActionAllinCompare": 9,
	"ActionAutoCompare":  10,
	"ActionRenew":        11,
	"ActionLeave":        12,
}

func (x ActionType) String() string {
	return proto.EnumName(ActionType_name, int32(x))
}

func (ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{1}
}

type Player_State int32

const (
	// 没有准备
	Player_None Player_State = 0
	// 已准备
	Player_Ready Player_State = 1
	// 游戏中
	Player_Playing Player_State = 2
	// 全押
	Player_Allin Player_State = 3
	// 已弃牌
	Player_Discard Player_State = 4
	// PK失败
	Player_Lose Player_State = 5
	// 赢得最终胜利
	Player_Win Player_State = 6
	// 离开
	Player_Leave Player_State = 7
)

var Player_State_name = map[int32]string{
	0: "None",
	1: "Ready",
	2: "Playing",
	3: "Allin",
	4: "Discard",
	5: "Lose",
	6: "Win",
	7: "Leave",
}

var Player_State_value = map[string]int32{
	"None":    0,
	"Ready":   1,
	"Playing": 2,
	"Allin":   3,
	"Discard": 4,
	"Lose":    5,
	"Win":     6,
	"Leave":   7,
}

func (x Player_State) String() string {
	return proto.EnumName(Player_State_name, int32(x))
}

func (Player_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{0, 0}
}

// 玩家信息
type Player struct {
	// 玩家ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 玩家头像
	Icon int32 `protobuf:"varint,2,opt,name=icon,proto3" json:"icon"`
	// VIP等级
	Vip int32 `protobuf:"varint,3,opt,name=vip,proto3" json:"vip"`
	// 椅子号(从0开始)
	Chair int32 `protobuf:"varint,4,opt,name=chair,proto3" json:"chair"`
	// 玩家带的分
	Coin int64 `protobuf:"varint,5,opt,name=coin,proto3" json:"coin"`
	// 玩家的下注
	Bet int64 `protobuf:"varint,6,opt,name=bet,proto3" json:"bet"`
	// 玩家名称
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name"`
	// 游戏状态
	State Player_State `protobuf:"varint,8,opt,name=state,proto3,enum=zjh.Player_State" json:"state"`
	// 是否已看牌
	Look bool `protobuf:"varint,9,opt,name=look,proto3" json:"look"`
	// 倒计时(等待玩家命令倒计时)
	Down int32 `protobuf:"zigzag32,10,opt,name=down,proto3" json:"down"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{0}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetIcon() int32 {
	if m != nil {
		return m.Icon
	}
	return 0
}

func (m *Player) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *Player) GetChair() int32 {
	if m != nil {
		return m.Chair
	}
	return 0
}

func (m *Player) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *Player) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetState() Player_State {
	if m != nil {
		return m.State
	}
	return Player_None
}

func (m *Player) GetLook() bool {
	if m != nil {
		return m.Look
	}
	return false
}

func (m *Player) GetDown() int32 {
	if m != nil {
		return m.Down
	}
	return 0
}

// 打牌请求
type ActionReq struct {
	// 动作类型
	Type ActionType `protobuf:"varint,1,opt,name=type,proto3,enum=zjh.ActionType" json:"type"`
	// 下注
	Bet int32 `protobuf:"varint,2,opt,name=bet,proto3" json:"bet"`
	// 对手ID
	Opponent int32 `protobuf:"varint,3,opt,name=opponent,proto3" json:"opponent"`
}

func (m *ActionReq) Reset()         { *m = ActionReq{} }
func (m *ActionReq) String() string { return proto.CompactTextString(m) }
func (*ActionReq) ProtoMessage()    {}
func (*ActionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{1}
}
func (m *ActionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionReq.Merge(m, src)
}
func (m *ActionReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionReq proto.InternalMessageInfo

func (m *ActionReq) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ActionType_ActionNone
}

func (m *ActionReq) GetBet() int32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *ActionReq) GetOpponent() int32 {
	if m != nil {
		return m.Opponent
	}
	return 0
}

type ActionAck struct {
	// 动作类型
	Type ActionType `protobuf:"varint,1,opt,name=type,proto3,enum=zjh.ActionType" json:"type"`
	// 牌
	Poker []byte `protobuf:"bytes,2,opt,name=poker,proto3" json:"poker"`
	// 玩家ID
	Uid int32 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid"`
	// 下注
	Bet int32 `protobuf:"varint,4,opt,name=bet,proto3" json:"bet"`
	// 参与比牌的玩家ID
	Players []int32 `protobuf:"varint,5,rep,packed,name=players,proto3" json:"players"`
	// 赢的人
	Winners []int32 `protobuf:"varint,6,rep,packed,name=winners,proto3" json:"winners"`
	// 当前金币
	Coin int64 `protobuf:"varint,7,opt,name=coin,proto3" json:"coin"`
}

func (m *ActionAck) Reset()         { *m = ActionAck{} }
func (m *ActionAck) String() string { return proto.CompactTextString(m) }
func (*ActionAck) ProtoMessage()    {}
func (*ActionAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{2}
}
func (m *ActionAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionAck.Merge(m, src)
}
func (m *ActionAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionAck proto.InternalMessageInfo

func (m *ActionAck) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ActionType_ActionNone
}

func (m *ActionAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *ActionAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionAck) GetBet() int32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *ActionAck) GetPlayers() []int32 {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *ActionAck) GetWinners() []int32 {
	if m != nil {
		return m.Winners
	}
	return nil
}

func (m *ActionAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

type GameInitAck struct {
	// 当前游戏ID
	Table int32 `protobuf:"varint,1,opt,name=table,proto3" json:"table"`
	// 当前游戏ID
	Id int32 `protobuf:"varint,2,opt,name=id,proto3" json:"id"`
	// 彩池的钱
	Pool int64 `protobuf:"varint,3,opt,name=pool,proto3" json:"pool"`
	// 当前游戏状态
	State int32 `protobuf:"varint,4,opt,name=state,proto3" json:"state"`
	// 第几轮
	Ring int32 `protobuf:"varint,5,opt,name=ring,proto3" json:"ring"`
	// 玩家(第1个位置为先)
	Players []*Player `protobuf:"bytes,6,rep,name=players,proto3" json:"players"`
	// 我的牌,如果已看牌
	Poker []byte `protobuf:"bytes,7,opt,name=poker,proto3" json:"poker"`
}

func (m *GameInitAck) Reset()         { *m = GameInitAck{} }
func (m *GameInitAck) String() string { return proto.CompactTextString(m) }
func (*GameInitAck) ProtoMessage()    {}
func (*GameInitAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{3}
}
func (m *GameInitAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInitAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInitAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameInitAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInitAck.Merge(m, src)
}
func (m *GameInitAck) XXX_Size() int {
	return m.Size()
}
func (m *GameInitAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInitAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameInitAck proto.InternalMessageInfo

func (m *GameInitAck) GetTable() int32 {
	if m != nil {
		return m.Table
	}
	return 0
}

func (m *GameInitAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameInitAck) GetPool() int64 {
	if m != nil {
		return m.Pool
	}
	return 0
}

func (m *GameInitAck) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *GameInitAck) GetRing() int32 {
	if m != nil {
		return m.Ring
	}
	return 0
}

func (m *GameInitAck) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *GameInitAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

// 游戏开始
type GameStartAck struct {
	// 当前游戏ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 彩池的钱
	Pool int64 `protobuf:"varint,2,opt,name=pool,proto3" json:"pool"`
	// 玩家(第1个位置为先)
	Players []*Player `protobuf:"bytes,3,rep,name=players,proto3" json:"players"`
}

func (m *GameStartAck) Reset()         { *m = GameStartAck{} }
func (m *GameStartAck) String() string { return proto.CompactTextString(m) }
func (*GameStartAck) ProtoMessage()    {}
func (*GameStartAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{4}
}
func (m *GameStartAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameStartAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameStartAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameStartAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameStartAck.Merge(m, src)
}
func (m *GameStartAck) XXX_Size() int {
	return m.Size()
}
func (m *GameStartAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameStartAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameStartAck proto.InternalMessageInfo

func (m *GameStartAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameStartAck) GetPool() int64 {
	if m != nil {
		return m.Pool
	}
	return 0
}

func (m *GameStartAck) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// 游戏结束
type GameResultAck struct {
	// 当前游戏ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 赢家
	Winner []int32 `protobuf:"varint,2,rep,packed,name=winner,proto3" json:"winner"`
	// 每个人的赢钱数
	Prize []int64 `protobuf:"varint,3,rep,packed,name=prize,proto3" json:"prize"`
	// 我的金币数
	Coin int64 `protobuf:"varint,4,opt,name=coin,proto3" json:"coin"`
	// 所有牌,不能看的为0
	Poker []byte `protobuf:"bytes,5,opt,name=poker,proto3" json:"poker"`
	// 喜钱，从彩池单独出
	Lucky int64 `protobuf:"varint,6,opt,name=lucky,proto3" json:"lucky"`
}

func (m *GameResultAck) Reset()         { *m = GameResultAck{} }
func (m *GameResultAck) String() string { return proto.CompactTextString(m) }
func (*GameResultAck) ProtoMessage()    {}
func (*GameResultAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{5}
}
func (m *GameResultAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameResultAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameResultAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameResultAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameResultAck.Merge(m, src)
}
func (m *GameResultAck) XXX_Size() int {
	return m.Size()
}
func (m *GameResultAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameResultAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameResultAck proto.InternalMessageInfo

func (m *GameResultAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameResultAck) GetWinner() []int32 {
	if m != nil {
		return m.Winner
	}
	return nil
}

func (m *GameResultAck) GetPrize() []int64 {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *GameResultAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *GameResultAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameResultAck) GetLucky() int64 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func init() {
	proto.RegisterEnum("zjh.Code", Code_name, Code_value)
	proto.RegisterEnum("zjh.ActionType", ActionType_name, ActionType_value)
	proto.RegisterEnum("zjh.Player_State", Player_State_name, Player_State_value)
	proto.RegisterType((*Player)(nil), "zjh.Player")
	proto.RegisterType((*ActionReq)(nil), "zjh.ActionReq")
	proto.RegisterType((*ActionAck)(nil), "zjh.ActionAck")
	proto.RegisterType((*GameInitAck)(nil), "zjh.GameInitAck")
	proto.RegisterType((*GameStartAck)(nil), "zjh.GameStartAck")
	proto.RegisterType((*GameResultAck)(nil), "zjh.GameResultAck")
}

func init() { proto.RegisterFile("zjh.proto", fileDescriptor_953ac353d286795d) }

var fileDescriptor_953ac353d286795d = []byte{
	// 770 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcd, 0x6a, 0x1b, 0x49,
	0x10, 0x56, 0xcf, 0x8f, 0x46, 0x2a, 0xc9, 0x72, 0xab, 0x91, 0xcd, 0x60, 0x58, 0x21, 0xb4, 0x2c,
	0x2b, 0x0c, 0x2b, 0x83, 0xf7, 0x05, 0x24, 0x7b, 0x61, 0x59, 0x30, 0xbb, 0xcb, 0x78, 0x61, 0x49,
	0x0e, 0x09, 0xa3, 0x99, 0x8e, 0xd4, 0xd6, 0xa8, 0x7b, 0x32, 0x1a, 0xd9, 0xc8, 0xb7, 0x3c, 0x40,
	0x20, 0x4f, 0x92, 0x43, 0x9e, 0x20, 0xc7, 0x1c, 0x7d, 0xcc, 0x31, 0xd8, 0xc7, 0x24, 0x84, 0x90,
	0x17, 0x08, 0xdd, 0x3d, 0x7f, 0x01, 0x07, 0x72, 0x9a, 0xfa, 0xbe, 0xea, 0xea, 0xfa, 0xba, 0x7e,
	0x06, 0x9a, 0xd7, 0x17, 0x8b, 0x71, 0x9c, 0x88, 0x54, 0x10, 0xf3, 0xfa, 0x62, 0x71, 0xf0, 0xdb,
	0x9c, 0xa5, 0x8b, 0xcd, 0x6c, 0x1c, 0x88, 0xd5, 0xd1, 0x5c, 0xcc, 0xc5, 0x91, 0xf2, 0xcd, 0x36,
	0x4f, 0x14, 0x52, 0x40, 0x59, 0x3a, 0x66, 0xf8, 0xda, 0x80, 0xfa, 0xbf, 0x91, 0xbf, 0xa5, 0x09,
	0xe9, 0x80, 0xc1, 0x42, 0x17, 0x0d, 0xd0, 0xc8, 0xf6, 0x0c, 0x16, 0x12, 0x02, 0x16, 0x0b, 0x04,
	0x77, 0x0d, 0xc5, 0x28, 0x9b, 0x60, 0x30, 0x2f, 0x59, 0xec, 0x9a, 0x8a, 0x92, 0x26, 0xe9, 0x81,
	0x1d, 0x2c, 0x7c, 0x96, 0xb8, 0x96, 0xe2, 0x34, 0x90, 0xb1, 0x81, 0x60, 0xdc, 0xb5, 0x07, 0x68,
	0x64, 0x7a, 0xca, 0x96, 0xb1, 0x33, 0x9a, 0xba, 0x75, 0x45, 0x49, 0x53, 0x9e, 0xe2, 0xfe, 0x8a,
	0xba, 0xce, 0x00, 0x8d, 0x9a, 0x9e, 0xb2, 0xc9, 0xaf, 0x60, 0xaf, 0x53, 0x3f, 0xa5, 0x6e, 0x63,
	0x80, 0x46, 0x9d, 0xe3, 0xee, 0x58, 0xbe, 0x4f, 0x2b, 0x1c, 0x9f, 0x4b, 0x87, 0xa7, 0xfd, 0x32,
	0x38, 0x12, 0x62, 0xe9, 0x36, 0x07, 0x68, 0xd4, 0xf0, 0x94, 0x2d, 0xb9, 0x50, 0x5c, 0x71, 0x17,
	0x06, 0x68, 0xd4, 0xf5, 0x94, 0x3d, 0x7c, 0x0c, 0xb6, 0x8a, 0x23, 0x0d, 0xb0, 0xfe, 0x16, 0x9c,
	0xe2, 0x1a, 0x69, 0x82, 0xed, 0x51, 0x3f, 0xdc, 0x62, 0x44, 0x5a, 0xe0, 0xc8, 0xcb, 0x19, 0x9f,
	0x63, 0x43, 0xf2, 0xd3, 0x28, 0x62, 0x1c, 0x9b, 0x92, 0xff, 0x83, 0xad, 0x03, 0x3f, 0x09, 0xb1,
	0x25, 0x23, 0xcf, 0xc4, 0x9a, 0x62, 0x9b, 0x38, 0x60, 0xfe, 0xcf, 0x38, 0xae, 0xcb, 0xa3, 0x67,
	0xd4, 0xbf, 0xa4, 0xd8, 0x19, 0x3e, 0x82, 0xe6, 0x34, 0x48, 0x99, 0xe0, 0x1e, 0x7d, 0x4a, 0x7e,
	0x06, 0x2b, 0xdd, 0xc6, 0x54, 0x95, 0xb1, 0x73, 0xbc, 0xab, 0xd4, 0x6b, 0xef, 0x7f, 0xdb, 0x98,
	0x7a, 0xca, 0x99, 0x57, 0x42, 0x17, 0x56, 0x55, 0xe2, 0x00, 0x1a, 0x22, 0x8e, 0x05, 0xa7, 0x3c,
	0xcd, 0x8a, 0x5b, 0xe0, 0xe1, 0x2b, 0x94, 0x27, 0x98, 0x06, 0xcb, 0x1f, 0x4b, 0xd0, 0x03, 0x3b,
	0x16, 0x4b, 0x9a, 0xa8, 0x14, 0x6d, 0x4f, 0x03, 0x99, 0x76, 0xc3, 0xc2, 0xbc, 0x79, 0x1b, 0x16,
	0xe6, 0x42, 0xac, 0x52, 0x88, 0x0b, 0x4e, 0xac, 0x8a, 0xbd, 0x76, 0xed, 0x81, 0x39, 0xb2, 0xbd,
	0x1c, 0x4a, 0xcf, 0x15, 0xe3, 0x5c, 0x7a, 0xea, 0xda, 0x93, 0xc1, 0xa2, 0xd9, 0x4e, 0xd9, 0xec,
	0xe1, 0x4b, 0x04, 0xad, 0x3f, 0xfd, 0x15, 0xfd, 0x8b, 0xb3, 0x54, 0xca, 0xee, 0x81, 0x9d, 0xfa,
	0xb3, 0x88, 0x66, 0xf3, 0xa5, 0x41, 0x36, 0x72, 0x46, 0x75, 0xe4, 0x62, 0x21, 0x22, 0x25, 0xd1,
	0xf4, 0x94, 0x2d, 0x23, 0xf5, 0x40, 0x64, 0x03, 0x56, 0x74, 0x3f, 0x61, 0x7c, 0xae, 0x06, 0xcc,
	0xf6, 0x94, 0x4d, 0x7e, 0x29, 0xb5, 0x4b, 0x85, 0xad, 0xe3, 0x56, 0x65, 0x78, 0xca, 0x87, 0x14,
	0xc5, 0x71, 0x2a, 0xc5, 0x19, 0x3e, 0x80, 0xb6, 0xd4, 0x7b, 0x9e, 0xfa, 0x89, 0x12, 0x7c, 0xcf,
	0x36, 0x28, 0x69, 0x46, 0x45, 0x5a, 0x25, 0xa1, 0xf9, 0xfd, 0x84, 0xc3, 0xe7, 0x08, 0x76, 0xe4,
	0xdd, 0x1e, 0x5d, 0x6f, 0xa2, 0x7b, 0x2f, 0xdf, 0x87, 0xba, 0x2e, 0xa6, 0x6b, 0xa8, 0xd2, 0x66,
	0x48, 0x49, 0x4d, 0xd8, 0x35, 0x55, 0xd7, 0x9b, 0x9e, 0x06, 0x45, 0xbd, 0xad, 0xca, 0x72, 0x15,
	0x8f, 0xb2, 0xab, 0x1d, 0xef, 0x81, 0x1d, 0x6d, 0x82, 0xe5, 0x36, 0x5b, 0x3a, 0x0d, 0x0e, 0x9f,
	0x21, 0xb0, 0x4e, 0x45, 0x48, 0x49, 0x1b, 0x1a, 0xf2, 0x9b, 0x6d, 0x05, 0x81, 0x1d, 0x89, 0x8a,
	0x59, 0xc6, 0x1f, 0x26, 0xdf, 0x72, 0xd3, 0x60, 0x89, 0x3f, 0x4e, 0x48, 0x0f, 0x76, 0x25, 0x57,
	0xe9, 0x2e, 0xfe, 0x34, 0x21, 0x7b, 0x80, 0x73, 0x36, 0xaf, 0x21, 0xfe, 0x3c, 0x21, 0xfb, 0xd0,
	0xcd, 0xe9, 0xe2, 0xf9, 0xf8, 0xcb, 0xe4, 0xf0, 0x3d, 0x02, 0x28, 0xc7, 0x96, 0x74, 0x72, 0x94,
	0x69, 0xd9, 0x85, 0x56, 0xae, 0x43, 0xef, 0x69, 0x71, 0xe0, 0x4c, 0x88, 0x25, 0x36, 0x48, 0x17,
	0x76, 0x34, 0xce, 0xb7, 0xd4, 0x24, 0x04, 0x3a, 0x9a, 0xfa, 0xe7, 0x92, 0x26, 0x29, 0x5b, 0x51,
	0x6c, 0x95, 0xc7, 0x4e, 0xc5, 0x2a, 0xf6, 0x13, 0xb9, 0xc2, 0x18, 0xda, 0xd9, 0x73, 0xc2, 0xf0,
	0x84, 0xa6, 0xb8, 0x5e, 0x26, 0xd3, 0xcb, 0xef, 0x90, 0x7d, 0x20, 0x15, 0x22, 0x0f, 0x6d, 0x92,
	0x3d, 0xe8, 0x66, 0xfc, 0x26, 0x15, 0x39, 0x0d, 0x55, 0xb1, 0x9c, 0x5e, 0xe1, 0x56, 0x49, 0xe8,
	0x5f, 0x44, 0xfb, 0xe4, 0xa7, 0x37, 0xb7, 0x7d, 0x74, 0x73, 0xdb, 0x47, 0xef, 0x6e, 0xfb, 0xe8,
	0xc5, 0x5d, 0xbf, 0x76, 0x73, 0xd7, 0xaf, 0xbd, 0xbd, 0xeb, 0xd7, 0x1e, 0xca, 0x7f, 0xf6, 0xac,
	0xae, 0xfe, 0xc5, 0xbf, 0x7f, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xc1, 0xdb, 0xfe, 0xe2, 0xcc, 0x05,
	0x00, 0x00,
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Player) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Down != 0 {
		i = encodeVarintZjh(dAtA, i, uint64((uint32(m.Down)<<1)^uint32((m.Down>>31))))
		i--
		dAtA[i] = 0x50
	}
	if m.Look {
		i--
		if m.Look {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.State != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Bet != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
		i--
		dAtA[i] = 0x30
	}
	if m.Coin != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
		i--
		dAtA[i] = 0x28
	}
	if m.Chair != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Chair))
		i--
		dAtA[i] = 0x20
	}
	if m.Vip != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Vip))
		i--
		dAtA[i] = 0x18
	}
	if m.Icon != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Icon))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Opponent != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Opponent))
		i--
		dAtA[i] = 0x18
	}
	if m.Bet != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ActionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActionAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Coin != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Winners) > 0 {
		dAtA2 := make([]byte, len(m.Winners)*10)
		var j1 int
		for _, num1 := range m.Winners {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintZjh(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Players) > 0 {
		dAtA4 := make([]byte, len(m.Players)*10)
		var j3 int
		for _, num1 := range m.Players {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintZjh(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0x2a
	}
	if m.Bet != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
		i--
		dAtA[i] = 0x20
	}
	if m.Uid != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Poker) > 0 {
		i -= len(m.Poker)
		copy(dAtA[i:], m.Poker)
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameInitAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInitAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameInitAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Poker) > 0 {
		i -= len(m.Poker)
		copy(dAtA[i:], m.Poker)
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintZjh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Ring != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Ring))
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.Pool != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Pool))
		i--
		dAtA[i] = 0x18
	}
	if m.Id != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x10
	}
	if m.Table != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Table))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameStartAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameStartAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameStartAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for iNdEx := len(m.Players) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Players[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintZjh(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Pool != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Pool))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GameResultAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameResultAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GameResultAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lucky != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Lucky))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Poker) > 0 {
		i -= len(m.Poker)
		copy(dAtA[i:], m.Poker)
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Coin != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Prize) > 0 {
		dAtA6 := make([]byte, len(m.Prize)*10)
		var j5 int
		for _, num1 := range m.Prize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintZjh(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Winner) > 0 {
		dAtA8 := make([]byte, len(m.Winner)*10)
		var j7 int
		for _, num1 := range m.Winner {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintZjh(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintZjh(dAtA []byte, offset int, v uint64) int {
	offset -= sovZjh(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Icon != 0 {
		n += 1 + sovZjh(uint64(m.Icon))
	}
	if m.Vip != 0 {
		n += 1 + sovZjh(uint64(m.Vip))
	}
	if m.Chair != 0 {
		n += 1 + sovZjh(uint64(m.Chair))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovZjh(uint64(m.State))
	}
	if m.Look {
		n += 2
	}
	if m.Down != 0 {
		n += 1 + sozZjh(uint64(m.Down))
	}
	return n
}

func (m *ActionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovZjh(uint64(m.Type))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	if m.Opponent != 0 {
		n += 1 + sovZjh(uint64(m.Opponent))
	}
	return n
}

func (m *ActionAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovZjh(uint64(m.Type))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	if len(m.Players) > 0 {
		l = 0
		for _, e := range m.Players {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if len(m.Winners) > 0 {
		l = 0
		for _, e := range m.Winners {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *GameInitAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Table != 0 {
		n += 1 + sovZjh(uint64(m.Table))
	}
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Pool != 0 {
		n += 1 + sovZjh(uint64(m.Pool))
	}
	if m.State != 0 {
		n += 1 + sovZjh(uint64(m.State))
	}
	if m.Ring != 0 {
		n += 1 + sovZjh(uint64(m.Ring))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *GameStartAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Pool != 0 {
		n += 1 + sovZjh(uint64(m.Pool))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	return n
}

func (m *GameResultAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if len(m.Winner) > 0 {
		l = 0
		for _, e := range m.Winner {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if len(m.Prize) > 0 {
		l = 0
		for _, e := range m.Prize {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Lucky != 0 {
		n += 1 + sovZjh(uint64(m.Lucky))
	}
	return n
}

func sovZjh(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozZjh(x uint64) (n int) {
	return sovZjh(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			m.Icon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chair", wireType)
			}
			m.Chair = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chair |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Player_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Look", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Look = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Down = v
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opponent", wireType)
			}
			m.Opponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opponent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Players = append(m.Players, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Players) == 0 {
					m.Players = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Players = append(m.Players, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winners = append(m.Winners, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Winners) == 0 {
					m.Winners = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Winners = append(m.Winners, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Winners", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInitAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInitAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInitAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			m.Ring = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ring |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameStartAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameStartAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameStartAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameResultAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameResultAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameResultAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winner = append(m.Winner, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Winner) == 0 {
					m.Winner = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Winner = append(m.Winner, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Winner", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Prize = append(m.Prize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Prize) == 0 {
					m.Prize = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Prize = append(m.Prize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipZjh(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthZjh
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupZjh
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthZjh
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthZjh        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowZjh          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupZjh = fmt.Errorf("proto: unexpected end of group")
)
