// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: zjh.proto

package zjh

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Zjh_Code int32

const (
	// 8300-8399(炸金花)
	Zjh_None             Zjh_Code = 0
	Zjh_ActionLookReq    Zjh_Code = 8300
	Zjh_ActionLookAck    Zjh_Code = 8301
	Zjh_ActionDiscardReq Zjh_Code = 8302
	Zjh_ActionDiscardAck Zjh_Code = 8303
	Zjh_ActionCompareReq Zjh_Code = 8304
	Zjh_ActionCompareAck Zjh_Code = 8305
	Zjh_ActionBetReq     Zjh_Code = 8306
	Zjh_ActionBetAck     Zjh_Code = 8307
	Zjh_ActionAllinReq   Zjh_Code = 8308
	Zjh_ActionAllinAck   Zjh_Code = 8309
	Zjh_ActionLeaveReq   Zjh_Code = 8310
	Zjh_ActionLeaveAck   Zjh_Code = 8311
	Zjh_GameInitAck      Zjh_Code = 8313
	Zjh_GameStartAck     Zjh_Code = 8315
	Zjh_GameEndAck       Zjh_Code = 8316
)

var Zjh_Code_name = map[int32]string{
	0:    "None",
	8300: "ActionLookReq",
	8301: "ActionLookAck",
	8302: "ActionDiscardReq",
	8303: "ActionDiscardAck",
	8304: "ActionCompareReq",
	8305: "ActionCompareAck",
	8306: "ActionBetReq",
	8307: "ActionBetAck",
	8308: "ActionAllinReq",
	8309: "ActionAllinAck",
	8310: "ActionLeaveReq",
	8311: "ActionLeaveAck",
	8313: "GameInitAck",
	8315: "GameStartAck",
	8316: "GameEndAck",
}
var Zjh_Code_value = map[string]int32{
	"None":             0,
	"ActionLookReq":    8300,
	"ActionLookAck":    8301,
	"ActionDiscardReq": 8302,
	"ActionDiscardAck": 8303,
	"ActionCompareReq": 8304,
	"ActionCompareAck": 8305,
	"ActionBetReq":     8306,
	"ActionBetAck":     8307,
	"ActionAllinReq":   8308,
	"ActionAllinAck":   8309,
	"ActionLeaveReq":   8310,
	"ActionLeaveAck":   8311,
	"GameInitAck":      8313,
	"GameStartAck":     8315,
	"GameEndAck":       8316,
}

func (x Zjh_Code) String() string {
	return proto.EnumName(Zjh_Code_name, int32(x))
}
func (Zjh_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{0, 0}
}

type Player_State int32

const (
	// 没有准备
	Player_None Player_State = 0
	// 已准备
	Player_Read Player_State = 1
	// 游戏中
	Player_Playing Player_State = 2
	// 已弃牌
	Player_Discard Player_State = 3
	// PK失败
	Player_Lost Player_State = 4
	// 赢得最终胜利
	Player_Win Player_State = 5
	// 离开
	Player_Leave Player_State = 6
)

var Player_State_name = map[int32]string{
	0: "None",
	1: "Read",
	2: "Playing",
	3: "Discard",
	4: "Lost",
	5: "Win",
	6: "Leave",
}
var Player_State_value = map[string]int32{
	"None":    0,
	"Read":    1,
	"Playing": 2,
	"Discard": 3,
	"Lost":    4,
	"Win":     5,
	"Leave":   6,
}

func (x Player_State) String() string {
	return proto.EnumName(Player_State_name, int32(x))
}
func (Player_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{1, 0}
}

type ActionLog_Type int32

const (
	ActionLog_None ActionLog_Type = 0
	// 看牌
	ActionLog_Look ActionLog_Type = 1
	// 主动弃牌
	ActionLog_Discard ActionLog_Type = 2
	// 超时弃牌
	ActionLog_Overtime ActionLog_Type = 3
	// 比牌
	ActionLog_Compare ActionLog_Type = 4
	// 加注
	ActionLog_Bet ActionLog_Type = 5
	// 全压
	ActionLog_Allin ActionLog_Type = 6
	// 自动比牌
	ActionLog_AutoCompare ActionLog_Type = 7
	// 离开
	ActionLog_Leave ActionLog_Type = 8
)

var ActionLog_Type_name = map[int32]string{
	0: "None",
	1: "Look",
	2: "Discard",
	3: "Overtime",
	4: "Compare",
	5: "Bet",
	6: "Allin",
	7: "AutoCompare",
	8: "Leave",
}
var ActionLog_Type_value = map[string]int32{
	"None":        0,
	"Look":        1,
	"Discard":     2,
	"Overtime":    3,
	"Compare":     4,
	"Bet":         5,
	"Allin":       6,
	"AutoCompare": 7,
	"Leave":       8,
}

func (x ActionLog_Type) String() string {
	return proto.EnumName(ActionLog_Type_name, int32(x))
}
func (ActionLog_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{16, 0}
}

type Zjh struct {
}

func (m *Zjh) Reset()         { *m = Zjh{} }
func (m *Zjh) String() string { return proto.CompactTextString(m) }
func (*Zjh) ProtoMessage()    {}
func (*Zjh) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{0}
}
func (m *Zjh) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Zjh) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Zjh.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Zjh) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Zjh.Merge(dst, src)
}
func (m *Zjh) XXX_Size() int {
	return m.Size()
}
func (m *Zjh) XXX_DiscardUnknown() {
	xxx_messageInfo_Zjh.DiscardUnknown(m)
}

var xxx_messageInfo_Zjh proto.InternalMessageInfo

// 玩家信息
type Player struct {
	// 玩家ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	// 玩家头像
	Icon int32 `protobuf:"varint,2,opt,name=icon,proto3" json:"icon,omitempty" bson:"icon" msg:"icon"`
	// VIP等级
	Vip int32 `protobuf:"varint,3,opt,name=vip,proto3" json:"vip,omitempty" bson:"vip" msg:"vip"`
	// 椅子号
	Chair int32 `protobuf:"varint,4,opt,name=chair,proto3" json:"chair,omitempty" bson:"chair" msg:"chair"`
	// 玩家带的分
	Coin int64 `protobuf:"varint,5,opt,name=coin,proto3" json:"coin,omitempty" bson:"coin" msg:"coin"`
	// 玩家的下注
	Bet int64 `protobuf:"varint,6,opt,name=bet,proto3" json:"bet,omitempty" bson:"bet" msg:"bet"`
	// 玩家名称
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty" bson:"name" msg:"name"`
	// 游戏状态
	State Player_State `protobuf:"varint,8,opt,name=state,proto3,enum=zjh.Player_State" json:"state,omitempty" bson:"state" msg:"state"`
	// 是否已看牌
	Look bool `protobuf:"varint,9,opt,name=look,proto3" json:"look,omitempty" bson:"look" msg:"look"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{1}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(dst, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetIcon() int32 {
	if m != nil {
		return m.Icon
	}
	return 0
}

func (m *Player) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *Player) GetChair() int32 {
	if m != nil {
		return m.Chair
	}
	return 0
}

func (m *Player) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *Player) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetState() Player_State {
	if m != nil {
		return m.State
	}
	return Player_None
}

func (m *Player) GetLook() bool {
	if m != nil {
		return m.Look
	}
	return false
}

// 玩家结算信息
type GameBill struct {
	// 玩家ID
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	// 开始游戏时带的钱
	Coin int64 `protobuf:"varint,2,opt,name=coin,proto3" json:"c" bson:"c" msg:"c"`
	// 投注总额
	Bet int64 `protobuf:"varint,3,opt,name=bet,proto3" json:"b" bson:"b" msg:"b"`
	// 发牌情况
	Poker []byte `protobuf:"bytes,4,opt,name=poker,proto3" json:"p" bson:"p" msg:"p"`
	// 输赢情况
	Win int64 `protobuf:"zigzag64,5,opt,name=win,proto3" json:"w" bson:"w" msg:"w"`
	// 税收
	Tax int64 `protobuf:"varint,6,opt,name=tax,proto3" json:"t,omitempty" bson:"t,omitempty" msg:"t,omitempty"`
	// 玩家类型
	Job int32 `protobuf:"varint,7,opt,name=job,proto3" json:"j,omitempty" bson:"j,omitempty" msg:"j,omitempty"`
	// 喜钱
	Lottery int64 `protobuf:"varint,8,opt,name=lottery,proto3" json:"l,omitempty" bson:"l,omitempty" msg:"l,omitempty"`
	// 彩池税收
	PoolTax int32 `protobuf:"varint,9,opt,name=poolTax,proto3" json:"x,omitempty" bson:"x,omitempty" msg:"x,omitempty"`
}

func (m *GameBill) Reset()         { *m = GameBill{} }
func (m *GameBill) String() string { return proto.CompactTextString(m) }
func (*GameBill) ProtoMessage()    {}
func (*GameBill) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{2}
}
func (m *GameBill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameBill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameBill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameBill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameBill.Merge(dst, src)
}
func (m *GameBill) XXX_Size() int {
	return m.Size()
}
func (m *GameBill) XXX_DiscardUnknown() {
	xxx_messageInfo_GameBill.DiscardUnknown(m)
}

var xxx_messageInfo_GameBill proto.InternalMessageInfo

func (m *GameBill) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GameBill) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *GameBill) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *GameBill) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameBill) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameBill) GetTax() int64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *GameBill) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *GameBill) GetLottery() int64 {
	if m != nil {
		return m.Lottery
	}
	return 0
}

func (m *GameBill) GetPoolTax() int32 {
	if m != nil {
		return m.PoolTax
	}
	return 0
}

// 炸金花日志
type GameRound struct {
	// 游戏ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"_id" bson:"_id" msg:"_id"`
	// 游戏开始时间
	Start int64 `protobuf:"varint,2,opt,name=start,proto3" json:"s" bson:"s" msg:"s"`
	// 游戏结束时间
	End int64 `protobuf:"varint,3,opt,name=end,proto3" json:"e" bson:"e" msg:"e"`
	// 房间ID
	Room int32 `protobuf:"varint,4,opt,name=room,proto3" json:"r" bson:"r" msg:"r"`
	// 桌子ID
	Tab int32 `protobuf:"varint,5,opt,name=tab,proto3" json:"t,omitempty" bson:"t,omitempty" msg:"t,omitempty"`
	// 所有玩家结算汇总
	Bill []*GameBill `protobuf:"bytes,6,rep,name=bill,proto3" json:"b" bson:"b" msg:"b"`
	// 系统税收
	Tax int64 `protobuf:"varint,8,opt,name=tax,proto3" json:"x" bson:"x" msg:"x"`
	// 系统输赢
	Win int64 `protobuf:"zigzag64,9,opt,name=win,proto3" json:"w" bson:"w" msg:"w"`
	// 备注
	Note string `protobuf:"bytes,10,opt,name=note,proto3" json:"n,omitempty" bson:"n,omitempty" msg:"n,omitempty"`
}

func (m *GameRound) Reset()         { *m = GameRound{} }
func (m *GameRound) String() string { return proto.CompactTextString(m) }
func (*GameRound) ProtoMessage()    {}
func (*GameRound) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{3}
}
func (m *GameRound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameRound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameRound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameRound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameRound.Merge(dst, src)
}
func (m *GameRound) XXX_Size() int {
	return m.Size()
}
func (m *GameRound) XXX_DiscardUnknown() {
	xxx_messageInfo_GameRound.DiscardUnknown(m)
}

var xxx_messageInfo_GameRound proto.InternalMessageInfo

func (m *GameRound) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameRound) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *GameRound) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *GameRound) GetRoom() int32 {
	if m != nil {
		return m.Room
	}
	return 0
}

func (m *GameRound) GetTab() int32 {
	if m != nil {
		return m.Tab
	}
	return 0
}

func (m *GameRound) GetBill() []*GameBill {
	if m != nil {
		return m.Bill
	}
	return nil
}

func (m *GameRound) GetTax() int64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *GameRound) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameRound) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

// 看牌
type ActionLookReq struct {
}

func (m *ActionLookReq) Reset()         { *m = ActionLookReq{} }
func (m *ActionLookReq) String() string { return proto.CompactTextString(m) }
func (*ActionLookReq) ProtoMessage()    {}
func (*ActionLookReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{4}
}
func (m *ActionLookReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLookReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLookReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLookReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLookReq.Merge(dst, src)
}
func (m *ActionLookReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionLookReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLookReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLookReq proto.InternalMessageInfo

type ActionLookAck struct {
	Poker []byte `protobuf:"bytes,1,opt,name=poker,proto3" json:"p" bson:"p" msg:"p"`
}

func (m *ActionLookAck) Reset()         { *m = ActionLookAck{} }
func (m *ActionLookAck) String() string { return proto.CompactTextString(m) }
func (*ActionLookAck) ProtoMessage()    {}
func (*ActionLookAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{5}
}
func (m *ActionLookAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLookAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLookAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLookAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLookAck.Merge(dst, src)
}
func (m *ActionLookAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionLookAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLookAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLookAck proto.InternalMessageInfo

func (m *ActionLookAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

// 弃牌
type ActionDiscardReq struct {
}

func (m *ActionDiscardReq) Reset()         { *m = ActionDiscardReq{} }
func (m *ActionDiscardReq) String() string { return proto.CompactTextString(m) }
func (*ActionDiscardReq) ProtoMessage()    {}
func (*ActionDiscardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{6}
}
func (m *ActionDiscardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDiscardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDiscardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionDiscardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDiscardReq.Merge(dst, src)
}
func (m *ActionDiscardReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionDiscardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDiscardReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDiscardReq proto.InternalMessageInfo

type ActionDiscardAck struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
}

func (m *ActionDiscardAck) Reset()         { *m = ActionDiscardAck{} }
func (m *ActionDiscardAck) String() string { return proto.CompactTextString(m) }
func (*ActionDiscardAck) ProtoMessage()    {}
func (*ActionDiscardAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{7}
}
func (m *ActionDiscardAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDiscardAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDiscardAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionDiscardAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDiscardAck.Merge(dst, src)
}
func (m *ActionDiscardAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionDiscardAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDiscardAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDiscardAck proto.InternalMessageInfo

func (m *ActionDiscardAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// 比牌
type ActionCompareReq struct {
	// 对手ID
	Opponent int32 `protobuf:"varint,1,opt,name=opponent,proto3" json:"o,omitempty" bson:"o,omitempty" msg:"o,omitempty"`
}

func (m *ActionCompareReq) Reset()         { *m = ActionCompareReq{} }
func (m *ActionCompareReq) String() string { return proto.CompactTextString(m) }
func (*ActionCompareReq) ProtoMessage()    {}
func (*ActionCompareReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{8}
}
func (m *ActionCompareReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionCompareReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionCompareReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionCompareReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionCompareReq.Merge(dst, src)
}
func (m *ActionCompareReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionCompareReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionCompareReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionCompareReq proto.InternalMessageInfo

func (m *ActionCompareReq) GetOpponent() int32 {
	if m != nil {
		return m.Opponent
	}
	return 0
}

type ActionCompareAck struct {
	Uid      int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	Opponent int32 `protobuf:"varint,2,opt,name=opponent,proto3" json:"o,omitempty" bson:"o,omitempty" msg:"o,omitempty"`
	Win      bool  `protobuf:"varint,3,opt,name=win,proto3" json:"w,omitempty" bson:"w,omitempty" msg:"w,omitempty"`
}

func (m *ActionCompareAck) Reset()         { *m = ActionCompareAck{} }
func (m *ActionCompareAck) String() string { return proto.CompactTextString(m) }
func (*ActionCompareAck) ProtoMessage()    {}
func (*ActionCompareAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{9}
}
func (m *ActionCompareAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionCompareAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionCompareAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionCompareAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionCompareAck.Merge(dst, src)
}
func (m *ActionCompareAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionCompareAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionCompareAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionCompareAck proto.InternalMessageInfo

func (m *ActionCompareAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionCompareAck) GetOpponent() int32 {
	if m != nil {
		return m.Opponent
	}
	return 0
}

func (m *ActionCompareAck) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

// 下注(跟注+加注)
type ActionBetReq struct {
	Coin int64 `protobuf:"varint,1,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
}

func (m *ActionBetReq) Reset()         { *m = ActionBetReq{} }
func (m *ActionBetReq) String() string { return proto.CompactTextString(m) }
func (*ActionBetReq) ProtoMessage()    {}
func (*ActionBetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{10}
}
func (m *ActionBetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionBetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionBetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionBetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionBetReq.Merge(dst, src)
}
func (m *ActionBetReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionBetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionBetReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionBetReq proto.InternalMessageInfo

func (m *ActionBetReq) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

type ActionBetAck struct {
	Uid  int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	Coin int64 `protobuf:"varint,2,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
}

func (m *ActionBetAck) Reset()         { *m = ActionBetAck{} }
func (m *ActionBetAck) String() string { return proto.CompactTextString(m) }
func (*ActionBetAck) ProtoMessage()    {}
func (*ActionBetAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{11}
}
func (m *ActionBetAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionBetAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionBetAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionBetAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionBetAck.Merge(dst, src)
}
func (m *ActionBetAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionBetAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionBetAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionBetAck proto.InternalMessageInfo

func (m *ActionBetAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionBetAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

// 全压
type ActionAllinReq struct {
	Coin int64 `protobuf:"varint,1,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
}

func (m *ActionAllinReq) Reset()         { *m = ActionAllinReq{} }
func (m *ActionAllinReq) String() string { return proto.CompactTextString(m) }
func (*ActionAllinReq) ProtoMessage()    {}
func (*ActionAllinReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{12}
}
func (m *ActionAllinReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionAllinReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionAllinReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionAllinReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionAllinReq.Merge(dst, src)
}
func (m *ActionAllinReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionAllinReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionAllinReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionAllinReq proto.InternalMessageInfo

func (m *ActionAllinReq) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

type ActionAllinAck struct {
	Uid  int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	Coin int64 `protobuf:"varint,2,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
}

func (m *ActionAllinAck) Reset()         { *m = ActionAllinAck{} }
func (m *ActionAllinAck) String() string { return proto.CompactTextString(m) }
func (*ActionAllinAck) ProtoMessage()    {}
func (*ActionAllinAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{13}
}
func (m *ActionAllinAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionAllinAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionAllinAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionAllinAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionAllinAck.Merge(dst, src)
}
func (m *ActionAllinAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionAllinAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionAllinAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionAllinAck proto.InternalMessageInfo

func (m *ActionAllinAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionAllinAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

// 离开
type ActionLeaveReq struct {
}

func (m *ActionLeaveReq) Reset()         { *m = ActionLeaveReq{} }
func (m *ActionLeaveReq) String() string { return proto.CompactTextString(m) }
func (*ActionLeaveReq) ProtoMessage()    {}
func (*ActionLeaveReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{14}
}
func (m *ActionLeaveReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLeaveReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLeaveReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLeaveReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLeaveReq.Merge(dst, src)
}
func (m *ActionLeaveReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionLeaveReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLeaveReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLeaveReq proto.InternalMessageInfo

type ActionLeaveAck struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
}

func (m *ActionLeaveAck) Reset()         { *m = ActionLeaveAck{} }
func (m *ActionLeaveAck) String() string { return proto.CompactTextString(m) }
func (*ActionLeaveAck) ProtoMessage()    {}
func (*ActionLeaveAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{15}
}
func (m *ActionLeaveAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLeaveAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLeaveAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLeaveAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLeaveAck.Merge(dst, src)
}
func (m *ActionLeaveAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionLeaveAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLeaveAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLeaveAck proto.InternalMessageInfo

func (m *ActionLeaveAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type ActionLog struct {
	// 时间
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"s" bson:"s" msg:"s"`
	// 玩家ID
	Uid int32 `protobuf:"varint,2,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	// 动作类型
	Type ActionLog_Type `protobuf:"varint,3,opt,name=type,proto3,enum=zjh.ActionLog_Type" json:"t" bson:"t" msg:"t"`
	// 金额
	Coin int64 `protobuf:"varint,4,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
	// 对手ID
	Opponent int32 `protobuf:"varint,5,opt,name=opponent,proto3" json:"o,omitempty" bson:"o,omitempty" msg:"o,omitempty"`
}

func (m *ActionLog) Reset()         { *m = ActionLog{} }
func (m *ActionLog) String() string { return proto.CompactTextString(m) }
func (*ActionLog) ProtoMessage()    {}
func (*ActionLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{16}
}
func (m *ActionLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLog.Merge(dst, src)
}
func (m *ActionLog) XXX_Size() int {
	return m.Size()
}
func (m *ActionLog) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLog.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLog proto.InternalMessageInfo

func (m *ActionLog) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ActionLog) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionLog) GetType() ActionLog_Type {
	if m != nil {
		return m.Type
	}
	return ActionLog_None
}

func (m *ActionLog) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *ActionLog) GetOpponent() int32 {
	if m != nil {
		return m.Opponent
	}
	return 0
}

type GameInitAck struct {
	// 当前游戏ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	// 当前游戏状态
	State int32 `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty" bson:"state" msg:"state"`
	// 玩家(第1个位置为先)
	Player []*Player `protobuf:"bytes,3,rep,name=player,proto3" json:"player,omitempty" bson:"play" msg:"play"`
	// 我的牌,如果已看牌
	Poker []byte `protobuf:"bytes,4,opt,name=poker,proto3" json:"p" bson:"p" msg:"p"`
}

func (m *GameInitAck) Reset()         { *m = GameInitAck{} }
func (m *GameInitAck) String() string { return proto.CompactTextString(m) }
func (*GameInitAck) ProtoMessage()    {}
func (*GameInitAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{17}
}
func (m *GameInitAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInitAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInitAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameInitAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInitAck.Merge(dst, src)
}
func (m *GameInitAck) XXX_Size() int {
	return m.Size()
}
func (m *GameInitAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInitAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameInitAck proto.InternalMessageInfo

func (m *GameInitAck) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameInitAck) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *GameInitAck) GetPlayer() []*Player {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *GameInitAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

// 游戏开始
type GameStartAck struct {
	// 当前游戏ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	// 玩家(第1个位置为先)
	Player []*Player `protobuf:"bytes,2,rep,name=player,proto3" json:"player,omitempty" bson:"play" msg:"play"`
}

func (m *GameStartAck) Reset()         { *m = GameStartAck{} }
func (m *GameStartAck) String() string { return proto.CompactTextString(m) }
func (*GameStartAck) ProtoMessage()    {}
func (*GameStartAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{18}
}
func (m *GameStartAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameStartAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameStartAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameStartAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameStartAck.Merge(dst, src)
}
func (m *GameStartAck) XXX_Size() int {
	return m.Size()
}
func (m *GameStartAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameStartAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameStartAck proto.InternalMessageInfo

func (m *GameStartAck) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameStartAck) GetPlayer() []*Player {
	if m != nil {
		return m.Player
	}
	return nil
}

// 游戏结束
type GameEndAck struct {
	// 多人游戏开奖结果
	R *GameResult `protobuf:"bytes,1,opt,name=r,proto3" json:"r,omitempty" bson:"r" msg:"r"`
	// 我的输赢情况
	Win int64 `protobuf:"varint,2,opt,name=win,proto3" json:"win,omitempty" bson:"win" msg:"win"`
	// 我的金币数
	Coin int64 `protobuf:"varint,3,opt,name=coin,proto3" json:"coin,omitempty" bson:"coin" msg:"coin"`
	// 发牌情况
	Poker []byte `protobuf:"bytes,4,opt,name=poker,proto3" json:"p" bson:"p" msg:"p"`
}

func (m *GameEndAck) Reset()         { *m = GameEndAck{} }
func (m *GameEndAck) String() string { return proto.CompactTextString(m) }
func (*GameEndAck) ProtoMessage()    {}
func (*GameEndAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{19}
}
func (m *GameEndAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameEndAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameEndAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameEndAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameEndAck.Merge(dst, src)
}
func (m *GameEndAck) XXX_Size() int {
	return m.Size()
}
func (m *GameEndAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameEndAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameEndAck proto.InternalMessageInfo

func (m *GameEndAck) GetR() *GameResult {
	if m != nil {
		return m.R
	}
	return nil
}

func (m *GameEndAck) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameEndAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *GameEndAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

// 开奖结果(红黑/龙虎/百家乐/色宝)
type GameResult struct {
	// 当前游戏ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	// 发牌情况
	Poker []byte `protobuf:"bytes,2,opt,name=poker,proto3" json:"poker,omitempty" bson:"p" msg:"p"`
	// 各个区域的赔付情况
	Odd []int32 `protobuf:"varint,4,rep,packed,name=odd,proto3" json:"odd,omitempty" bson:"odd" msg:"odd"`
	// 各个区域的投注情况
	Sum []int64 `protobuf:"varint,5,rep,packed,name=sum,proto3" json:"sum,omitempty" bson:"sum" msg:"sum"`
	// 富豪玩家的输赢
	Rich []int64 `protobuf:"varint,6,rep,packed,name=rich,proto3" json:"rich,omitempty" bson:"rich" msg:"rich"`
}

func (m *GameResult) Reset()         { *m = GameResult{} }
func (m *GameResult) String() string { return proto.CompactTextString(m) }
func (*GameResult) ProtoMessage()    {}
func (*GameResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_b25598133aeb8ae5, []int{20}
}
func (m *GameResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameResult.Merge(dst, src)
}
func (m *GameResult) XXX_Size() int {
	return m.Size()
}
func (m *GameResult) XXX_DiscardUnknown() {
	xxx_messageInfo_GameResult.DiscardUnknown(m)
}

var xxx_messageInfo_GameResult proto.InternalMessageInfo

func (m *GameResult) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameResult) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameResult) GetOdd() []int32 {
	if m != nil {
		return m.Odd
	}
	return nil
}

func (m *GameResult) GetSum() []int64 {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *GameResult) GetRich() []int64 {
	if m != nil {
		return m.Rich
	}
	return nil
}

func init() {
	proto.RegisterType((*Zjh)(nil), "zjh.Zjh")
	proto.RegisterType((*Player)(nil), "zjh.Player")
	proto.RegisterType((*GameBill)(nil), "zjh.GameBill")
	proto.RegisterType((*GameRound)(nil), "zjh.GameRound")
	proto.RegisterType((*ActionLookReq)(nil), "zjh.ActionLookReq")
	proto.RegisterType((*ActionLookAck)(nil), "zjh.ActionLookAck")
	proto.RegisterType((*ActionDiscardReq)(nil), "zjh.ActionDiscardReq")
	proto.RegisterType((*ActionDiscardAck)(nil), "zjh.ActionDiscardAck")
	proto.RegisterType((*ActionCompareReq)(nil), "zjh.ActionCompareReq")
	proto.RegisterType((*ActionCompareAck)(nil), "zjh.ActionCompareAck")
	proto.RegisterType((*ActionBetReq)(nil), "zjh.ActionBetReq")
	proto.RegisterType((*ActionBetAck)(nil), "zjh.ActionBetAck")
	proto.RegisterType((*ActionAllinReq)(nil), "zjh.ActionAllinReq")
	proto.RegisterType((*ActionAllinAck)(nil), "zjh.ActionAllinAck")
	proto.RegisterType((*ActionLeaveReq)(nil), "zjh.ActionLeaveReq")
	proto.RegisterType((*ActionLeaveAck)(nil), "zjh.ActionLeaveAck")
	proto.RegisterType((*ActionLog)(nil), "zjh.ActionLog")
	proto.RegisterType((*GameInitAck)(nil), "zjh.GameInitAck")
	proto.RegisterType((*GameStartAck)(nil), "zjh.GameStartAck")
	proto.RegisterType((*GameEndAck)(nil), "zjh.GameEndAck")
	proto.RegisterType((*GameResult)(nil), "zjh.GameResult")
	proto.RegisterEnum("zjh.Zjh_Code", Zjh_Code_name, Zjh_Code_value)
	proto.RegisterEnum("zjh.Player_State", Player_State_name, Player_State_value)
	proto.RegisterEnum("zjh.ActionLog_Type", ActionLog_Type_name, ActionLog_Type_value)
}
func (m *Zjh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Zjh) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Icon != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Icon))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Vip))
	}
	if m.Chair != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Chair))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.State != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.State))
	}
	if m.Look {
		dAtA[i] = 0x48
		i++
		if m.Look {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GameBill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameBill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	if m.Win != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint64(m.Win)<<1)^uint64((m.Win>>63))))
	}
	if m.Tax != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tax))
	}
	if m.Job != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Job))
	}
	if m.Lottery != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Lottery))
	}
	if m.PoolTax != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.PoolTax))
	}
	return i, nil
}

func (m *GameRound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameRound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Start != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.End))
	}
	if m.Room != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Room))
	}
	if m.Tab != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tab))
	}
	if len(m.Bill) > 0 {
		for _, msg := range m.Bill {
			dAtA[i] = 0x32
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Tax != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tax))
	}
	if m.Win != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint64(m.Win)<<1)^uint64((m.Win>>63))))
	}
	if len(m.Note) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Note)))
		i += copy(dAtA[i:], m.Note)
	}
	return i, nil
}

func (m *ActionLookReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLookReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ActionLookAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLookAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Poker) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	return i, nil
}

func (m *ActionDiscardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDiscardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ActionDiscardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDiscardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *ActionCompareReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionCompareReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Opponent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Opponent))
	}
	return i, nil
}

func (m *ActionCompareAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionCompareAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Opponent != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Opponent))
	}
	if m.Win {
		dAtA[i] = 0x18
		i++
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ActionBetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionBetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Coin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ActionBetAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionBetAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ActionAllinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionAllinReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Coin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ActionAllinAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionAllinAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ActionLeaveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLeaveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ActionLeaveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLeaveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *ActionLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Start))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Type))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if m.Opponent != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Opponent))
	}
	return i, nil
}

func (m *GameInitAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInitAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.State))
	}
	if len(m.Player) > 0 {
		for _, msg := range m.Player {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	return i, nil
}

func (m *GameStartAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameStartAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if len(m.Player) > 0 {
		for _, msg := range m.Player {
			dAtA[i] = 0x12
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GameEndAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameEndAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.R != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.R.Size()))
		n1, err := m.R.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Win != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Win))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	return i, nil
}

func (m *GameResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	if len(m.Odd) > 0 {
		dAtA3 := make([]byte, len(m.Odd)*10)
		var j2 int
		for _, num1 := range m.Odd {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.Sum) > 0 {
		dAtA5 := make([]byte, len(m.Sum)*10)
		var j4 int
		for _, num1 := range m.Sum {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if len(m.Rich) > 0 {
		dAtA7 := make([]byte, len(m.Rich)*10)
		var j6 int
		for _, num1 := range m.Rich {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func encodeVarintZjh(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Zjh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Icon != 0 {
		n += 1 + sovZjh(uint64(m.Icon))
	}
	if m.Vip != 0 {
		n += 1 + sovZjh(uint64(m.Vip))
	}
	if m.Chair != 0 {
		n += 1 + sovZjh(uint64(m.Chair))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovZjh(uint64(m.State))
	}
	if m.Look {
		n += 2
	}
	return n
}

func (m *GameBill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Win != 0 {
		n += 1 + sozZjh(uint64(m.Win))
	}
	if m.Tax != 0 {
		n += 1 + sovZjh(uint64(m.Tax))
	}
	if m.Job != 0 {
		n += 1 + sovZjh(uint64(m.Job))
	}
	if m.Lottery != 0 {
		n += 1 + sovZjh(uint64(m.Lottery))
	}
	if m.PoolTax != 0 {
		n += 1 + sovZjh(uint64(m.PoolTax))
	}
	return n
}

func (m *GameRound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Start != 0 {
		n += 1 + sovZjh(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovZjh(uint64(m.End))
	}
	if m.Room != 0 {
		n += 1 + sovZjh(uint64(m.Room))
	}
	if m.Tab != 0 {
		n += 1 + sovZjh(uint64(m.Tab))
	}
	if len(m.Bill) > 0 {
		for _, e := range m.Bill {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	if m.Tax != 0 {
		n += 1 + sovZjh(uint64(m.Tax))
	}
	if m.Win != 0 {
		n += 1 + sozZjh(uint64(m.Win))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *ActionLookReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ActionLookAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *ActionDiscardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ActionDiscardAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	return n
}

func (m *ActionCompareReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opponent != 0 {
		n += 1 + sovZjh(uint64(m.Opponent))
	}
	return n
}

func (m *ActionCompareAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Opponent != 0 {
		n += 1 + sovZjh(uint64(m.Opponent))
	}
	if m.Win {
		n += 2
	}
	return n
}

func (m *ActionBetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *ActionBetAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *ActionAllinReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *ActionAllinAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *ActionLeaveReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ActionLeaveAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	return n
}

func (m *ActionLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovZjh(uint64(m.Start))
	}
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Type != 0 {
		n += 1 + sovZjh(uint64(m.Type))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	if m.Opponent != 0 {
		n += 1 + sovZjh(uint64(m.Opponent))
	}
	return n
}

func (m *GameInitAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.State != 0 {
		n += 1 + sovZjh(uint64(m.State))
	}
	if len(m.Player) > 0 {
		for _, e := range m.Player {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *GameStartAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if len(m.Player) > 0 {
		for _, e := range m.Player {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	return n
}

func (m *GameEndAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.R != nil {
		l = m.R.Size()
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Win != 0 {
		n += 1 + sovZjh(uint64(m.Win))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *GameResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if len(m.Odd) > 0 {
		l = 0
		for _, e := range m.Odd {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if len(m.Sum) > 0 {
		l = 0
		for _, e := range m.Sum {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if len(m.Rich) > 0 {
		l = 0
		for _, e := range m.Rich {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	return n
}

func sovZjh(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozZjh(x uint64) (n int) {
	return sovZjh(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Zjh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Zjh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Zjh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			m.Icon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icon |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chair", wireType)
			}
			m.Chair = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chair |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (Player_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Look", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Look = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameBill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameBill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameBill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Win = int64(v)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			m.Tax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lottery", wireType)
			}
			m.Lottery = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lottery |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolTax", wireType)
			}
			m.PoolTax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolTax |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameRound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameRound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameRound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			m.Room = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Room |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tab", wireType)
			}
			m.Tab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tab |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bill = append(m.Bill, &GameBill{})
			if err := m.Bill[len(m.Bill)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			m.Tax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Win = int64(v)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLookReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLookReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLookReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLookAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLookAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLookAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDiscardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDiscardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDiscardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDiscardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDiscardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDiscardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionCompareReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionCompareReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionCompareReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opponent", wireType)
			}
			m.Opponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opponent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionCompareAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionCompareAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionCompareAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opponent", wireType)
			}
			m.Opponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opponent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionBetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionBetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionBetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionBetAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionBetAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionBetAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionAllinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionAllinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionAllinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionAllinAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionAllinAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionAllinAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLeaveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLeaveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLeaveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLeaveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLeaveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLeaveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ActionLog_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opponent", wireType)
			}
			m.Opponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opponent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInitAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInitAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInitAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Player = append(m.Player, &Player{})
			if err := m.Player[len(m.Player)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameStartAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameStartAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameStartAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Player = append(m.Player, &Player{})
			if err := m.Player[len(m.Player)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameEndAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameEndAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameEndAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.R == nil {
				m.R = &GameResult{}
			}
			if err := m.R.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			m.Win = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Win |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Odd = append(m.Odd, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Odd) == 0 {
					m.Odd = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Odd = append(m.Odd, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Odd", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sum = append(m.Sum, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Sum) == 0 {
					m.Sum = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sum = append(m.Sum, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rich = append(m.Rich, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Rich) == 0 {
					m.Rich = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rich = append(m.Rich, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rich", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipZjh(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthZjh
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipZjh(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthZjh = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowZjh   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("zjh.proto", fileDescriptor_zjh_b25598133aeb8ae5) }

var fileDescriptor_zjh_b25598133aeb8ae5 = []byte{
	// 1406 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xcd, 0x8e, 0x1b, 0x45,
	0x10, 0xde, 0xf1, 0x8c, 0x77, 0xed, 0x76, 0x92, 0x9d, 0x74, 0x42, 0x34, 0x44, 0xb0, 0xb6, 0x5a,
	0x08, 0xad, 0x12, 0xb2, 0x2b, 0x6d, 0x0e, 0x48, 0x08, 0x14, 0xaf, 0x43, 0x84, 0xa2, 0x44, 0xfc,
	0xf4, 0x46, 0x42, 0x0a, 0x42, 0x91, 0x3d, 0x6e, 0xec, 0xf1, 0xda, 0xd3, 0xc3, 0xb8, 0xbd, 0xf6,
	0xe6, 0x09, 0x10, 0x27, 0x8e, 0xbc, 0x04, 0x4f, 0x01, 0x07, 0x0e, 0x08, 0xe5, 0x88, 0x84, 0x64,
	0x50, 0x72, 0x41, 0x11, 0xbf, 0xe6, 0x4f, 0x11, 0x1c, 0x50, 0x55, 0xcf, 0x78, 0x66, 0x6c, 0x13,
	0x79, 0xc9, 0x4a, 0xdc, 0xca, 0x35, 0x5f, 0x7f, 0x5d, 0x5d, 0xfd, 0x75, 0x75, 0xb5, 0x49, 0xf1,
	0x6e, 0xa7, 0xbd, 0x15, 0x84, 0x52, 0x49, 0x6a, 0xde, 0xed, 0xb4, 0xcf, 0x5f, 0x6a, 0x79, 0xaa,
	0x3d, 0x68, 0x6c, 0xb9, 0xb2, 0xb7, 0xdd, 0x92, 0x2d, 0xb9, 0x8d, 0xdf, 0x1a, 0x83, 0xf7, 0xf0,
	0x17, 0xfe, 0x40, 0x4b, 0x8f, 0x61, 0x5f, 0xe4, 0x88, 0x79, 0xbb, 0xd3, 0x66, 0x9f, 0xe5, 0x88,
	0x75, 0x55, 0x36, 0x05, 0x2d, 0x10, 0xeb, 0x75, 0xe9, 0x0b, 0x7b, 0x85, 0x52, 0x72, 0x72, 0xd7,
	0x55, 0x9e, 0xf4, 0x6f, 0x4a, 0xb9, 0xcf, 0xc5, 0xfb, 0xf6, 0xf7, 0xd5, 0xac, 0x6f, 0xd7, 0xdd,
	0xb7, 0x7f, 0xa8, 0xd2, 0xa7, 0x88, 0xad, 0x7d, 0xaf, 0x7a, 0x7d, 0xb7, 0x1e, 0x36, 0x01, 0xfa,
	0xe3, 0xbc, 0x1b, 0xd0, 0x3f, 0xa5, 0xdc, 0x57, 0x65, 0x2f, 0xa8, 0x87, 0x02, 0xd0, 0x3f, 0xcf,
	0xbb, 0x01, 0xfd, 0x4b, 0x95, 0x9e, 0x26, 0x27, 0xb4, 0xbb, 0x26, 0x14, 0x20, 0x27, 0x59, 0x17,
	0xa0, 0x7e, 0xad, 0xd2, 0x33, 0xe4, 0x94, 0x76, 0xed, 0x76, 0xbb, 0x9e, 0x0f, 0xb8, 0xdf, 0x66,
	0x9d, 0x80, 0xfc, 0x3d, 0xe5, 0xbc, 0x29, 0xea, 0x07, 0x38, 0xf7, 0x1f, 0xb3, 0x4e, 0x40, 0xfe,
	0x59, 0xa5, 0x36, 0x29, 0xbd, 0x56, 0xef, 0x89, 0xeb, 0xbe, 0x87, 0xb3, 0x3c, 0xc2, 0x89, 0xc1,
	0xb3, 0xa7, 0xea, 0x21, 0xba, 0xfe, 0xaa, 0xd2, 0x75, 0x42, 0xc0, 0x75, 0xcd, 0xc7, 0xd5, 0xfd,
	0x5d, 0x65, 0x1f, 0x5b, 0x64, 0xf5, 0xcd, 0x6e, 0xfd, 0x50, 0x84, 0xf4, 0x79, 0x92, 0xf3, 0x9a,
	0x8e, 0x51, 0x31, 0x36, 0xf3, 0xb5, 0x73, 0x93, 0x71, 0x99, 0x36, 0xfa, 0xd2, 0x7f, 0x89, 0x79,
	0x4d, 0x56, 0xe9, 0xf5, 0x5b, 0x68, 0xf0, 0x9c, 0xd7, 0xa4, 0x5b, 0xc4, 0xf2, 0x5c, 0xe9, 0x3b,
	0x39, 0x44, 0x9e, 0x9f, 0x8c, 0xcb, 0xe7, 0x22, 0xa4, 0x2b, 0xfd, 0x18, 0x0b, 0x26, 0x47, 0x1c,
	0xbd, 0x40, 0xcc, 0x03, 0x2f, 0x70, 0x4c, 0x84, 0x3b, 0x93, 0x71, 0xf9, 0xac, 0x86, 0x1f, 0x78,
	0x41, 0x84, 0x06, 0x8b, 0x03, 0x88, 0xee, 0x90, 0xbc, 0xdb, 0xae, 0x7b, 0xa1, 0x63, 0x21, 0xfa,
	0x99, 0xc9, 0xb8, 0xec, 0x68, 0x34, 0xba, 0x23, 0xbc, 0xb6, 0xb9, 0x86, 0x42, 0x3c, 0xae, 0xf4,
	0x7c, 0x27, 0x5f, 0x31, 0x36, 0xcd, 0x74, 0x3c, 0xe0, 0x8d, 0x47, 0x80, 0xc9, 0x11, 0x07, 0xf1,
	0x34, 0x84, 0x72, 0x56, 0x11, 0x9e, 0x8a, 0xa7, 0x21, 0x54, 0x84, 0x06, 0x8b, 0x03, 0x08, 0xb8,
	0xfd, 0x7a, 0x4f, 0x38, 0x6b, 0x15, 0x63, 0xb3, 0x98, 0xe6, 0x06, 0x6f, 0x84, 0x46, 0x93, 0x23,
	0x8e, 0x5e, 0x23, 0xf9, 0xbe, 0xaa, 0x2b, 0xe1, 0x14, 0x2a, 0xc6, 0xe6, 0xa9, 0x9d, 0xd3, 0x5b,
	0x20, 0x76, 0x9d, 0xdf, 0xad, 0x3d, 0xf8, 0x90, 0x5e, 0x12, 0x22, 0x23, 0x12, 0x6d, 0x73, 0x3d,
	0x1a, 0xa6, 0xed, 0x4a, 0xb9, 0xef, 0x14, 0x2b, 0xc6, 0x66, 0x21, 0x3d, 0x2d, 0x78, 0xa3, 0x11,
	0x68, 0x72, 0xc4, 0xb1, 0x3d, 0x92, 0x47, 0xf6, 0xd4, 0x61, 0x28, 0x10, 0x8b, 0x8b, 0x7a, 0xd3,
	0x36, 0x68, 0x89, 0xac, 0x41, 0x04, 0x9e, 0xdf, 0xb2, 0x73, 0xf0, 0x23, 0x92, 0xb7, 0x6d, 0x02,
	0xe6, 0xa6, 0xec, 0x2b, 0xdb, 0xa2, 0x6b, 0xc4, 0x7c, 0xdb, 0xf3, 0xed, 0x3c, 0x2d, 0x92, 0x3c,
	0x8a, 0xca, 0x5e, 0x65, 0x9f, 0x58, 0xa4, 0x00, 0x62, 0xa9, 0x79, 0xdd, 0x2e, 0xbd, 0x48, 0xcc,
	0xc1, 0x54, 0x1d, 0x4f, 0x3f, 0x1c, 0x97, 0x8d, 0xc1, 0x64, 0x5c, 0xb6, 0x75, 0x54, 0x83, 0x28,
	0xa4, 0x01, 0xe3, 0x80, 0xa2, 0x97, 0xa2, 0x1d, 0xc9, 0x61, 0x8a, 0x11, 0xed, 0x26, 0x68, 0x37,
	0xde, 0x93, 0x78, 0x43, 0x2e, 0xea, 0x0d, 0x31, 0x13, 0x74, 0x23, 0x41, 0x37, 0xe2, 0x3d, 0x89,
	0x76, 0x64, 0x9b, 0xe4, 0x03, 0xb9, 0x2f, 0xb4, 0x42, 0x4e, 0x68, 0x78, 0x90, 0xc0, 0x63, 0x49,
	0x05, 0x8c, 0x6b, 0x1c, 0xb0, 0x0f, 0x23, 0x75, 0x50, 0x0d, 0x1f, 0x26, 0xf0, 0x61, 0x04, 0x1f,
	0x32, 0x0e, 0x28, 0x7a, 0x9d, 0x98, 0xaa, 0x3e, 0x8a, 0xb4, 0xf1, 0xe2, 0xc3, 0x71, 0xb9, 0xa4,
	0x5e, 0x90, 0x3d, 0x4f, 0x89, 0x5e, 0xa0, 0x0e, 0x27, 0xe3, 0xf2, 0x73, 0x7a, 0x58, 0xca, 0x19,
	0x11, 0xa4, 0x3d, 0x1c, 0x38, 0x80, 0xaa, 0x23, 0x1b, 0xa8, 0x9c, 0xbc, 0xa6, 0xea, 0x2c, 0xa2,
	0xea, 0xcc, 0x51, 0x75, 0x32, 0x54, 0x1d, 0xd9, 0xa0, 0x6f, 0x91, 0xb5, 0xae, 0x54, 0x4a, 0x84,
	0x87, 0xa8, 0xab, 0x28, 0xb2, 0xee, 0x22, 0xba, 0xee, 0x1c, 0x5d, 0xda, 0xc3, 0x63, 0x1e, 0xa0,
	0x0c, 0xa4, 0xec, 0xde, 0xaa, 0x8f, 0x50, 0x64, 0x51, 0x84, 0xa3, 0x45, 0x94, 0xa3, 0x39, 0xca,
	0x51, 0x86, 0x32, 0xe2, 0x61, 0x8f, 0x4c, 0x52, 0x04, 0xbd, 0x70, 0x39, 0xf0, 0x9b, 0x74, 0x7b,
	0x5a, 0x4d, 0xcc, 0x5a, 0xf9, 0xe1, 0xb8, 0x6c, 0xde, 0xf1, 0x9a, 0xc9, 0x59, 0xbb, 0x33, 0xad,
	0x2a, 0x77, 0xe2, 0xb2, 0xb2, 0x8d, 0x47, 0x27, 0x54, 0x69, 0xd5, 0xf4, 0x93, 0x9d, 0xea, 0xc7,
	0x07, 0x45, 0x1f, 0x92, 0x50, 0xc1, 0xc6, 0x0a, 0xbf, 0x99, 0x96, 0x8d, 0x48, 0xe0, 0xf1, 0xb9,
	0x12, 0x8c, 0x03, 0x0a, 0x24, 0x19, 0x4a, 0xd9, 0x8b, 0xea, 0x0a, 0xa2, 0xc3, 0x04, 0x1d, 0x17,
	0x96, 0x90, 0x71, 0x84, 0x69, 0x1d, 0x34, 0x50, 0x34, 0xf9, 0x27, 0xd2, 0x41, 0x83, 0xbe, 0x4c,
	0xac, 0x86, 0xd7, 0xed, 0x3a, 0xab, 0x15, 0x73, 0xb3, 0xb4, 0x73, 0x12, 0x2b, 0x42, 0x7c, 0xac,
	0x1e, 0xa7, 0x76, 0x1c, 0x05, 0x8b, 0x04, 0x41, 0x16, 0x92, 0x45, 0x8e, 0x12, 0xf4, 0x28, 0xde,
	0x8f, 0x48, 0x72, 0x91, 0xd4, 0x8b, 0x4b, 0x49, 0xfd, 0x06, 0xb1, 0x7c, 0xa9, 0x84, 0x43, 0xb0,
	0xb4, 0xe1, 0x1a, 0xfd, 0x45, 0x6b, 0xf4, 0xe7, 0xd6, 0x98, 0xf6, 0x70, 0x24, 0x61, 0xeb, 0x33,
	0x57, 0x2f, 0xab, 0xce, 0xdc, 0xbb, 0xc9, 0xb9, 0x35, 0x96, 0x3b, 0xb7, 0x8c, 0xce, 0xdf, 0xd2,
	0xec, 0xca, 0xfc, 0x15, 0x7d, 0xa4, 0xca, 0xc4, 0x5a, 0xf3, 0x97, 0x39, 0xdd, 0x23, 0x05, 0x19,
	0x04, 0xd2, 0x17, 0xbe, 0x8a, 0x58, 0x30, 0x19, 0x72, 0x51, 0x32, 0xe4, 0x5c, 0x32, 0xd2, 0x1e,
	0x3e, 0x25, 0x62, 0xdf, 0x18, 0xf3, 0xfd, 0xc1, 0xd1, 0x8a, 0x68, 0x3a, 0xac, 0xdc, 0x31, 0x85,
	0x05, 0xba, 0x06, 0x85, 0x98, 0x78, 0xaf, 0x20, 0xdf, 0x70, 0x11, 0xdf, 0x70, 0x8e, 0x6f, 0x98,
	0xd1, 0xf5, 0xd0, 0xf3, 0xd9, 0x3b, 0xd9, 0x4e, 0x07, 0xf4, 0x84, 0x45, 0xdf, 0x48, 0x2a, 0x94,
	0xbb, 0x88, 0xdb, 0x9d, 0xe3, 0x76, 0x33, 0x7a, 0xc2, 0xab, 0xfa, 0x03, 0x23, 0xdb, 0x34, 0x1d,
	0x2d, 0x75, 0x37, 0x32, 0xf7, 0xcf, 0x13, 0x86, 0xf2, 0xee, 0x6c, 0xaf, 0x76, 0xbc, 0x2b, 0xfd,
	0xd0, 0x98, 0x6d, 0xfb, 0xfe, 0xc7, 0xb5, 0xda, 0xb3, 0xdd, 0x26, 0x7b, 0x65, 0xb6, 0xd5, 0x3c,
	0xda, 0x79, 0xfb, 0xd4, 0x24, 0xc5, 0xb8, 0x0e, 0xb4, 0x92, 0x12, 0x6f, 0x2c, 0x5f, 0xe2, 0x61,
	0xae, 0xdc, 0x52, 0x99, 0xa8, 0x11, 0x4b, 0x1d, 0x06, 0x02, 0xc5, 0x7d, 0x6a, 0xe7, 0x0c, 0x16,
	0xda, 0xe9, 0xdc, 0x5b, 0xb7, 0x0e, 0x03, 0xa1, 0x29, 0x54, 0x42, 0x11, 0x37, 0x7c, 0x8a, 0x71,
	0x1c, 0x3b, 0xcd, 0xa6, 0x75, 0x0c, 0xd9, 0xcc, 0x9c, 0xe0, 0xfc, 0x71, 0x15, 0x96, 0x90, 0x58,
	0xb0, 0x94, 0x6c, 0xa7, 0x07, 0x45, 0x56, 0x77, 0x7a, 0x71, 0x73, 0x97, 0xa3, 0x27, 0x48, 0xe1,
	0x8d, 0x03, 0x11, 0x2a, 0xaf, 0x27, 0x6c, 0x13, 0x3e, 0x45, 0x85, 0x48, 0x77, 0x7b, 0x35, 0xa1,
	0x74, 0xb7, 0x87, 0xaa, 0xb3, 0x57, 0xe9, 0x3a, 0x29, 0xed, 0x0e, 0x94, 0x8c, 0x41, 0x6b, 0x49,
	0x27, 0x58, 0x60, 0x5f, 0x1b, 0x99, 0xb7, 0x45, 0xea, 0xa5, 0x60, 0x3e, 0xf6, 0xa5, 0xb0, 0x13,
	0x77, 0xc3, 0xb9, 0xd9, 0x6e, 0xfe, 0xdf, 0x5b, 0xdf, 0x2b, 0x64, 0x35, 0xc0, 0x7e, 0xd9, 0x31,
	0xf1, 0xc2, 0x2c, 0xa5, 0x5a, 0xe8, 0x74, 0x27, 0x0c, 0xa0, 0xf8, 0xce, 0x00, 0x93, 0x47, 0xc3,
	0x8e, 0xdc, 0x20, 0xb2, 0x61, 0xf6, 0x99, 0xb4, 0xf4, 0xea, 0x92, 0x48, 0x73, 0xff, 0x29, 0x52,
	0xf6, 0xa5, 0x91, 0x7e, 0x8d, 0xd1, 0xcb, 0xc4, 0xd0, 0xb7, 0x63, 0x69, 0x67, 0x7d, 0xda, 0x25,
	0x70, 0xd1, 0x1f, 0x74, 0x55, 0xed, 0xec, 0xc2, 0x5e, 0xc5, 0x08, 0xe1, 0x31, 0x33, 0x9c, 0x9e,
	0xfe, 0xd4, 0x63, 0x66, 0x38, 0x7d, 0xfa, 0x80, 0xa5, 0x6f, 0xfc, 0xf8, 0xa1, 0x64, 0x2e, 0xf9,
	0x50, 0x3a, 0x72, 0x26, 0xbf, 0x8b, 0x16, 0xa4, 0x83, 0x5e, 0x3a, 0x91, 0x17, 0xe2, 0x79, 0x72,
	0x38, 0xcf, 0xd9, 0xc7, 0x75, 0xf3, 0x17, 0x88, 0x29, 0x9b, 0x4d, 0xc7, 0xaa, 0x98, 0xd9, 0xc7,
	0xa4, 0x6c, 0xc6, 0xac, 0x60, 0x71, 0x00, 0x01, 0xb6, 0x3f, 0xe8, 0x39, 0xf9, 0x8a, 0x99, 0xcd,
	0x4d, 0x7f, 0xd0, 0x8b, 0xa5, 0x37, 0xe8, 0x31, 0x0e, 0x20, 0xc8, 0x4d, 0xe8, 0xb9, 0x6d, 0xec,
	0xd2, 0x32, 0xb9, 0x01, 0x6f, 0x9c, 0x71, 0x30, 0x39, 0xe2, 0x6a, 0xcf, 0x7e, 0x7e, 0x7f, 0xc3,
	0xb8, 0x77, 0x7f, 0xc3, 0xf8, 0xf6, 0xfe, 0x86, 0xf1, 0xd1, 0x83, 0x8d, 0x95, 0x7b, 0x0f, 0x36,
	0x56, 0xbe, 0x7a, 0xb0, 0xb1, 0x72, 0xdb, 0xbc, 0xdb, 0x69, 0x37, 0x56, 0xf1, 0xcf, 0x8a, 0xcb,
	0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x74, 0x98, 0xcf, 0x1b, 0xed, 0x10, 0x00, 0x00,
}
