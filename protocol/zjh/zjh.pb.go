// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: zjh.proto

package zjh

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Zjh_Code int32

const (
	// 8300-8399(炸金花)
	Zjh_None             Zjh_Code = 0
	Zjh_ActionLookReq    Zjh_Code = 8300
	Zjh_ActionLookAck    Zjh_Code = 8301
	Zjh_ActionDiscardReq Zjh_Code = 8302
	Zjh_ActionDiscardAck Zjh_Code = 8303
	Zjh_ActionCompareReq Zjh_Code = 8304
	Zjh_ActionCompareAck Zjh_Code = 8305
	Zjh_ActionBetReq     Zjh_Code = 8306
	Zjh_ActionBetAck     Zjh_Code = 8307
	Zjh_ActionAllinReq   Zjh_Code = 8308
	Zjh_ActionAllinAck   Zjh_Code = 8309
	Zjh_ActionLeaveReq   Zjh_Code = 8310
	Zjh_ActionLeaveAck   Zjh_Code = 8311
	Zjh_GameInitAck      Zjh_Code = 8313
	Zjh_GameStartAck     Zjh_Code = 8315
	Zjh_GameEndAck       Zjh_Code = 8316
)

var Zjh_Code_name = map[int32]string{
	0:    "None",
	8300: "ActionLookReq",
	8301: "ActionLookAck",
	8302: "ActionDiscardReq",
	8303: "ActionDiscardAck",
	8304: "ActionCompareReq",
	8305: "ActionCompareAck",
	8306: "ActionBetReq",
	8307: "ActionBetAck",
	8308: "ActionAllinReq",
	8309: "ActionAllinAck",
	8310: "ActionLeaveReq",
	8311: "ActionLeaveAck",
	8313: "GameInitAck",
	8315: "GameStartAck",
	8316: "GameEndAck",
}
var Zjh_Code_value = map[string]int32{
	"None":             0,
	"ActionLookReq":    8300,
	"ActionLookAck":    8301,
	"ActionDiscardReq": 8302,
	"ActionDiscardAck": 8303,
	"ActionCompareReq": 8304,
	"ActionCompareAck": 8305,
	"ActionBetReq":     8306,
	"ActionBetAck":     8307,
	"ActionAllinReq":   8308,
	"ActionAllinAck":   8309,
	"ActionLeaveReq":   8310,
	"ActionLeaveAck":   8311,
	"GameInitAck":      8313,
	"GameStartAck":     8315,
	"GameEndAck":       8316,
}

func (x Zjh_Code) String() string {
	return proto.EnumName(Zjh_Code_name, int32(x))
}
func (Zjh_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{0, 0}
}

type Player_State int32

const (
	// 没有准备
	Player_None Player_State = 0
	// 已准备
	Player_Read Player_State = 1
	// 游戏中
	Player_Playing Player_State = 2
	// 已弃牌
	Player_Discard Player_State = 3
	// PK失败
	Player_Lost Player_State = 4
	// 赢得最终胜利
	Player_Win Player_State = 5
	// 离开
	Player_Leave Player_State = 6
)

var Player_State_name = map[int32]string{
	0: "None",
	1: "Read",
	2: "Playing",
	3: "Discard",
	4: "Lost",
	5: "Win",
	6: "Leave",
}
var Player_State_value = map[string]int32{
	"None":    0,
	"Read":    1,
	"Playing": 2,
	"Discard": 3,
	"Lost":    4,
	"Win":     5,
	"Leave":   6,
}

func (x Player_State) String() string {
	return proto.EnumName(Player_State_name, int32(x))
}
func (Player_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{1, 0}
}

type ActionLog_Type int32

const (
	ActionLog_None ActionLog_Type = 0
	// 看牌
	ActionLog_Look ActionLog_Type = 1
	// 主动弃牌
	ActionLog_Discard ActionLog_Type = 2
	// 超时弃牌
	ActionLog_Overtime ActionLog_Type = 3
	// 比牌
	ActionLog_Compare ActionLog_Type = 4
	// 加注
	ActionLog_Bet ActionLog_Type = 5
	// 全压
	ActionLog_Allin ActionLog_Type = 6
	// 自动比牌
	ActionLog_AutoCompare ActionLog_Type = 7
	// 离开
	ActionLog_Leave ActionLog_Type = 8
)

var ActionLog_Type_name = map[int32]string{
	0: "None",
	1: "Look",
	2: "Discard",
	3: "Overtime",
	4: "Compare",
	5: "Bet",
	6: "Allin",
	7: "AutoCompare",
	8: "Leave",
}
var ActionLog_Type_value = map[string]int32{
	"None":        0,
	"Look":        1,
	"Discard":     2,
	"Overtime":    3,
	"Compare":     4,
	"Bet":         5,
	"Allin":       6,
	"AutoCompare": 7,
	"Leave":       8,
}

func (x ActionLog_Type) String() string {
	return proto.EnumName(ActionLog_Type_name, int32(x))
}
func (ActionLog_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{16, 0}
}

type Zjh struct {
}

func (m *Zjh) Reset()         { *m = Zjh{} }
func (m *Zjh) String() string { return proto.CompactTextString(m) }
func (*Zjh) ProtoMessage()    {}
func (*Zjh) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{0}
}
func (m *Zjh) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Zjh) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Zjh.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Zjh) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Zjh.Merge(dst, src)
}
func (m *Zjh) XXX_Size() int {
	return m.Size()
}
func (m *Zjh) XXX_DiscardUnknown() {
	xxx_messageInfo_Zjh.DiscardUnknown(m)
}

var xxx_messageInfo_Zjh proto.InternalMessageInfo

// 玩家信息
type Player struct {
	// 玩家ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	// 玩家头像
	Icon int32 `protobuf:"varint,2,opt,name=icon,proto3" json:"icon,omitempty" bson:"icon" msg:"icon"`
	// VIP等级
	Vip int32 `protobuf:"varint,3,opt,name=vip,proto3" json:"vip,omitempty" bson:"vip" msg:"vip"`
	// 椅子号
	Chair int32 `protobuf:"varint,4,opt,name=chair,proto3" json:"chair,omitempty" bson:"chair" msg:"chair"`
	// 玩家带的分
	Coin int64 `protobuf:"varint,5,opt,name=coin,proto3" json:"coin,omitempty" bson:"coin" msg:"coin"`
	// 玩家的下注
	Bet int64 `protobuf:"varint,6,opt,name=bet,proto3" json:"bet,omitempty" bson:"bet" msg:"bet"`
	// 玩家名称
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty" bson:"name" msg:"name"`
	// 游戏状态
	State Player_State `protobuf:"varint,8,opt,name=state,proto3,enum=zjh.Player_State" json:"state,omitempty" bson:"state" msg:"state"`
	// 是否已看牌
	Look bool `protobuf:"varint,9,opt,name=look,proto3" json:"look,omitempty" bson:"look" msg:"look"`
	// 倒计时(等待玩家命令倒计时)
	Down int32 `protobuf:"zigzag32,10,opt,name=down,proto3" json:"down,omitempty" bson:"down" msg:"down"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{1}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(dst, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetIcon() int32 {
	if m != nil {
		return m.Icon
	}
	return 0
}

func (m *Player) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *Player) GetChair() int32 {
	if m != nil {
		return m.Chair
	}
	return 0
}

func (m *Player) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *Player) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetState() Player_State {
	if m != nil {
		return m.State
	}
	return Player_None
}

func (m *Player) GetLook() bool {
	if m != nil {
		return m.Look
	}
	return false
}

func (m *Player) GetDown() int32 {
	if m != nil {
		return m.Down
	}
	return 0
}

// 玩家结算信息
type GameBill struct {
	// 玩家ID(u有建立索引，不要更改名称)
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	// 玩家类型
	Job int32 `protobuf:"varint,2,opt,name=job,proto3" json:"j,omitempty" bson:"j,omitempty" msg:"j,omitempty"`
	// 开始游戏时带的钱
	Coin int64 `protobuf:"varint,3,opt,name=coin,proto3" json:"c" bson:"c" msg:"c"`
	// 投注总额
	Bet int64 `protobuf:"varint,4,opt,name=bet,proto3" json:"b" bson:"b" msg:"b"`
	// 发牌情况
	Poker []byte `protobuf:"bytes,5,opt,name=poker,proto3" json:"p" bson:"p" msg:"p"`
	// 输赢情况
	Win int64 `protobuf:"zigzag64,6,opt,name=win,proto3" json:"w" bson:"w" msg:"w"`
	// 税收
	Tax int64 `protobuf:"varint,7,opt,name=tax,proto3" json:"x,omitempty" bson:"x,omitempty" msg:"x,omitempty"`
	// 和机器人之间的输赢
	WinRobot int64 `protobuf:"zigzag64,8,opt,name=winRobot,proto3" json:"t,omitempty" bson:"t,omitempty" msg:"t,omitempty"`
}

func (m *GameBill) Reset()         { *m = GameBill{} }
func (m *GameBill) String() string { return proto.CompactTextString(m) }
func (*GameBill) ProtoMessage()    {}
func (*GameBill) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{2}
}
func (m *GameBill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameBill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameBill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameBill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameBill.Merge(dst, src)
}
func (m *GameBill) XXX_Size() int {
	return m.Size()
}
func (m *GameBill) XXX_DiscardUnknown() {
	xxx_messageInfo_GameBill.DiscardUnknown(m)
}

var xxx_messageInfo_GameBill proto.InternalMessageInfo

func (m *GameBill) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GameBill) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *GameBill) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *GameBill) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *GameBill) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameBill) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameBill) GetTax() int64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *GameBill) GetWinRobot() int64 {
	if m != nil {
		return m.WinRobot
	}
	return 0
}

// 炸金花日志
type GameRound struct {
	// 游戏ID(i有建立索引，不要更改名称)
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"i" bson:"i" msg:"i"`
	// 游戏开始时间(s有建立索引，不要更改名称)
	Start int64 `protobuf:"varint,2,opt,name=start,proto3" json:"s" bson:"s" msg:"s"`
	// 游戏结束时间
	End int64 `protobuf:"varint,3,opt,name=end,proto3" json:"e" bson:"e" msg:"e"`
	// 房间ID
	Room int32 `protobuf:"varint,4,opt,name=room,proto3" json:"r" bson:"r" msg:"r"`
	// 桌子ID
	Tab int32 `protobuf:"varint,5,opt,name=tab,proto3" json:"t" bson:"t" msg:"t"`
	// 所有玩家结算汇总(b.u有建立索引，不要更改名称)
	Bill []*GameBill `protobuf:"bytes,6,rep,name=bill,proto3" json:"b" bson:"b" msg:"b"`
	// 下注轮数
	Ring int32 `protobuf:"varint,7,opt,name=ring,proto3" json:"g" bson:"g" msg:"g"`
	// 下注总金币
	Sum int64 `protobuf:"varint,8,opt,name=sum,proto3" json:"m" bson:"m" msg:"m"`
	// 系统输赢
	Win int64 `protobuf:"zigzag64,9,opt,name=win,proto3" json:"w" bson:"w" msg:"w"`
	// 系统总税收
	Tax int64 `protobuf:"varint,10,opt,name=tax,proto3" json:"x" bson:"x" msg:"x"`
	// 进入彩池的税收
	Pool int64 `protobuf:"varint,11,opt,name=pool,proto3" json:"o,omitempty" bson:"o,omitempty" msg:"o,omitempty"`
	// 喜钱，从彩池单独出
	Lucky int64 `protobuf:"varint,12,opt,name=lucky,proto3" json:"l,omitempty" bson:"l,omitempty" msg:"l,omitempty"`
	// 备注
	Note string `protobuf:"bytes,13,opt,name=note,proto3" json:"n,omitempty" bson:"n,omitempty" msg:"n,omitempty"`
}

func (m *GameRound) Reset()         { *m = GameRound{} }
func (m *GameRound) String() string { return proto.CompactTextString(m) }
func (*GameRound) ProtoMessage()    {}
func (*GameRound) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{3}
}
func (m *GameRound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameRound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameRound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameRound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameRound.Merge(dst, src)
}
func (m *GameRound) XXX_Size() int {
	return m.Size()
}
func (m *GameRound) XXX_DiscardUnknown() {
	xxx_messageInfo_GameRound.DiscardUnknown(m)
}

var xxx_messageInfo_GameRound proto.InternalMessageInfo

func (m *GameRound) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameRound) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *GameRound) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *GameRound) GetRoom() int32 {
	if m != nil {
		return m.Room
	}
	return 0
}

func (m *GameRound) GetTab() int32 {
	if m != nil {
		return m.Tab
	}
	return 0
}

func (m *GameRound) GetBill() []*GameBill {
	if m != nil {
		return m.Bill
	}
	return nil
}

func (m *GameRound) GetRing() int32 {
	if m != nil {
		return m.Ring
	}
	return 0
}

func (m *GameRound) GetSum() int64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *GameRound) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameRound) GetTax() int64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *GameRound) GetPool() int64 {
	if m != nil {
		return m.Pool
	}
	return 0
}

func (m *GameRound) GetLucky() int64 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func (m *GameRound) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

// 看牌
type ActionLookReq struct {
	// 玩家ID
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
}

func (m *ActionLookReq) Reset()         { *m = ActionLookReq{} }
func (m *ActionLookReq) String() string { return proto.CompactTextString(m) }
func (*ActionLookReq) ProtoMessage()    {}
func (*ActionLookReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{4}
}
func (m *ActionLookReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLookReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLookReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLookReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLookReq.Merge(dst, src)
}
func (m *ActionLookReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionLookReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLookReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLookReq proto.InternalMessageInfo

func (m *ActionLookReq) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type ActionLookAck struct {
	Poker []byte `protobuf:"bytes,1,opt,name=poker,proto3" json:"p" bson:"p" msg:"p"`
}

func (m *ActionLookAck) Reset()         { *m = ActionLookAck{} }
func (m *ActionLookAck) String() string { return proto.CompactTextString(m) }
func (*ActionLookAck) ProtoMessage()    {}
func (*ActionLookAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{5}
}
func (m *ActionLookAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLookAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLookAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLookAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLookAck.Merge(dst, src)
}
func (m *ActionLookAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionLookAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLookAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLookAck proto.InternalMessageInfo

func (m *ActionLookAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

// 弃牌
type ActionDiscardReq struct {
	// 玩家ID
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
}

func (m *ActionDiscardReq) Reset()         { *m = ActionDiscardReq{} }
func (m *ActionDiscardReq) String() string { return proto.CompactTextString(m) }
func (*ActionDiscardReq) ProtoMessage()    {}
func (*ActionDiscardReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{6}
}
func (m *ActionDiscardReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDiscardReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDiscardReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionDiscardReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDiscardReq.Merge(dst, src)
}
func (m *ActionDiscardReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionDiscardReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDiscardReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDiscardReq proto.InternalMessageInfo

func (m *ActionDiscardReq) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type ActionDiscardAck struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
}

func (m *ActionDiscardAck) Reset()         { *m = ActionDiscardAck{} }
func (m *ActionDiscardAck) String() string { return proto.CompactTextString(m) }
func (*ActionDiscardAck) ProtoMessage()    {}
func (*ActionDiscardAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{7}
}
func (m *ActionDiscardAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionDiscardAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionDiscardAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionDiscardAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionDiscardAck.Merge(dst, src)
}
func (m *ActionDiscardAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionDiscardAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionDiscardAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionDiscardAck proto.InternalMessageInfo

func (m *ActionDiscardAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

// 比牌
type ActionCompareReq struct {
	// 对手ID
	Opponent int32 `protobuf:"varint,1,opt,name=opponent,proto3" json:"o,omitempty" bson:"o,omitempty" msg:"o,omitempty"`
}

func (m *ActionCompareReq) Reset()         { *m = ActionCompareReq{} }
func (m *ActionCompareReq) String() string { return proto.CompactTextString(m) }
func (*ActionCompareReq) ProtoMessage()    {}
func (*ActionCompareReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{8}
}
func (m *ActionCompareReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionCompareReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionCompareReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionCompareReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionCompareReq.Merge(dst, src)
}
func (m *ActionCompareReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionCompareReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionCompareReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionCompareReq proto.InternalMessageInfo

func (m *ActionCompareReq) GetOpponent() int32 {
	if m != nil {
		return m.Opponent
	}
	return 0
}

type ActionCompareAck struct {
	Uid      int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	Opponent int32 `protobuf:"varint,2,opt,name=opponent,proto3" json:"o,omitempty" bson:"o,omitempty" msg:"o,omitempty"`
	Win      bool  `protobuf:"varint,3,opt,name=win,proto3" json:"w,omitempty" bson:"w,omitempty" msg:"w,omitempty"`
}

func (m *ActionCompareAck) Reset()         { *m = ActionCompareAck{} }
func (m *ActionCompareAck) String() string { return proto.CompactTextString(m) }
func (*ActionCompareAck) ProtoMessage()    {}
func (*ActionCompareAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{9}
}
func (m *ActionCompareAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionCompareAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionCompareAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionCompareAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionCompareAck.Merge(dst, src)
}
func (m *ActionCompareAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionCompareAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionCompareAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionCompareAck proto.InternalMessageInfo

func (m *ActionCompareAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionCompareAck) GetOpponent() int32 {
	if m != nil {
		return m.Opponent
	}
	return 0
}

func (m *ActionCompareAck) GetWin() bool {
	if m != nil {
		return m.Win
	}
	return false
}

// 下注(跟注+加注)
type ActionBetReq struct {
	Coin int64 `protobuf:"varint,1,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
}

func (m *ActionBetReq) Reset()         { *m = ActionBetReq{} }
func (m *ActionBetReq) String() string { return proto.CompactTextString(m) }
func (*ActionBetReq) ProtoMessage()    {}
func (*ActionBetReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{10}
}
func (m *ActionBetReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionBetReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionBetReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionBetReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionBetReq.Merge(dst, src)
}
func (m *ActionBetReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionBetReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionBetReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionBetReq proto.InternalMessageInfo

func (m *ActionBetReq) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

type ActionBetAck struct {
	Uid  int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	Coin int64 `protobuf:"varint,2,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
}

func (m *ActionBetAck) Reset()         { *m = ActionBetAck{} }
func (m *ActionBetAck) String() string { return proto.CompactTextString(m) }
func (*ActionBetAck) ProtoMessage()    {}
func (*ActionBetAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{11}
}
func (m *ActionBetAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionBetAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionBetAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionBetAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionBetAck.Merge(dst, src)
}
func (m *ActionBetAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionBetAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionBetAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionBetAck proto.InternalMessageInfo

func (m *ActionBetAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionBetAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

// 全压
type ActionAllinReq struct {
	Coin int64 `protobuf:"varint,1,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
}

func (m *ActionAllinReq) Reset()         { *m = ActionAllinReq{} }
func (m *ActionAllinReq) String() string { return proto.CompactTextString(m) }
func (*ActionAllinReq) ProtoMessage()    {}
func (*ActionAllinReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{12}
}
func (m *ActionAllinReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionAllinReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionAllinReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionAllinReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionAllinReq.Merge(dst, src)
}
func (m *ActionAllinReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionAllinReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionAllinReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionAllinReq proto.InternalMessageInfo

func (m *ActionAllinReq) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

type ActionAllinAck struct {
	Uid  int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	Coin int64 `protobuf:"varint,2,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
}

func (m *ActionAllinAck) Reset()         { *m = ActionAllinAck{} }
func (m *ActionAllinAck) String() string { return proto.CompactTextString(m) }
func (*ActionAllinAck) ProtoMessage()    {}
func (*ActionAllinAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{13}
}
func (m *ActionAllinAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionAllinAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionAllinAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionAllinAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionAllinAck.Merge(dst, src)
}
func (m *ActionAllinAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionAllinAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionAllinAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionAllinAck proto.InternalMessageInfo

func (m *ActionAllinAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionAllinAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

// 离开
type ActionLeaveReq struct {
	// 玩家ID
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
}

func (m *ActionLeaveReq) Reset()         { *m = ActionLeaveReq{} }
func (m *ActionLeaveReq) String() string { return proto.CompactTextString(m) }
func (*ActionLeaveReq) ProtoMessage()    {}
func (*ActionLeaveReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{14}
}
func (m *ActionLeaveReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLeaveReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLeaveReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLeaveReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLeaveReq.Merge(dst, src)
}
func (m *ActionLeaveReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionLeaveReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLeaveReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLeaveReq proto.InternalMessageInfo

func (m *ActionLeaveReq) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type ActionLeaveAck struct {
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
}

func (m *ActionLeaveAck) Reset()         { *m = ActionLeaveAck{} }
func (m *ActionLeaveAck) String() string { return proto.CompactTextString(m) }
func (*ActionLeaveAck) ProtoMessage()    {}
func (*ActionLeaveAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{15}
}
func (m *ActionLeaveAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLeaveAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLeaveAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLeaveAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLeaveAck.Merge(dst, src)
}
func (m *ActionLeaveAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionLeaveAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLeaveAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLeaveAck proto.InternalMessageInfo

func (m *ActionLeaveAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type ActionLog struct {
	// 时间
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"s" bson:"s" msg:"s"`
	// 玩家ID
	Uid int32 `protobuf:"varint,2,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	// 动作类型
	Type ActionLog_Type `protobuf:"varint,3,opt,name=type,proto3,enum=zjh.ActionLog_Type" json:"t" bson:"t" msg:"t"`
	// 金币
	Coin int64 `protobuf:"varint,4,opt,name=coin,proto3" json:"c,omitempty" bson:"c,omitempty" msg:"c,omitempty"`
	// 对手ID
	Opponent int32 `protobuf:"varint,5,opt,name=opponent,proto3" json:"o,omitempty" bson:"o,omitempty" msg:"o,omitempty"`
}

func (m *ActionLog) Reset()         { *m = ActionLog{} }
func (m *ActionLog) String() string { return proto.CompactTextString(m) }
func (*ActionLog) ProtoMessage()    {}
func (*ActionLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{16}
}
func (m *ActionLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ActionLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLog.Merge(dst, src)
}
func (m *ActionLog) XXX_Size() int {
	return m.Size()
}
func (m *ActionLog) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLog.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLog proto.InternalMessageInfo

func (m *ActionLog) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ActionLog) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionLog) GetType() ActionLog_Type {
	if m != nil {
		return m.Type
	}
	return ActionLog_None
}

func (m *ActionLog) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *ActionLog) GetOpponent() int32 {
	if m != nil {
		return m.Opponent
	}
	return 0
}

type GameInitAck struct {
	// 当前游戏ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	// 当前游戏状态
	State int32 `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty" bson:"state" msg:"state"`
	// 第几轮
	Ring int32 `protobuf:"varint,3,opt,name=ring,proto3" json:"ring,omitempty" bson:"ring" msg:"ring"`
	// 第一个出牌的人
	First int32 `protobuf:"varint,4,opt,name=first,proto3" json:"first,omitempty" bson:"first" msg:"first"`
	// 玩家(第1个位置为先)
	Player []*Player `protobuf:"bytes,5,rep,name=player,proto3" json:"player,omitempty" bson:"play" msg:"play"`
	// 我的牌,如果已看牌
	Poker []byte `protobuf:"bytes,6,opt,name=poker,proto3" json:"p,omitempty" bson:"p,omitempty" msg:"p,omitempty"`
}

func (m *GameInitAck) Reset()         { *m = GameInitAck{} }
func (m *GameInitAck) String() string { return proto.CompactTextString(m) }
func (*GameInitAck) ProtoMessage()    {}
func (*GameInitAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{17}
}
func (m *GameInitAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInitAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInitAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameInitAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInitAck.Merge(dst, src)
}
func (m *GameInitAck) XXX_Size() int {
	return m.Size()
}
func (m *GameInitAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInitAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameInitAck proto.InternalMessageInfo

func (m *GameInitAck) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameInitAck) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *GameInitAck) GetRing() int32 {
	if m != nil {
		return m.Ring
	}
	return 0
}

func (m *GameInitAck) GetFirst() int32 {
	if m != nil {
		return m.First
	}
	return 0
}

func (m *GameInitAck) GetPlayer() []*Player {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *GameInitAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

// 游戏开始
type GameStartAck struct {
	// 当前游戏ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	// 玩家(第1个位置为先)
	Player []*Player `protobuf:"bytes,2,rep,name=player,proto3" json:"player,omitempty" bson:"play" msg:"play"`
}

func (m *GameStartAck) Reset()         { *m = GameStartAck{} }
func (m *GameStartAck) String() string { return proto.CompactTextString(m) }
func (*GameStartAck) ProtoMessage()    {}
func (*GameStartAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{18}
}
func (m *GameStartAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameStartAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameStartAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameStartAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameStartAck.Merge(dst, src)
}
func (m *GameStartAck) XXX_Size() int {
	return m.Size()
}
func (m *GameStartAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameStartAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameStartAck proto.InternalMessageInfo

func (m *GameStartAck) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameStartAck) GetPlayer() []*Player {
	if m != nil {
		return m.Player
	}
	return nil
}

// 游戏结束
type GameEndAck struct {
	// 当前游戏ID
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" bson:"id" msg:"id"`
	// 赢钱数
	Win int64 `protobuf:"varint,2,opt,name=win,proto3" json:"win,omitempty" bson:"win" msg:"win"`
	// 赢家
	Winner int32 `protobuf:"varint,3,opt,name=winner,proto3" json:"winner,omitempty" bson:"winner" msg:"winner"`
	// 我的金币数
	Coin int64 `protobuf:"varint,4,opt,name=coin,proto3" json:"coin,omitempty" bson:"coin" msg:"coin"`
	// 所有牌,不能看的为0
	Poker []byte `protobuf:"bytes,5,opt,name=poker,proto3" json:"poker" bson:"poker" msg:"poker"`
	// 喜钱，从彩池单独出
	Lucky int64 `protobuf:"varint,6,opt,name=lucky,proto3" json:"lucky,omitempty" bson:"lucky,omitempty" msg:"lucky,omitempty"`
}

func (m *GameEndAck) Reset()         { *m = GameEndAck{} }
func (m *GameEndAck) String() string { return proto.CompactTextString(m) }
func (*GameEndAck) ProtoMessage()    {}
func (*GameEndAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_zjh_c60e07f1ef6727e0, []int{19}
}
func (m *GameEndAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameEndAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameEndAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *GameEndAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameEndAck.Merge(dst, src)
}
func (m *GameEndAck) XXX_Size() int {
	return m.Size()
}
func (m *GameEndAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameEndAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameEndAck proto.InternalMessageInfo

func (m *GameEndAck) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameEndAck) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameEndAck) GetWinner() int32 {
	if m != nil {
		return m.Winner
	}
	return 0
}

func (m *GameEndAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *GameEndAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameEndAck) GetLucky() int64 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func init() {
	proto.RegisterType((*Zjh)(nil), "zjh.Zjh")
	proto.RegisterType((*Player)(nil), "zjh.Player")
	proto.RegisterType((*GameBill)(nil), "zjh.GameBill")
	proto.RegisterType((*GameRound)(nil), "zjh.GameRound")
	proto.RegisterType((*ActionLookReq)(nil), "zjh.ActionLookReq")
	proto.RegisterType((*ActionLookAck)(nil), "zjh.ActionLookAck")
	proto.RegisterType((*ActionDiscardReq)(nil), "zjh.ActionDiscardReq")
	proto.RegisterType((*ActionDiscardAck)(nil), "zjh.ActionDiscardAck")
	proto.RegisterType((*ActionCompareReq)(nil), "zjh.ActionCompareReq")
	proto.RegisterType((*ActionCompareAck)(nil), "zjh.ActionCompareAck")
	proto.RegisterType((*ActionBetReq)(nil), "zjh.ActionBetReq")
	proto.RegisterType((*ActionBetAck)(nil), "zjh.ActionBetAck")
	proto.RegisterType((*ActionAllinReq)(nil), "zjh.ActionAllinReq")
	proto.RegisterType((*ActionAllinAck)(nil), "zjh.ActionAllinAck")
	proto.RegisterType((*ActionLeaveReq)(nil), "zjh.ActionLeaveReq")
	proto.RegisterType((*ActionLeaveAck)(nil), "zjh.ActionLeaveAck")
	proto.RegisterType((*ActionLog)(nil), "zjh.ActionLog")
	proto.RegisterType((*GameInitAck)(nil), "zjh.GameInitAck")
	proto.RegisterType((*GameStartAck)(nil), "zjh.GameStartAck")
	proto.RegisterType((*GameEndAck)(nil), "zjh.GameEndAck")
	proto.RegisterEnum("zjh.Zjh_Code", Zjh_Code_name, Zjh_Code_value)
	proto.RegisterEnum("zjh.Player_State", Player_State_name, Player_State_value)
	proto.RegisterEnum("zjh.ActionLog_Type", ActionLog_Type_name, ActionLog_Type_value)
}
func (m *Zjh) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Zjh) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Icon != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Icon))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Vip))
	}
	if m.Chair != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Chair))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.State != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.State))
	}
	if m.Look {
		dAtA[i] = 0x48
		i++
		if m.Look {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Down != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint32(m.Down)<<1)^uint32((m.Down>>31))))
	}
	return i, nil
}

func (m *GameBill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameBill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Job != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Job))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	if m.Win != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint64(m.Win)<<1)^uint64((m.Win>>63))))
	}
	if m.Tax != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tax))
	}
	if m.WinRobot != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint64(m.WinRobot)<<1)^uint64((m.WinRobot>>63))))
	}
	return i, nil
}

func (m *GameRound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameRound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Start != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.End))
	}
	if m.Room != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Room))
	}
	if m.Tab != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tab))
	}
	if len(m.Bill) > 0 {
		for _, msg := range m.Bill {
			dAtA[i] = 0x32
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ring != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Ring))
	}
	if m.Sum != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Sum))
	}
	if m.Win != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint64(m.Win)<<1)^uint64((m.Win>>63))))
	}
	if m.Tax != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tax))
	}
	if m.Pool != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Pool))
	}
	if m.Lucky != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Lucky))
	}
	if len(m.Note) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Note)))
		i += copy(dAtA[i:], m.Note)
	}
	return i, nil
}

func (m *ActionLookReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLookReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *ActionLookAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLookAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Poker) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	return i, nil
}

func (m *ActionDiscardReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDiscardReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *ActionDiscardAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionDiscardAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *ActionCompareReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionCompareReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Opponent != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Opponent))
	}
	return i, nil
}

func (m *ActionCompareAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionCompareAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Opponent != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Opponent))
	}
	if m.Win {
		dAtA[i] = 0x18
		i++
		if m.Win {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ActionBetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionBetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Coin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ActionBetAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionBetAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ActionAllinReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionAllinReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Coin != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ActionAllinAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionAllinAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *ActionLeaveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLeaveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *ActionLeaveAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLeaveAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *ActionLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Start))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Type))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if m.Opponent != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Opponent))
	}
	return i, nil
}

func (m *GameInitAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInitAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.State))
	}
	if m.Ring != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Ring))
	}
	if m.First != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.First))
	}
	if len(m.Player) > 0 {
		for _, msg := range m.Player {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	return i, nil
}

func (m *GameStartAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameStartAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if len(m.Player) > 0 {
		for _, msg := range m.Player {
			dAtA[i] = 0x12
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GameEndAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameEndAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Win != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Win))
	}
	if m.Winner != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Winner))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	if m.Lucky != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Lucky))
	}
	return i, nil
}

func encodeVarintZjh(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Zjh) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Icon != 0 {
		n += 1 + sovZjh(uint64(m.Icon))
	}
	if m.Vip != 0 {
		n += 1 + sovZjh(uint64(m.Vip))
	}
	if m.Chair != 0 {
		n += 1 + sovZjh(uint64(m.Chair))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovZjh(uint64(m.State))
	}
	if m.Look {
		n += 2
	}
	if m.Down != 0 {
		n += 1 + sozZjh(uint64(m.Down))
	}
	return n
}

func (m *GameBill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Job != 0 {
		n += 1 + sovZjh(uint64(m.Job))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Win != 0 {
		n += 1 + sozZjh(uint64(m.Win))
	}
	if m.Tax != 0 {
		n += 1 + sovZjh(uint64(m.Tax))
	}
	if m.WinRobot != 0 {
		n += 1 + sozZjh(uint64(m.WinRobot))
	}
	return n
}

func (m *GameRound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Start != 0 {
		n += 1 + sovZjh(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovZjh(uint64(m.End))
	}
	if m.Room != 0 {
		n += 1 + sovZjh(uint64(m.Room))
	}
	if m.Tab != 0 {
		n += 1 + sovZjh(uint64(m.Tab))
	}
	if len(m.Bill) > 0 {
		for _, e := range m.Bill {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	if m.Ring != 0 {
		n += 1 + sovZjh(uint64(m.Ring))
	}
	if m.Sum != 0 {
		n += 1 + sovZjh(uint64(m.Sum))
	}
	if m.Win != 0 {
		n += 1 + sozZjh(uint64(m.Win))
	}
	if m.Tax != 0 {
		n += 1 + sovZjh(uint64(m.Tax))
	}
	if m.Pool != 0 {
		n += 1 + sovZjh(uint64(m.Pool))
	}
	if m.Lucky != 0 {
		n += 1 + sovZjh(uint64(m.Lucky))
	}
	l = len(m.Note)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *ActionLookReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	return n
}

func (m *ActionLookAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *ActionDiscardReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	return n
}

func (m *ActionDiscardAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	return n
}

func (m *ActionCompareReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Opponent != 0 {
		n += 1 + sovZjh(uint64(m.Opponent))
	}
	return n
}

func (m *ActionCompareAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Opponent != 0 {
		n += 1 + sovZjh(uint64(m.Opponent))
	}
	if m.Win {
		n += 2
	}
	return n
}

func (m *ActionBetReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *ActionBetAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *ActionAllinReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *ActionAllinAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *ActionLeaveReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	return n
}

func (m *ActionLeaveAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	return n
}

func (m *ActionLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovZjh(uint64(m.Start))
	}
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Type != 0 {
		n += 1 + sovZjh(uint64(m.Type))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	if m.Opponent != 0 {
		n += 1 + sovZjh(uint64(m.Opponent))
	}
	return n
}

func (m *GameInitAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.State != 0 {
		n += 1 + sovZjh(uint64(m.State))
	}
	if m.Ring != 0 {
		n += 1 + sovZjh(uint64(m.Ring))
	}
	if m.First != 0 {
		n += 1 + sovZjh(uint64(m.First))
	}
	if len(m.Player) > 0 {
		for _, e := range m.Player {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *GameStartAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if len(m.Player) > 0 {
		for _, e := range m.Player {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	return n
}

func (m *GameEndAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Win != 0 {
		n += 1 + sovZjh(uint64(m.Win))
	}
	if m.Winner != 0 {
		n += 1 + sovZjh(uint64(m.Winner))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Lucky != 0 {
		n += 1 + sovZjh(uint64(m.Lucky))
	}
	return n
}

func sovZjh(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozZjh(x uint64) (n int) {
	return sovZjh(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Zjh) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Zjh: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Zjh: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			m.Icon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icon |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chair", wireType)
			}
			m.Chair = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chair |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (Player_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Look", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Look = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Down = v
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameBill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameBill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameBill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Win = int64(v)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			m.Tax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinRobot", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.WinRobot = int64(v)
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameRound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameRound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameRound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			m.Room = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Room |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tab", wireType)
			}
			m.Tab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tab |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bill = append(m.Bill, &GameBill{})
			if err := m.Bill[len(m.Bill)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			m.Ring = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ring |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Win = int64(v)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			m.Tax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLookReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLookReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLookReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLookAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLookAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLookAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDiscardReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDiscardReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDiscardReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionDiscardAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionDiscardAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionDiscardAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionCompareReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionCompareReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionCompareReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opponent", wireType)
			}
			m.Opponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opponent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionCompareAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionCompareAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionCompareAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opponent", wireType)
			}
			m.Opponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opponent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Win = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionBetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionBetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionBetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionBetAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionBetAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionBetAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionAllinReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionAllinReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionAllinReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionAllinAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionAllinAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionAllinAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLeaveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLeaveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLeaveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLeaveAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLeaveAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLeaveAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ActionLog_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opponent", wireType)
			}
			m.Opponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opponent |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInitAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInitAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInitAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			m.Ring = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ring |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field First", wireType)
			}
			m.First = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.First |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Player = append(m.Player, &Player{})
			if err := m.Player[len(m.Player)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameStartAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameStartAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameStartAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Player = append(m.Player, &Player{})
			if err := m.Player[len(m.Player)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameEndAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameEndAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameEndAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			m.Win = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Win |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Winner", wireType)
			}
			m.Winner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Winner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipZjh(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthZjh
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipZjh(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthZjh = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowZjh   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("zjh.proto", fileDescriptor_zjh_c60e07f1ef6727e0) }

var fileDescriptor_zjh_c60e07f1ef6727e0 = []byte{
	// 1491 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x98, 0x5b, 0x6f, 0x1b, 0x45,
	0x14, 0xc7, 0xb3, 0xbb, 0xb6, 0xe3, 0x4c, 0xd2, 0x76, 0x3b, 0x85, 0x6a, 0xa9, 0x20, 0xb6, 0x56,
	0x80, 0x42, 0x2f, 0x89, 0x14, 0x24, 0x90, 0xa0, 0x55, 0x9d, 0x94, 0x0a, 0x55, 0x94, 0x8b, 0x36,
	0x48, 0x88, 0x22, 0x1e, 0xec, 0xf5, 0xd6, 0x99, 0xc4, 0x9e, 0x59, 0xd6, 0xe3, 0x6c, 0xd2, 0x4f,
	0x80, 0x78, 0xe2, 0x3b, 0xc1, 0x43, 0x1f, 0x40, 0xea, 0x23, 0x0f, 0x60, 0xaa, 0xf6, 0x2d, 0xe2,
	0x6a, 0x6e, 0x42, 0xf0, 0x80, 0xce, 0x99, 0x59, 0xef, 0xae, 0xd7, 0x8a, 0xe2, 0x2a, 0x12, 0x6f,
	0xe3, 0xb3, 0xbf, 0x39, 0x73, 0x66, 0xe6, 0x3f, 0x33, 0xe7, 0x98, 0x2c, 0xdc, 0xdb, 0xd9, 0x5e,
	0x0d, 0x23, 0x21, 0x05, 0xb5, 0xee, 0xed, 0x6c, 0x5f, 0xb8, 0xd2, 0x61, 0x72, 0x7b, 0xd0, 0x5a,
	0xf5, 0x45, 0x6f, 0xad, 0x23, 0x3a, 0x62, 0x0d, 0xbf, 0xb5, 0x06, 0x77, 0xf1, 0x17, 0xfe, 0xc0,
	0x96, 0xea, 0xe3, 0x7e, 0x65, 0x12, 0xeb, 0xce, 0xce, 0xb6, 0xfb, 0xa5, 0x49, 0x4a, 0x37, 0x44,
	0x3b, 0xa0, 0x55, 0x52, 0x7a, 0x47, 0xf0, 0xc0, 0x9e, 0xa3, 0x94, 0x9c, 0xda, 0xf0, 0x25, 0x13,
	0xfc, 0xb6, 0x10, 0xbb, 0x5e, 0xf0, 0x89, 0xfd, 0x43, 0x23, 0x6f, 0xdb, 0xf0, 0x77, 0xed, 0x1f,
	0x1b, 0xf4, 0x69, 0x62, 0x2b, 0xdb, 0x1b, 0xac, 0xef, 0x37, 0xa3, 0x36, 0xa0, 0x3f, 0x15, 0xcd,
	0x40, 0xff, 0x9c, 0x31, 0xdf, 0x10, 0xbd, 0xb0, 0x19, 0x05, 0x40, 0xff, 0x52, 0x34, 0x03, 0xfd,
	0x6b, 0x83, 0x9e, 0x25, 0x4b, 0xca, 0xbc, 0x19, 0x48, 0x20, 0x47, 0x79, 0x13, 0x50, 0xbf, 0x35,
	0xe8, 0x39, 0x72, 0x5a, 0x99, 0x36, 0xba, 0x5d, 0xc6, 0x81, 0xfb, 0x7d, 0xd2, 0x08, 0xe4, 0x1f,
	0x19, 0xe3, 0xed, 0xa0, 0xb9, 0x87, 0x63, 0xff, 0x39, 0x69, 0x04, 0xf2, 0xaf, 0x06, 0xb5, 0xc9,
	0xe2, 0x9b, 0xcd, 0x5e, 0x70, 0x8b, 0x33, 0x1c, 0xe5, 0x6f, 0x1c, 0x18, 0x2c, 0x5b, 0xb2, 0x19,
	0xa1, 0xe9, 0x9f, 0x06, 0x3d, 0x43, 0x08, 0x98, 0x6e, 0x72, 0x9c, 0xdd, 0xbf, 0x0d, 0xf7, 0x7e,
	0x89, 0x54, 0xde, 0xeb, 0x36, 0x0f, 0x82, 0x88, 0xbe, 0x48, 0x4c, 0xd6, 0x76, 0x8c, 0xba, 0xb1,
	0x52, 0xde, 0x3c, 0x3f, 0x1a, 0xd6, 0x68, 0xab, 0x2f, 0xf8, 0x6b, 0x2e, 0x6b, 0xbb, 0xf5, 0x5e,
	0xbf, 0x83, 0x0d, 0xcf, 0x64, 0x6d, 0xba, 0x4a, 0x4a, 0xcc, 0x17, 0xdc, 0x31, 0x91, 0xbc, 0x30,
	0x1a, 0xd6, 0xce, 0x6b, 0xd2, 0x17, 0x3c, 0x61, 0xa1, 0xe9, 0x21, 0x47, 0x2f, 0x12, 0x6b, 0x8f,
	0x85, 0x8e, 0x85, 0xb8, 0x33, 0x1a, 0xd6, 0x9e, 0x52, 0xf8, 0x1e, 0x0b, 0x35, 0x0d, 0x2d, 0x0f,
	0x20, 0xba, 0x4e, 0xca, 0xfe, 0x76, 0x93, 0x45, 0x4e, 0x09, 0xe9, 0x67, 0x47, 0xc3, 0x9a, 0xa3,
	0x68, 0x34, 0x6b, 0x5e, 0xb5, 0x3d, 0x85, 0x42, 0x3c, 0xbe, 0x60, 0xdc, 0x29, 0xd7, 0x8d, 0x15,
	0x2b, 0x1b, 0x0f, 0x58, 0x93, 0x1e, 0xd0, 0xf4, 0x90, 0x83, 0x78, 0x5a, 0x81, 0x74, 0x2a, 0x88,
	0x67, 0xe2, 0x69, 0x05, 0x52, 0xd3, 0xd0, 0xf2, 0x00, 0x02, 0xdf, 0xbc, 0xd9, 0x0b, 0x9c, 0xf9,
	0xba, 0xb1, 0xb2, 0x90, 0xf5, 0x0d, 0x56, 0x4d, 0x63, 0xd3, 0x43, 0x8e, 0xde, 0x24, 0xe5, 0xbe,
	0x6c, 0xca, 0xc0, 0xa9, 0xd6, 0x8d, 0x95, 0xd3, 0xeb, 0x67, 0x57, 0x41, 0xec, 0x6a, 0x7d, 0x57,
	0xb7, 0xe0, 0x43, 0x76, 0x4a, 0x48, 0x6a, 0x27, 0xaa, 0xed, 0xa9, 0xde, 0x30, 0x6c, 0x57, 0x88,
	0x5d, 0x67, 0xa1, 0x6e, 0xac, 0x54, 0xb3, 0xc3, 0x82, 0x55, 0xf7, 0xc0, 0xa6, 0x87, 0x1c, 0xf0,
	0x6d, 0x11, 0x73, 0x87, 0xd4, 0x8d, 0x95, 0xb3, 0x59, 0x1e, 0xac, 0x9a, 0xc7, 0xa6, 0x87, 0x9c,
	0xbb, 0x45, 0xca, 0x18, 0x4d, 0xe6, 0xf0, 0x54, 0x49, 0xc9, 0x0b, 0x9a, 0x6d, 0xdb, 0xa0, 0x8b,
	0x64, 0x1e, 0x22, 0x66, 0xbc, 0x63, 0x9b, 0xf0, 0x43, 0x1f, 0x07, 0xdb, 0x02, 0xe6, 0xb6, 0xe8,
	0x4b, 0xbb, 0x44, 0xe7, 0x89, 0xf5, 0x01, 0xe3, 0x76, 0x99, 0x2e, 0x90, 0x32, 0x8a, 0xd0, 0xae,
	0xb8, 0xdf, 0x5a, 0xa4, 0x0a, 0xe2, 0xda, 0x64, 0xdd, 0x2e, 0xbd, 0x44, 0xac, 0xc1, 0x58, 0x4d,
	0xcf, 0x1c, 0x0e, 0x6b, 0xc6, 0x60, 0x34, 0xac, 0xd9, 0x2a, 0xaa, 0x81, 0x0e, 0x69, 0xe0, 0x7a,
	0x40, 0xd1, 0x5b, 0xc4, 0xda, 0x11, 0x2d, 0x2d, 0xa8, 0x57, 0x0f, 0x87, 0xb5, 0xc5, 0x9d, 0xcb,
	0xa2, 0xc7, 0x64, 0xd0, 0x0b, 0xe5, 0xc1, 0x68, 0x58, 0x7b, 0x5e, 0x75, 0xcb, 0x18, 0xb5, 0x83,
	0xac, 0xc5, 0x03, 0x1f, 0xf4, 0x8a, 0x16, 0x83, 0x85, 0xbb, 0x8b, 0x03, 0xfb, 0xe9, 0xc0, 0x7e,
	0x22, 0x87, 0x44, 0x0b, 0x97, 0x94, 0x16, 0x4a, 0x29, 0xdd, 0x4a, 0xe9, 0x56, 0x22, 0x07, 0x2d,
	0x86, 0x35, 0x52, 0x0e, 0xc5, 0x6e, 0x10, 0xa1, 0xd2, 0x96, 0x14, 0x1e, 0xa6, 0x78, 0xa2, 0xe6,
	0xd0, 0xf5, 0x14, 0x07, 0xde, 0x63, 0xc6, 0x51, 0x69, 0x54, 0xe1, 0x71, 0x8a, 0xc7, 0x1a, 0x8f,
	0x5d, 0x0f, 0x28, 0x58, 0x04, 0xd9, 0xdc, 0x47, 0xa5, 0x59, 0x6a, 0x11, 0xf6, 0xa7, 0x2d, 0xc2,
	0x7e, 0x61, 0x11, 0xf6, 0x73, 0x8b, 0x20, 0x9b, 0xfb, 0x74, 0x8b, 0x54, 0x63, 0xc6, 0x3d, 0xd1,
	0x12, 0x12, 0x85, 0x48, 0x95, 0x3f, 0x39, 0xcd, 0x9f, 0x2c, 0xf8, 0xcb, 0x5a, 0xbc, 0xb1, 0x23,
	0xf7, 0xeb, 0x32, 0x59, 0x80, 0xed, 0xf5, 0xc4, 0x80, 0xb7, 0xe9, 0x4b, 0xe3, 0xcb, 0x42, 0xaf,
	0x1b, 0x4b, 0x67, 0xc6, 0x92, 0x4b, 0x40, 0xdd, 0x17, 0x6b, 0x78, 0x26, 0x22, 0x89, 0xfb, 0xab,
	0xe9, 0x7e, 0x4a, 0xf7, 0x93, 0x13, 0xa0, 0xd4, 0x1f, 0x49, 0x58, 0xb6, 0x80, 0xb7, 0xb3, 0x5b,
	0x18, 0xa4, 0x78, 0x72, 0x60, 0x02, 0xd7, 0x03, 0x0a, 0x36, 0x3c, 0x12, 0xa2, 0xa7, 0x2f, 0x0c,
	0xa4, 0xa3, 0x94, 0x4e, 0x6e, 0x8c, 0xc8, 0xf5, 0x10, 0x03, 0xdf, 0xb2, 0xd9, 0xc2, 0x1d, 0xd4,
	0xb4, 0x4c, 0xe9, 0xe4, 0xfc, 0x4b, 0x5c, 0xc7, 0x16, 0xbd, 0x4a, 0x4a, 0x2d, 0xd6, 0xed, 0x3a,
	0x95, 0xba, 0xb5, 0xb2, 0xb8, 0x7e, 0x0a, 0x0f, 0x73, 0xa2, 0xf0, 0xa3, 0xd4, 0x82, 0xbd, 0x30,
	0x32, 0xc6, 0x3b, 0xb8, 0xa3, 0x7a, 0xac, 0x4e, 0x8a, 0x77, 0x34, 0xde, 0x81, 0xc8, 0x18, 0xef,
	0x40, 0x64, 0xfd, 0x41, 0x0f, 0xf7, 0x4b, 0xcf, 0xba, 0x97, 0xd2, 0x3d, 0x4d, 0xf7, 0x5c, 0x0f,
	0xa8, 0x44, 0x59, 0x0b, 0xc7, 0x52, 0xd6, 0x25, 0xa5, 0x2c, 0x92, 0x7a, 0xde, 0x4f, 0xe1, 0xfd,
	0x44, 0x45, 0x5a, 0x3b, 0x6f, 0x91, 0x52, 0x28, 0x44, 0xd7, 0x59, 0x4c, 0x75, 0x28, 0xa6, 0xe9,
	0x46, 0x14, 0x74, 0x93, 0xb5, 0x78, 0xe8, 0x84, 0xbe, 0x4d, 0xca, 0xdd, 0x81, 0xbf, 0x7b, 0xe0,
	0x2c, 0xa5, 0xde, 0xba, 0xd3, 0xbc, 0x75, 0x0b, 0xde, 0xb2, 0x16, 0x4f, 0x79, 0x81, 0xd8, 0xb8,
	0x90, 0x81, 0x73, 0x0a, 0x6f, 0x63, 0xf4, 0xc6, 0xa7, 0x79, 0xe3, 0x05, 0x6f, 0x3c, 0x17, 0x1b,
	0x38, 0x71, 0xaf, 0x4e, 0x64, 0x0b, 0x33, 0x5d, 0x59, 0x6e, 0x63, 0x22, 0xaf, 0x48, 0x2f, 0x07,
	0xe3, 0x78, 0x97, 0x83, 0x7b, 0xbd, 0x98, 0x85, 0xcc, 0x16, 0xc2, 0xf5, 0x62, 0xbe, 0x32, 0x9b,
	0x83, 0x4e, 0x31, 0xb3, 0x81, 0xab, 0x43, 0x84, 0xa1, 0xe0, 0x01, 0x97, 0xda, 0xcb, 0x13, 0x4b,
	0x60, 0xec, 0xc8, 0xfd, 0xde, 0x28, 0x26, 0x4b, 0xb3, 0xbd, 0x10, 0xd9, 0xb0, 0xcc, 0x13, 0x0a,
	0x0b, 0x6e, 0xdc, 0x58, 0x3f, 0x15, 0x55, 0xe5, 0x2f, 0x9e, 0xe6, 0x2f, 0x2e, 0xf8, 0x8b, 0x73,
	0x37, 0x6e, 0xcc, 0xb8, 0xfb, 0x51, 0x3e, 0xed, 0x03, 0xa5, 0xe2, 0x33, 0x64, 0xa4, 0xba, 0xf7,
	0xa7, 0xf9, 0xf6, 0x0b, 0xbe, 0xfd, 0x9c, 0x52, 0x31, 0x6f, 0xf9, 0xd4, 0xc8, 0x67, 0x90, 0xb3,
	0x2d, 0x5d, 0x12, 0x8a, 0x79, 0x12, 0xa1, 0x7c, 0x3c, 0x99, 0xb8, 0x9e, 0xec, 0x4c, 0x3f, 0x33,
	0x26, 0x73, 0xe0, 0xff, 0x71, 0xae, 0xd7, 0x26, 0x53, 0xef, 0xd9, 0x4e, 0xd7, 0xb5, 0xc9, 0x24,
	0x7d, 0xb6, 0xee, 0x5f, 0x58, 0x64, 0x21, 0xb9, 0x61, 0x3a, 0xe9, 0x1b, 0x6a, 0x1c, 0xff, 0x0d,
	0x85, 0xb1, 0xcc, 0x63, 0x2d, 0xdb, 0x26, 0x29, 0xc9, 0x83, 0x30, 0xc0, 0x93, 0x70, 0x7a, 0xfd,
	0x1c, 0xbe, 0x73, 0xe3, 0xb1, 0x57, 0xdf, 0x3f, 0x08, 0x83, 0xa3, 0x9e, 0x4a, 0xec, 0x3b, 0x5e,
	0xfa, 0xd2, 0x09, 0x2c, 0x7d, 0xee, 0xb8, 0x97, 0x4f, 0xea, 0x16, 0x8a, 0x48, 0x09, 0xa6, 0x92,
	0xcf, 0x79, 0xe1, 0xfa, 0x56, 0x39, 0x6f, 0x92, 0xe6, 0x9a, 0x74, 0x89, 0x54, 0xdf, 0xdd, 0x0b,
	0x22, 0xc9, 0x7a, 0x81, 0x6d, 0xc1, 0x27, 0x7d, 0x6b, 0xa9, 0xbc, 0x77, 0x33, 0x90, 0x2a, 0xef,
	0x45, 0x89, 0xda, 0x15, 0x7a, 0x86, 0x2c, 0x6e, 0x0c, 0xa4, 0x48, 0xa0, 0xf9, 0x34, 0x27, 0xae,
	0xba, 0xdf, 0x99, 0xb9, 0xaa, 0x2c, 0x53, 0x63, 0x59, 0x47, 0xd6, 0x58, 0xeb, 0x49, 0x1d, 0x61,
	0x4e, 0xd6, 0x41, 0x47, 0x16, 0x0d, 0x98, 0x6f, 0x58, 0x93, 0x75, 0x19, 0x58, 0x93, 0x3c, 0x08,
	0x9a, 0x3a, 0xe1, 0x58, 0x27, 0xe5, 0xbb, 0x2c, 0xea, 0xcb, 0x62, 0xad, 0x85, 0x66, 0xdd, 0x43,
	0xb5, 0x3d, 0x85, 0xd2, 0xeb, 0xa4, 0x12, 0x62, 0x35, 0xe3, 0x94, 0x31, 0x27, 0x5a, 0xcc, 0x14,
	0x38, 0xd9, 0x21, 0x01, 0x4a, 0x5e, 0x3c, 0x68, 0x7a, 0xba, 0x1b, 0x64, 0x04, 0xea, 0x99, 0xac,
	0xe0, 0x33, 0x89, 0xdb, 0x1a, 0x4e, 0xdb, 0xd6, 0xb0, 0xb0, 0xad, 0x61, 0x2e, 0x23, 0x50, 0x8f,
	0x68, 0x9c, 0x2f, 0x71, 0x8f, 0xbd, 0xbe, 0xe9, 0x3c, 0xcc, 0x27, 0x9a, 0x87, 0xfb, 0xd0, 0xcc,
	0x56, 0xd2, 0xc7, 0x1e, 0xf7, 0xa2, 0x7a, 0x72, 0xcc, 0xc9, 0xda, 0x33, 0x1e, 0x57, 0xaa, 0xd0,
	0x52, 0x69, 0xdb, 0x2b, 0xa4, 0x12, 0x33, 0xce, 0x83, 0x48, 0xef, 0xe8, 0xf2, 0x68, 0x58, 0xbb,
	0x30, 0xc6, 0x79, 0x10, 0xa5, 0x3d, 0xe0, 0x87, 0xa7, 0xe9, 0x71, 0x3d, 0x5c, 0x3a, 0x66, 0x3d,
	0xfc, 0x7a, 0xbe, 0xac, 0x79, 0xe1, 0x70, 0x58, 0x53, 0x86, 0x54, 0x10, 0x6a, 0xb1, 0xf5, 0x3a,
	0x60, 0x3b, 0x29, 0x71, 0x3e, 0x4c, 0x32, 0x3c, 0x55, 0x4e, 0xdf, 0x38, 0x1c, 0xd6, 0xce, 0xa0,
	0x21, 0xb7, 0xa7, 0x97, 0x75, 0x96, 0x97, 0xff, 0x90, 0x64, 0x7a, 0x13, 0x56, 0x9d, 0xed, 0x6d,
	0x3e, 0x77, 0xff, 0xd1, 0xb2, 0xf1, 0xe0, 0xd1, 0xb2, 0xf1, 0xf0, 0xd1, 0xb2, 0xf1, 0xf9, 0xe3,
	0xe5, 0xb9, 0x07, 0x8f, 0x97, 0xe7, 0xbe, 0x79, 0xbc, 0x3c, 0x77, 0xc7, 0xba, 0xb7, 0xb3, 0xdd,
	0xaa, 0xe0, 0xff, 0x41, 0x2f, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0x82, 0x50, 0xb0, 0x26, 0x50,
	0x12, 0x00, 0x00,
}
