// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: zjh.proto

package zjh

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Code int32

const (
	// 8300-8399(炸金花)
	Code_CodeNone          Code = 0
	Code_CodeActionReq     Code = 8300
	Code_CodeActionAck     Code = 8301
	Code_CodeGameInitAck   Code = 8303
	Code_CodeGameStartAck  Code = 8305
	Code_CodeGameResultAck Code = 8307
)

var Code_name = map[int32]string{
	0:    "CodeNone",
	8300: "CodeActionReq",
	8301: "CodeActionAck",
	8303: "CodeGameInitAck",
	8305: "CodeGameStartAck",
	8307: "CodeGameResultAck",
}

var Code_value = map[string]int32{
	"CodeNone":          0,
	"CodeActionReq":     8300,
	"CodeActionAck":     8301,
	"CodeGameInitAck":   8303,
	"CodeGameStartAck":  8305,
	"CodeGameResultAck": 8307,
}

func (x Code) String() string {
	return proto.EnumName(Code_name, int32(x))
}

func (Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{0}
}

type ActionType int32

const (
	ActionType_ActionNone ActionType = 0
	// 准备
	ActionType_ActionReady ActionType = 1
	// 看牌
	ActionType_ActionLook ActionType = 2
	// 主动弃牌
	ActionType_ActionDiscard ActionType = 3
	// 超时弃牌
	ActionType_ActionOvertime ActionType = 4
	// 比牌
	ActionType_ActionCompare ActionType = 5
	// 下注(跟注+加注)
	ActionType_ActionAddBet ActionType = 6
	// 全压
	ActionType_ActionAllin ActionType = 7
	// 全压比牌
	ActionType_ActionAllinCompare ActionType = 9
	// 自动比牌
	ActionType_ActionAutoCompare ActionType = 10
	// 换桌玩
	ActionType_ActionRenew ActionType = 11
	// 离开
	ActionType_ActionLeave ActionType = 12
)

var ActionType_name = map[int32]string{
	0:  "ActionNone",
	1:  "ActionReady",
	2:  "ActionLook",
	3:  "ActionDiscard",
	4:  "ActionOvertime",
	5:  "ActionCompare",
	6:  "ActionAddBet",
	7:  "ActionAllin",
	9:  "ActionAllinCompare",
	10: "ActionAutoCompare",
	11: "ActionRenew",
	12: "ActionLeave",
}

var ActionType_value = map[string]int32{
	"ActionNone":         0,
	"ActionReady":        1,
	"ActionLook":         2,
	"ActionDiscard":      3,
	"ActionOvertime":     4,
	"ActionCompare":      5,
	"ActionAddBet":       6,
	"ActionAllin":        7,
	"ActionAllinCompare": 9,
	"ActionAutoCompare":  10,
	"ActionRenew":        11,
	"ActionLeave":        12,
}

func (x ActionType) String() string {
	return proto.EnumName(ActionType_name, int32(x))
}

func (ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{1}
}

type Player_State int32

const (
	// 没有准备
	Player_None Player_State = 0
	// 已准备
	Player_Ready Player_State = 1
	// 游戏中
	Player_Playing Player_State = 2
	// 全押
	Player_Allin Player_State = 3
	// 已弃牌
	Player_Discard Player_State = 4
	// PK失败
	Player_Lose Player_State = 5
	// 赢得最终胜利
	Player_Win Player_State = 6
	// 离开
	Player_Leave Player_State = 7
)

var Player_State_name = map[int32]string{
	0: "None",
	1: "Ready",
	2: "Playing",
	3: "Allin",
	4: "Discard",
	5: "Lose",
	6: "Win",
	7: "Leave",
}

var Player_State_value = map[string]int32{
	"None":    0,
	"Ready":   1,
	"Playing": 2,
	"Allin":   3,
	"Discard": 4,
	"Lose":    5,
	"Win":     6,
	"Leave":   7,
}

func (x Player_State) String() string {
	return proto.EnumName(Player_State_name, int32(x))
}

func (Player_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{0, 0}
}

// 玩家信息
type Player struct {
	// 玩家ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 玩家头像
	Icon int32 `protobuf:"varint,2,opt,name=icon,proto3" json:"icon"`
	// VIP等级
	Vip int32 `protobuf:"varint,3,opt,name=vip,proto3" json:"vip"`
	// 椅子号(从0开始)
	Chair int32 `protobuf:"varint,4,opt,name=chair,proto3" json:"chair"`
	// 玩家带的分
	Coin int64 `protobuf:"varint,5,opt,name=coin,proto3" json:"coin"`
	// 玩家的下注
	Bet int64 `protobuf:"varint,6,opt,name=bet,proto3" json:"bet"`
	// 玩家名称
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name"`
	// 游戏状态
	State Player_State `protobuf:"varint,8,opt,name=state,proto3,enum=zjh.Player_State" json:"state"`
	// 是否已看牌
	Look bool `protobuf:"varint,9,opt,name=look,proto3" json:"look"`
	// 倒计时(等待玩家命令倒计时)
	Down int32 `protobuf:"zigzag32,10,opt,name=down,proto3" json:"down"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{0}
}
func (m *Player) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Player.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return m.Size()
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetIcon() int32 {
	if m != nil {
		return m.Icon
	}
	return 0
}

func (m *Player) GetVip() int32 {
	if m != nil {
		return m.Vip
	}
	return 0
}

func (m *Player) GetChair() int32 {
	if m != nil {
		return m.Chair
	}
	return 0
}

func (m *Player) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *Player) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetState() Player_State {
	if m != nil {
		return m.State
	}
	return Player_None
}

func (m *Player) GetLook() bool {
	if m != nil {
		return m.Look
	}
	return false
}

func (m *Player) GetDown() int32 {
	if m != nil {
		return m.Down
	}
	return 0
}

// 玩家结算信息
type GameBill struct {
	// 玩家ID(u有建立索引，不要更改名称)
	Uid int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"u" bson:"u" msg:"u"`
	// 玩家类型
	Job int32 `protobuf:"varint,2,opt,name=job,proto3" json:"job"`
	// 开始游戏时带的钱
	OldCoin int64 `protobuf:"varint,3,opt,name=oldCoin,proto3" json:"oldCoin"`
	// 投注总额
	Bet int64 `protobuf:"varint,4,opt,name=bet,proto3" json:"bet"`
	// 发牌情况
	Poker []byte `protobuf:"bytes,5,opt,name=poker,proto3" json:"poker"`
	// 牌力
	Weight int32 `protobuf:"varint,6,opt,name=weight,proto3" json:"weight"`
	// 输赢情况
	Win int64 `protobuf:"zigzag64,7,opt,name=win,proto3" json:"win"`
	// 税收
	Tax int64 `protobuf:"varint,8,opt,name=tax,proto3" json:"tax"`
	// 进入彩池的税收
	Water int64 `protobuf:"varint,9,opt,name=water,proto3" json:"water"`
	// 喜钱，从彩池单独出
	Lucky int64 `protobuf:"varint,10,opt,name=lucky,proto3" json:"lucky"`
	// 和机器人之间的输赢
	Robot int64 `protobuf:"zigzag64,11,opt,name=robot,proto3" json:"robot"`
	// PK过的玩家ID
	Pk []int32 `protobuf:"varint,12,rep,packed,name=pk,proto3" json:"pk"`
}

func (m *GameBill) Reset()         { *m = GameBill{} }
func (m *GameBill) String() string { return proto.CompactTextString(m) }
func (*GameBill) ProtoMessage()    {}
func (*GameBill) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{1}
}
func (m *GameBill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameBill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameBill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameBill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameBill.Merge(m, src)
}
func (m *GameBill) XXX_Size() int {
	return m.Size()
}
func (m *GameBill) XXX_DiscardUnknown() {
	xxx_messageInfo_GameBill.DiscardUnknown(m)
}

var xxx_messageInfo_GameBill proto.InternalMessageInfo

func (m *GameBill) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GameBill) GetJob() int32 {
	if m != nil {
		return m.Job
	}
	return 0
}

func (m *GameBill) GetOldCoin() int64 {
	if m != nil {
		return m.OldCoin
	}
	return 0
}

func (m *GameBill) GetBet() int64 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *GameBill) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameBill) GetWeight() int32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *GameBill) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameBill) GetTax() int64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *GameBill) GetWater() int64 {
	if m != nil {
		return m.Water
	}
	return 0
}

func (m *GameBill) GetLucky() int64 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func (m *GameBill) GetRobot() int64 {
	if m != nil {
		return m.Robot
	}
	return 0
}

func (m *GameBill) GetPk() []int32 {
	if m != nil {
		return m.Pk
	}
	return nil
}

// 炸金花日志
type GameRound struct {
	// 全局唯一游戏ID(i有建立索引，不要更改名称)
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"i" bson:"i" msg:"i"`
	// 游戏开始时间(s有建立索引，不要更改名称)
	Start int64 `protobuf:"varint,2,opt,name=start,proto3" json:"s" bson:"s" msg:"s"`
	// 游戏结束时间
	End int64 `protobuf:"varint,3,opt,name=end,proto3" json:"end"`
	// 房间ID
	Room int32 `protobuf:"varint,4,opt,name=room,proto3" json:"room"`
	// 桌子ID
	Tab int32 `protobuf:"varint,5,opt,name=tab,proto3" json:"tab"`
	// 所有玩家结算汇总(b.u有建立索引，不要更改名称)
	Bill []*GameBill `protobuf:"bytes,6,rep,name=bill,proto3" json:"b" bson:"b" msg:"b"`
	// 底注
	Ante int32 `protobuf:"varint,7,opt,name=ante,proto3" json:"ante"`
	// 下注轮数
	Ring int32 `protobuf:"varint,8,opt,name=ring,proto3" json:"ring"`
	// 下注总金币
	Sum int64 `protobuf:"varint,9,opt,name=sum,proto3" json:"sum"`
	// 本局所有真实玩家的输赢
	Win int64 `protobuf:"zigzag64,10,opt,name=win,proto3" json:"win"`
	// 真实玩家总税收
	Tax int64 `protobuf:"varint,11,opt,name=tax,proto3" json:"tax"`
	// 真实玩家进入彩池的税收
	Water int64 `protobuf:"varint,12,opt,name=water,proto3" json:"water"`
	// 动作日志
	Log []*ActionLog `protobuf:"bytes,13,rep,name=log,proto3" json:"log"`
	// 当前池子的钱
	Pool int64 `protobuf:"varint,14,opt,name=pool,proto3" json:"pool"`
	// 真实玩家获得的喜钱，从彩池单独出
	Lucky int64 `protobuf:"varint,15,opt,name=lucky,proto3" json:"lucky"`
	// 备注
	Note string `protobuf:"bytes,16,opt,name=note,proto3" json:"note"`
	// 系统必赢
	Cheat bool `protobuf:"varint,17,opt,name=cheat,proto3" json:"cheat"`
}

func (m *GameRound) Reset()         { *m = GameRound{} }
func (m *GameRound) String() string { return proto.CompactTextString(m) }
func (*GameRound) ProtoMessage()    {}
func (*GameRound) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{2}
}
func (m *GameRound) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameRound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameRound.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameRound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameRound.Merge(m, src)
}
func (m *GameRound) XXX_Size() int {
	return m.Size()
}
func (m *GameRound) XXX_DiscardUnknown() {
	xxx_messageInfo_GameRound.DiscardUnknown(m)
}

var xxx_messageInfo_GameRound proto.InternalMessageInfo

func (m *GameRound) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameRound) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *GameRound) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *GameRound) GetRoom() int32 {
	if m != nil {
		return m.Room
	}
	return 0
}

func (m *GameRound) GetTab() int32 {
	if m != nil {
		return m.Tab
	}
	return 0
}

func (m *GameRound) GetBill() []*GameBill {
	if m != nil {
		return m.Bill
	}
	return nil
}

func (m *GameRound) GetAnte() int32 {
	if m != nil {
		return m.Ante
	}
	return 0
}

func (m *GameRound) GetRing() int32 {
	if m != nil {
		return m.Ring
	}
	return 0
}

func (m *GameRound) GetSum() int64 {
	if m != nil {
		return m.Sum
	}
	return 0
}

func (m *GameRound) GetWin() int64 {
	if m != nil {
		return m.Win
	}
	return 0
}

func (m *GameRound) GetTax() int64 {
	if m != nil {
		return m.Tax
	}
	return 0
}

func (m *GameRound) GetWater() int64 {
	if m != nil {
		return m.Water
	}
	return 0
}

func (m *GameRound) GetLog() []*ActionLog {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *GameRound) GetPool() int64 {
	if m != nil {
		return m.Pool
	}
	return 0
}

func (m *GameRound) GetLucky() int64 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func (m *GameRound) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *GameRound) GetCheat() bool {
	if m != nil {
		return m.Cheat
	}
	return false
}

type ActionLog struct {
	// 时间
	Start int64 `protobuf:"varint,1,opt,name=start,proto3" json:"start"`
	// 动作类型
	Type ActionType `protobuf:"varint,2,opt,name=type,proto3,enum=zjh.ActionType" json:"type"`
	// 玩家ID
	Uid int32 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid"`
	// 下注
	Bet int32 `protobuf:"varint,4,opt,name=bet,proto3" json:"bet"`
	// 对手ID
	Players []int32 `protobuf:"varint,5,rep,packed,name=players,proto3" json:"players"`
	// 赢的人
	Winners []int32 `protobuf:"varint,6,rep,packed,name=winners,proto3" json:"winners"`
}

func (m *ActionLog) Reset()         { *m = ActionLog{} }
func (m *ActionLog) String() string { return proto.CompactTextString(m) }
func (*ActionLog) ProtoMessage()    {}
func (*ActionLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{3}
}
func (m *ActionLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionLog.Merge(m, src)
}
func (m *ActionLog) XXX_Size() int {
	return m.Size()
}
func (m *ActionLog) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionLog.DiscardUnknown(m)
}

var xxx_messageInfo_ActionLog proto.InternalMessageInfo

func (m *ActionLog) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *ActionLog) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ActionType_ActionNone
}

func (m *ActionLog) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionLog) GetBet() int32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *ActionLog) GetPlayers() []int32 {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *ActionLog) GetWinners() []int32 {
	if m != nil {
		return m.Winners
	}
	return nil
}

// 打牌请求
type ActionReq struct {
	// 动作类型
	Type ActionType `protobuf:"varint,1,opt,name=type,proto3,enum=zjh.ActionType" json:"type"`
	// 下注
	Bet int32 `protobuf:"varint,2,opt,name=bet,proto3" json:"bet"`
	// 对手ID
	Opponent int32 `protobuf:"varint,3,opt,name=opponent,proto3" json:"opponent"`
}

func (m *ActionReq) Reset()         { *m = ActionReq{} }
func (m *ActionReq) String() string { return proto.CompactTextString(m) }
func (*ActionReq) ProtoMessage()    {}
func (*ActionReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{4}
}
func (m *ActionReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionReq.Merge(m, src)
}
func (m *ActionReq) XXX_Size() int {
	return m.Size()
}
func (m *ActionReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionReq.DiscardUnknown(m)
}

var xxx_messageInfo_ActionReq proto.InternalMessageInfo

func (m *ActionReq) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ActionType_ActionNone
}

func (m *ActionReq) GetBet() int32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *ActionReq) GetOpponent() int32 {
	if m != nil {
		return m.Opponent
	}
	return 0
}

type ActionAck struct {
	// 动作类型
	Type ActionType `protobuf:"varint,1,opt,name=type,proto3,enum=zjh.ActionType" json:"type"`
	// 牌
	Poker []byte `protobuf:"bytes,2,opt,name=poker,proto3" json:"poker"`
	// 玩家ID
	Uid int32 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid"`
	// 下注
	Bet int32 `protobuf:"varint,4,opt,name=bet,proto3" json:"bet"`
	// 参与比牌的玩家ID
	Players []int32 `protobuf:"varint,5,rep,packed,name=players,proto3" json:"players"`
	// 赢的人
	Winners []int32 `protobuf:"varint,6,rep,packed,name=winners,proto3" json:"winners"`
	// 当前金币
	Coin int64 `protobuf:"varint,7,opt,name=coin,proto3" json:"coin"`
}

func (m *ActionAck) Reset()         { *m = ActionAck{} }
func (m *ActionAck) String() string { return proto.CompactTextString(m) }
func (*ActionAck) ProtoMessage()    {}
func (*ActionAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{5}
}
func (m *ActionAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionAck.Merge(m, src)
}
func (m *ActionAck) XXX_Size() int {
	return m.Size()
}
func (m *ActionAck) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionAck.DiscardUnknown(m)
}

var xxx_messageInfo_ActionAck proto.InternalMessageInfo

func (m *ActionAck) GetType() ActionType {
	if m != nil {
		return m.Type
	}
	return ActionType_ActionNone
}

func (m *ActionAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *ActionAck) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ActionAck) GetBet() int32 {
	if m != nil {
		return m.Bet
	}
	return 0
}

func (m *ActionAck) GetPlayers() []int32 {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *ActionAck) GetWinners() []int32 {
	if m != nil {
		return m.Winners
	}
	return nil
}

func (m *ActionAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

type GameInitAck struct {
	// 当前游戏ID
	Table int32 `protobuf:"varint,1,opt,name=table,proto3" json:"table"`
	// 当前游戏ID
	Id int32 `protobuf:"varint,2,opt,name=id,proto3" json:"id"`
	// 彩池的钱
	Pool int64 `protobuf:"varint,3,opt,name=pool,proto3" json:"pool"`
	// 当前游戏状态
	State int32 `protobuf:"varint,4,opt,name=state,proto3" json:"state"`
	// 第几轮
	Ring int32 `protobuf:"varint,5,opt,name=ring,proto3" json:"ring"`
	// 玩家(第1个位置为先)
	Players []*Player `protobuf:"bytes,6,rep,name=players,proto3" json:"players"`
	// 我的牌,如果已看牌
	Poker []byte `protobuf:"bytes,7,opt,name=poker,proto3" json:"poker"`
}

func (m *GameInitAck) Reset()         { *m = GameInitAck{} }
func (m *GameInitAck) String() string { return proto.CompactTextString(m) }
func (*GameInitAck) ProtoMessage()    {}
func (*GameInitAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{6}
}
func (m *GameInitAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameInitAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameInitAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameInitAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameInitAck.Merge(m, src)
}
func (m *GameInitAck) XXX_Size() int {
	return m.Size()
}
func (m *GameInitAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameInitAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameInitAck proto.InternalMessageInfo

func (m *GameInitAck) GetTable() int32 {
	if m != nil {
		return m.Table
	}
	return 0
}

func (m *GameInitAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameInitAck) GetPool() int64 {
	if m != nil {
		return m.Pool
	}
	return 0
}

func (m *GameInitAck) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *GameInitAck) GetRing() int32 {
	if m != nil {
		return m.Ring
	}
	return 0
}

func (m *GameInitAck) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *GameInitAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

// 游戏开始
type GameStartAck struct {
	// 当前游戏ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 彩池的钱
	Pool int64 `protobuf:"varint,2,opt,name=pool,proto3" json:"pool"`
	// 玩家(第1个位置为先)
	Players []*Player `protobuf:"bytes,3,rep,name=players,proto3" json:"players"`
}

func (m *GameStartAck) Reset()         { *m = GameStartAck{} }
func (m *GameStartAck) String() string { return proto.CompactTextString(m) }
func (*GameStartAck) ProtoMessage()    {}
func (*GameStartAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{7}
}
func (m *GameStartAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameStartAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameStartAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameStartAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameStartAck.Merge(m, src)
}
func (m *GameStartAck) XXX_Size() int {
	return m.Size()
}
func (m *GameStartAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameStartAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameStartAck proto.InternalMessageInfo

func (m *GameStartAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameStartAck) GetPool() int64 {
	if m != nil {
		return m.Pool
	}
	return 0
}

func (m *GameStartAck) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// 游戏结束
type GameResultAck struct {
	// 当前游戏ID
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	// 赢家
	Winner []int32 `protobuf:"varint,2,rep,packed,name=winner,proto3" json:"winner"`
	// 每个人的赢钱数
	Prize []int64 `protobuf:"varint,3,rep,packed,name=prize,proto3" json:"prize"`
	// 我的金币数
	Coin int64 `protobuf:"varint,4,opt,name=coin,proto3" json:"coin"`
	// 所有牌,不能看的为0
	Poker []byte `protobuf:"bytes,5,opt,name=poker,proto3" json:"poker"`
	// 喜钱，从彩池单独出
	Lucky int64 `protobuf:"varint,6,opt,name=lucky,proto3" json:"lucky"`
}

func (m *GameResultAck) Reset()         { *m = GameResultAck{} }
func (m *GameResultAck) String() string { return proto.CompactTextString(m) }
func (*GameResultAck) ProtoMessage()    {}
func (*GameResultAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_953ac353d286795d, []int{8}
}
func (m *GameResultAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameResultAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameResultAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameResultAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameResultAck.Merge(m, src)
}
func (m *GameResultAck) XXX_Size() int {
	return m.Size()
}
func (m *GameResultAck) XXX_DiscardUnknown() {
	xxx_messageInfo_GameResultAck.DiscardUnknown(m)
}

var xxx_messageInfo_GameResultAck proto.InternalMessageInfo

func (m *GameResultAck) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GameResultAck) GetWinner() []int32 {
	if m != nil {
		return m.Winner
	}
	return nil
}

func (m *GameResultAck) GetPrize() []int64 {
	if m != nil {
		return m.Prize
	}
	return nil
}

func (m *GameResultAck) GetCoin() int64 {
	if m != nil {
		return m.Coin
	}
	return 0
}

func (m *GameResultAck) GetPoker() []byte {
	if m != nil {
		return m.Poker
	}
	return nil
}

func (m *GameResultAck) GetLucky() int64 {
	if m != nil {
		return m.Lucky
	}
	return 0
}

func init() {
	proto.RegisterEnum("zjh.Code", Code_name, Code_value)
	proto.RegisterEnum("zjh.ActionType", ActionType_name, ActionType_value)
	proto.RegisterEnum("zjh.Player_State", Player_State_name, Player_State_value)
	proto.RegisterType((*Player)(nil), "zjh.Player")
	proto.RegisterType((*GameBill)(nil), "zjh.GameBill")
	proto.RegisterType((*GameRound)(nil), "zjh.GameRound")
	proto.RegisterType((*ActionLog)(nil), "zjh.ActionLog")
	proto.RegisterType((*ActionReq)(nil), "zjh.ActionReq")
	proto.RegisterType((*ActionAck)(nil), "zjh.ActionAck")
	proto.RegisterType((*GameInitAck)(nil), "zjh.GameInitAck")
	proto.RegisterType((*GameStartAck)(nil), "zjh.GameStartAck")
	proto.RegisterType((*GameResultAck)(nil), "zjh.GameResultAck")
}

func init() { proto.RegisterFile("zjh.proto", fileDescriptor_953ac353d286795d) }

var fileDescriptor_953ac353d286795d = []byte{
	// 1108 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0xe4, 0x44,
	0x10, 0x8e, 0xed, 0xf1, 0xfc, 0xd4, 0x4c, 0x26, 0x9e, 0x56, 0x36, 0x32, 0x2b, 0x31, 0x3b, 0x32,
	0x42, 0x0c, 0x8b, 0x48, 0xa4, 0x70, 0x43, 0x1c, 0xf2, 0x83, 0x84, 0x90, 0x22, 0x40, 0x5e, 0x24,
	0x04, 0x07, 0x90, 0x3d, 0xd3, 0x4c, 0x3a, 0xe3, 0xe9, 0x36, 0xb6, 0x27, 0x43, 0x72, 0xe3, 0x01,
	0x90, 0xb8, 0x72, 0xe1, 0x11, 0x38, 0xf0, 0x04, 0xdc, 0xe0, 0xb8, 0x47, 0x4e, 0x2b, 0x94, 0xdc,
	0xf8, 0x11, 0x02, 0x5e, 0x00, 0x55, 0x75, 0xfb, 0x67, 0x45, 0x10, 0x5c, 0x38, 0xb9, 0xaa, 0xba,
	0xba, 0xab, 0xfa, 0xab, 0xaf, 0xaa, 0x0d, 0xbd, 0xeb, 0x8b, 0xf3, 0xfd, 0x34, 0x53, 0x85, 0x62,
	0xce, 0xf5, 0xc5, 0xf9, 0xfd, 0x97, 0x17, 0xa2, 0x38, 0x5f, 0xc7, 0xfb, 0x33, 0xb5, 0x3a, 0x58,
	0xa8, 0x85, 0x3a, 0xa0, 0xb5, 0x78, 0xfd, 0x31, 0x69, 0xa4, 0x90, 0xa4, 0xf7, 0x04, 0xdf, 0xda,
	0xd0, 0x7e, 0x27, 0x89, 0xae, 0x78, 0xc6, 0x86, 0x60, 0x8b, 0xb9, 0x6f, 0x4d, 0xac, 0xa9, 0x1b,
	0xda, 0x62, 0xce, 0x18, 0xb4, 0xc4, 0x4c, 0x49, 0xdf, 0x26, 0x0b, 0xc9, 0xcc, 0x03, 0xe7, 0x52,
	0xa4, 0xbe, 0x43, 0x26, 0x14, 0xd9, 0x2e, 0xb8, 0xb3, 0xf3, 0x48, 0x64, 0x7e, 0x8b, 0x6c, 0x5a,
	0xc1, 0xbd, 0x33, 0x25, 0xa4, 0xef, 0x4e, 0xac, 0xa9, 0x13, 0x92, 0x8c, 0x7b, 0x63, 0x5e, 0xf8,
	0x6d, 0x32, 0xa1, 0x88, 0x5e, 0x32, 0x5a, 0x71, 0xbf, 0x33, 0xb1, 0xa6, 0xbd, 0x90, 0x64, 0xf6,
	0x02, 0xb8, 0x79, 0x11, 0x15, 0xdc, 0xef, 0x4e, 0xac, 0xe9, 0xf0, 0x70, 0xb4, 0x8f, 0xf7, 0xd3,
	0x19, 0xee, 0x3f, 0xc2, 0x85, 0x50, 0xaf, 0xe3, 0xe6, 0x44, 0xa9, 0xa5, 0xdf, 0x9b, 0x58, 0xd3,
	0x6e, 0x48, 0x32, 0xda, 0xe6, 0x6a, 0x23, 0x7d, 0x98, 0x58, 0xd3, 0x51, 0x48, 0x72, 0xf0, 0x11,
	0xb8, 0xb4, 0x8f, 0x75, 0xa1, 0xf5, 0x96, 0x92, 0xdc, 0xdb, 0x62, 0x3d, 0x70, 0x43, 0x1e, 0xcd,
	0xaf, 0x3c, 0x8b, 0xf5, 0xa1, 0x83, 0x87, 0x0b, 0xb9, 0xf0, 0x6c, 0xb4, 0x1f, 0x27, 0x89, 0x90,
	0x9e, 0x83, 0xf6, 0xd7, 0x45, 0x3e, 0x8b, 0xb2, 0xb9, 0xd7, 0xc2, 0x9d, 0x67, 0x2a, 0xe7, 0x9e,
	0xcb, 0x3a, 0xe0, 0xbc, 0x27, 0xa4, 0xd7, 0x46, 0xd7, 0x33, 0x1e, 0x5d, 0x72, 0xaf, 0x13, 0x7c,
	0x69, 0x43, 0xf7, 0x8d, 0x68, 0xc5, 0x4f, 0x44, 0x92, 0xb0, 0x97, 0xc0, 0x59, 0x97, 0x28, 0x9e,
	0x3c, 0xf3, 0xd3, 0x93, 0x07, 0xd6, 0xfa, 0x8f, 0x27, 0x0f, 0xbc, 0x38, 0x57, 0xf2, 0xd5, 0x60,
	0x1d, 0x4c, 0x56, 0xf9, 0x02, 0xbf, 0x21, 0x7a, 0x21, 0x22, 0x17, 0x2a, 0x36, 0x00, 0xa3, 0xc8,
	0x7c, 0xe8, 0xa8, 0x64, 0x7e, 0x8a, 0xd0, 0x39, 0x84, 0x53, 0xa9, 0x96, 0xe8, 0xb5, 0x6a, 0xf4,
	0x76, 0xc1, 0x4d, 0xd5, 0x92, 0x67, 0x04, 0xf2, 0x20, 0xd4, 0x0a, 0xdb, 0x83, 0xf6, 0x86, 0x8b,
	0xc5, 0xb9, 0x06, 0xda, 0x0d, 0x8d, 0x86, 0xfb, 0x37, 0x42, 0x12, 0xd4, 0x2c, 0x44, 0x11, 0x2d,
	0x45, 0xf4, 0x29, 0xe1, 0xec, 0x84, 0x28, 0xe2, 0x89, 0x9b, 0xa8, 0xe0, 0x19, 0x61, 0xea, 0x84,
	0x5a, 0x41, 0x6b, 0xb2, 0x9e, 0x2d, 0xaf, 0x08, 0x55, 0x27, 0xd4, 0x0a, 0x5a, 0x33, 0x15, 0xab,
	0xc2, 0xef, 0xd3, 0x89, 0x5a, 0x41, 0x0e, 0xa5, 0x4b, 0x7f, 0x30, 0x71, 0x90, 0x43, 0xe9, 0x32,
	0xf8, 0xce, 0x81, 0x1e, 0x62, 0x13, 0xaa, 0xb5, 0x9c, 0xb3, 0x17, 0x2b, 0x86, 0x39, 0x1a, 0x1b,
	0x51, 0x63, 0x23, 0x0c, 0x36, 0x22, 0x20, 0xf2, 0x1d, 0x10, 0x0d, 0xb2, 0x82, 0xc0, 0x31, 0xde,
	0x79, 0xed, 0x9d, 0x1b, 0xef, 0x3c, 0x08, 0xb5, 0x1f, 0xde, 0x86, 0xcb, 0xb9, 0x41, 0x0d, 0x45,
	0x24, 0x43, 0xa6, 0xd4, 0xca, 0x10, 0x93, 0x64, 0x7d, 0xe7, 0x98, 0x10, 0x73, 0xf1, 0xce, 0x31,
	0x7b, 0x0d, 0x5a, 0xb1, 0x48, 0x12, 0xbf, 0x3d, 0x71, 0xa6, 0xfd, 0xc3, 0x6d, 0xa2, 0x5b, 0x59,
	0x4d, 0x1d, 0x36, 0xae, 0xc3, 0xc6, 0x26, 0x6c, 0x1c, 0x84, 0xb4, 0x0b, 0x63, 0x44, 0xb2, 0xd0,
	0x0c, 0x76, 0x43, 0x92, 0x29, 0xae, 0x90, 0x0b, 0x02, 0x16, 0xe3, 0x0a, 0xb9, 0xc0, 0xb8, 0xf9,
	0x7a, 0x65, 0x70, 0x45, 0xb1, 0xac, 0x07, 0xfc, 0xad, 0x1e, 0xfd, 0x3b, 0xea, 0x31, 0x68, 0xd6,
	0x63, 0x02, 0x4e, 0xa2, 0x16, 0xfe, 0x36, 0x25, 0x3c, 0xa4, 0x84, 0x8f, 0x67, 0x85, 0x50, 0xf2,
	0x4c, 0x2d, 0x42, 0x5c, 0xc2, 0x0c, 0x52, 0xa5, 0x12, 0x7f, 0xa8, 0xbb, 0x0f, 0xe5, 0xba, 0x8a,
	0x3b, 0xcd, 0x2a, 0x62, 0x07, 0xaa, 0x82, 0xfb, 0x9e, 0xe9, 0x40, 0x55, 0x70, 0xdd, 0xd1, 0x3c,
	0x2a, 0xfc, 0x11, 0x75, 0x96, 0x56, 0x82, 0xaf, 0x2c, 0xe8, 0x55, 0x61, 0xd0, 0x47, 0x97, 0xc7,
	0xd2, 0xa7, 0xe9, 0x1a, 0x3c, 0x07, 0xad, 0xe2, 0x2a, 0xe5, 0x54, 0xb3, 0xe1, 0xe1, 0x4e, 0x23,
	0xb5, 0x77, 0xaf, 0x52, 0x1e, 0xd2, 0x22, 0x5e, 0x13, 0x3b, 0xc4, 0x8c, 0x10, 0xd3, 0x06, 0x25,
	0xb5, 0x5d, 0x4d, 0x6d, 0x1f, 0x3a, 0x29, 0xb5, 0x7c, 0xee, 0xbb, 0xc4, 0xa5, 0x52, 0xc5, 0x95,
	0x8d, 0x90, 0x12, 0x57, 0xda, 0x7a, 0xc5, 0xa8, 0xc1, 0x87, 0x65, 0x7e, 0x21, 0xff, 0xa4, 0xca,
	0xc4, 0xfa, 0x97, 0x4c, 0x30, 0xae, 0x5d, 0xc7, 0xbd, 0x0f, 0x5d, 0x95, 0xa6, 0x4a, 0x72, 0x59,
	0x98, 0x04, 0x2b, 0x3d, 0xf8, 0xa6, 0x02, 0xe0, 0x78, 0xb6, 0xfc, 0x6f, 0x01, 0xaa, 0x0e, 0xb5,
	0x9b, 0x1d, 0xfa, 0x3f, 0x01, 0x50, 0xcd, 0xdc, 0x4e, 0x3d, 0x73, 0x83, 0xaf, 0x2d, 0xe8, 0x23,
	0x9b, 0xdf, 0x94, 0xa2, 0xc0, 0xb4, 0x77, 0xc1, 0x2d, 0xa2, 0x38, 0xe1, 0x66, 0xcc, 0x6b, 0xc5,
	0x4c, 0x7e, 0xbb, 0x39, 0xf9, 0x89, 0x3f, 0xce, 0xd3, 0xfc, 0xd1, 0x73, 0xd9, 0xcc, 0xf9, 0x6a,
	0x08, 0x13, 0xd7, 0xdd, 0x06, 0xd7, 0x9f, 0xaf, 0x73, 0xd7, 0x4d, 0xd5, 0x6f, 0xcc, 0xf0, 0xfa,
	0x22, 0x15, 0x38, 0x9d, 0x06, 0x38, 0xc1, 0xfb, 0x30, 0xc0, 0x7c, 0x1f, 0x21, 0x9f, 0x30, 0xe1,
	0x3b, 0x1e, 0x25, 0x4a, 0xcd, 0x6e, 0xa4, 0xd6, 0x08, 0xe8, 0xfc, 0x73, 0xc0, 0xe0, 0x73, 0x0b,
	0xb6, 0x69, 0x16, 0xf1, 0x7c, 0x9d, 0xdc, 0x79, 0x38, 0xce, 0x4e, 0x02, 0xd3, 0xb7, 0x09, 0x5a,
	0xa3, 0x51, 0xaa, 0x99, 0xb8, 0xe6, 0x74, 0xbc, 0x13, 0x6a, 0xa5, 0xc2, 0xbb, 0xd5, 0x78, 0xe3,
	0xee, 0x9e, 0xc9, 0x55, 0xef, 0xb5, 0x1b, 0xbd, 0xf7, 0xf0, 0x33, 0x0b, 0x5a, 0xa7, 0x6a, 0xce,
	0xd9, 0x00, 0xba, 0xf8, 0x35, 0x8f, 0x13, 0x83, 0x6d, 0xd4, 0x2a, 0x2e, 0x7b, 0xbf, 0x1c, 0x3d,
	0x6d, 0x3b, 0x9e, 0x2d, 0xbd, 0x5f, 0x8f, 0xd8, 0x2e, 0xec, 0xa0, 0xad, 0x51, 0x5d, 0xef, 0xb7,
	0x23, 0x76, 0x0f, 0xbc, 0xd2, 0x5a, 0x62, 0xe8, 0xfd, 0x7e, 0xc4, 0xf6, 0x60, 0x54, 0x9a, 0xab,
	0xeb, 0x7b, 0x7f, 0x1e, 0x3d, 0xfc, 0xd9, 0x02, 0xa8, 0x69, 0xcb, 0x86, 0xa5, 0x66, 0x72, 0xd9,
	0x81, 0x7e, 0x99, 0x87, 0x7e, 0x2e, 0x2b, 0x87, 0x33, 0xa5, 0x96, 0x9e, 0xcd, 0x46, 0xb0, 0xad,
	0xf5, 0xf2, 0xb1, 0x74, 0x18, 0x83, 0xa1, 0x36, 0xbd, 0x7d, 0xc9, 0xb3, 0x42, 0xac, 0xb8, 0xd7,
	0xaa, 0xdd, 0x4e, 0xd5, 0x2a, 0x8d, 0x32, 0x7c, 0x49, 0x3d, 0x18, 0x98, 0xeb, 0xcc, 0xe7, 0x27,
	0xbc, 0xf0, 0xda, 0x75, 0x30, 0xfd, 0x06, 0x77, 0xd8, 0x1e, 0xb0, 0x86, 0xa1, 0xdc, 0xda, 0x63,
	0xf7, 0x60, 0x64, 0xec, 0xeb, 0x42, 0x95, 0x66, 0x68, 0x26, 0x2b, 0xf9, 0xc6, 0xeb, 0xd7, 0x06,
	0xfd, 0x52, 0x0f, 0x4e, 0x9e, 0xfd, 0xfe, 0x66, 0x6c, 0x3d, 0xbe, 0x19, 0x5b, 0x3f, 0xde, 0x8c,
	0xad, 0x2f, 0x6e, 0xc7, 0x5b, 0x8f, 0x6f, 0xc7, 0x5b, 0x3f, 0xdc, 0x8e, 0xb7, 0x3e, 0xc0, 0x5f,
	0xa7, 0xb8, 0x4d, 0xbf, 0x44, 0xaf, 0xfc, 0x15, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x42, 0x67, 0xa4,
	0x53, 0x09, 0x00, 0x00,
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Icon != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Icon))
	}
	if m.Vip != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Vip))
	}
	if m.Chair != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Chair))
	}
	if m.Coin != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.State != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.State))
	}
	if m.Look {
		dAtA[i] = 0x48
		i++
		if m.Look {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Down != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint32(m.Down)<<1)^uint32((m.Down>>31))))
	}
	return i, nil
}

func (m *GameBill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameBill) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Job != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Job))
	}
	if m.OldCoin != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.OldCoin))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Weight))
	}
	if m.Win != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint64(m.Win)<<1)^uint64((m.Win>>63))))
	}
	if m.Tax != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tax))
	}
	if m.Water != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Water))
	}
	if m.Lucky != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Lucky))
	}
	if m.Robot != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint64(m.Robot)<<1)^uint64((m.Robot>>63))))
	}
	if len(m.Pk) > 0 {
		dAtA2 := make([]byte, len(m.Pk)*10)
		var j1 int
		for _, num1 := range m.Pk {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x62
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *GameRound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameRound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Start != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.End))
	}
	if m.Room != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Room))
	}
	if m.Tab != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tab))
	}
	if len(m.Bill) > 0 {
		for _, msg := range m.Bill {
			dAtA[i] = 0x32
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ante != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Ante))
	}
	if m.Ring != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Ring))
	}
	if m.Sum != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Sum))
	}
	if m.Win != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintZjh(dAtA, i, uint64((uint64(m.Win)<<1)^uint64((m.Win>>63))))
	}
	if m.Tax != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Tax))
	}
	if m.Water != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Water))
	}
	if len(m.Log) > 0 {
		for _, msg := range m.Log {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Pool != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Pool))
	}
	if m.Lucky != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Lucky))
	}
	if len(m.Note) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Note)))
		i += copy(dAtA[i:], m.Note)
	}
	if m.Cheat {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.Cheat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ActionLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionLog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Start))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Type))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if len(m.Players) > 0 {
		dAtA4 := make([]byte, len(m.Players)*10)
		var j3 int
		for _, num1 := range m.Players {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Winners) > 0 {
		dAtA6 := make([]byte, len(m.Winners)*10)
		var j5 int
		for _, num1 := range m.Winners {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *ActionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Type))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if m.Opponent != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Opponent))
	}
	return i, nil
}

func (m *ActionAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Type))
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Uid))
	}
	if m.Bet != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Bet))
	}
	if len(m.Players) > 0 {
		dAtA8 := make([]byte, len(m.Players)*10)
		var j7 int
		for _, num1 := range m.Players {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.Winners) > 0 {
		dAtA10 := make([]byte, len(m.Winners)*10)
		var j9 int
		for _, num1 := range m.Winners {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if m.Coin != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	return i, nil
}

func (m *GameInitAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameInitAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Table != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Table))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Pool != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Pool))
	}
	if m.State != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.State))
	}
	if m.Ring != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Ring))
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x32
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	return i, nil
}

func (m *GameStartAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameStartAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if m.Pool != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Pool))
	}
	if len(m.Players) > 0 {
		for _, msg := range m.Players {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintZjh(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GameResultAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameResultAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Id))
	}
	if len(m.Winner) > 0 {
		dAtA12 := make([]byte, len(m.Winner)*10)
		var j11 int
		for _, num1 := range m.Winner {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if len(m.Prize) > 0 {
		dAtA14 := make([]byte, len(m.Prize)*10)
		var j13 int
		for _, num1 := range m.Prize {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.Coin != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Coin))
	}
	if len(m.Poker) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintZjh(dAtA, i, uint64(len(m.Poker)))
		i += copy(dAtA[i:], m.Poker)
	}
	if m.Lucky != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintZjh(dAtA, i, uint64(m.Lucky))
	}
	return i, nil
}

func encodeVarintZjh(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Player) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Icon != 0 {
		n += 1 + sovZjh(uint64(m.Icon))
	}
	if m.Vip != 0 {
		n += 1 + sovZjh(uint64(m.Vip))
	}
	if m.Chair != 0 {
		n += 1 + sovZjh(uint64(m.Chair))
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovZjh(uint64(m.State))
	}
	if m.Look {
		n += 2
	}
	if m.Down != 0 {
		n += 1 + sozZjh(uint64(m.Down))
	}
	return n
}

func (m *GameBill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Job != 0 {
		n += 1 + sovZjh(uint64(m.Job))
	}
	if m.OldCoin != 0 {
		n += 1 + sovZjh(uint64(m.OldCoin))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovZjh(uint64(m.Weight))
	}
	if m.Win != 0 {
		n += 1 + sozZjh(uint64(m.Win))
	}
	if m.Tax != 0 {
		n += 1 + sovZjh(uint64(m.Tax))
	}
	if m.Water != 0 {
		n += 1 + sovZjh(uint64(m.Water))
	}
	if m.Lucky != 0 {
		n += 1 + sovZjh(uint64(m.Lucky))
	}
	if m.Robot != 0 {
		n += 1 + sozZjh(uint64(m.Robot))
	}
	if len(m.Pk) > 0 {
		l = 0
		for _, e := range m.Pk {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	return n
}

func (m *GameRound) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Start != 0 {
		n += 1 + sovZjh(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovZjh(uint64(m.End))
	}
	if m.Room != 0 {
		n += 1 + sovZjh(uint64(m.Room))
	}
	if m.Tab != 0 {
		n += 1 + sovZjh(uint64(m.Tab))
	}
	if len(m.Bill) > 0 {
		for _, e := range m.Bill {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	if m.Ante != 0 {
		n += 1 + sovZjh(uint64(m.Ante))
	}
	if m.Ring != 0 {
		n += 1 + sovZjh(uint64(m.Ring))
	}
	if m.Sum != 0 {
		n += 1 + sovZjh(uint64(m.Sum))
	}
	if m.Win != 0 {
		n += 1 + sozZjh(uint64(m.Win))
	}
	if m.Tax != 0 {
		n += 1 + sovZjh(uint64(m.Tax))
	}
	if m.Water != 0 {
		n += 1 + sovZjh(uint64(m.Water))
	}
	if len(m.Log) > 0 {
		for _, e := range m.Log {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	if m.Pool != 0 {
		n += 1 + sovZjh(uint64(m.Pool))
	}
	if m.Lucky != 0 {
		n += 1 + sovZjh(uint64(m.Lucky))
	}
	l = len(m.Note)
	if l > 0 {
		n += 2 + l + sovZjh(uint64(l))
	}
	if m.Cheat {
		n += 3
	}
	return n
}

func (m *ActionLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovZjh(uint64(m.Start))
	}
	if m.Type != 0 {
		n += 1 + sovZjh(uint64(m.Type))
	}
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	if len(m.Players) > 0 {
		l = 0
		for _, e := range m.Players {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if len(m.Winners) > 0 {
		l = 0
		for _, e := range m.Winners {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	return n
}

func (m *ActionReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovZjh(uint64(m.Type))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	if m.Opponent != 0 {
		n += 1 + sovZjh(uint64(m.Opponent))
	}
	return n
}

func (m *ActionAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovZjh(uint64(m.Type))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovZjh(uint64(m.Uid))
	}
	if m.Bet != 0 {
		n += 1 + sovZjh(uint64(m.Bet))
	}
	if len(m.Players) > 0 {
		l = 0
		for _, e := range m.Players {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if len(m.Winners) > 0 {
		l = 0
		for _, e := range m.Winners {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	return n
}

func (m *GameInitAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Table != 0 {
		n += 1 + sovZjh(uint64(m.Table))
	}
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Pool != 0 {
		n += 1 + sovZjh(uint64(m.Pool))
	}
	if m.State != 0 {
		n += 1 + sovZjh(uint64(m.State))
	}
	if m.Ring != 0 {
		n += 1 + sovZjh(uint64(m.Ring))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	return n
}

func (m *GameStartAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if m.Pool != 0 {
		n += 1 + sovZjh(uint64(m.Pool))
	}
	if len(m.Players) > 0 {
		for _, e := range m.Players {
			l = e.Size()
			n += 1 + l + sovZjh(uint64(l))
		}
	}
	return n
}

func (m *GameResultAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovZjh(uint64(m.Id))
	}
	if len(m.Winner) > 0 {
		l = 0
		for _, e := range m.Winner {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if len(m.Prize) > 0 {
		l = 0
		for _, e := range m.Prize {
			l += sovZjh(uint64(e))
		}
		n += 1 + sovZjh(uint64(l)) + l
	}
	if m.Coin != 0 {
		n += 1 + sovZjh(uint64(m.Coin))
	}
	l = len(m.Poker)
	if l > 0 {
		n += 1 + l + sovZjh(uint64(l))
	}
	if m.Lucky != 0 {
		n += 1 + sovZjh(uint64(m.Lucky))
	}
	return n
}

func sovZjh(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozZjh(x uint64) (n int) {
	return sovZjh(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			m.Icon = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Icon |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vip", wireType)
			}
			m.Vip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vip |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chair", wireType)
			}
			m.Chair = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chair |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Player_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Look", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Look = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Down = v
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameBill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameBill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameBill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			m.Job = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Job |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldCoin", wireType)
			}
			m.OldCoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldCoin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Win = int64(v)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			m.Tax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Water", wireType)
			}
			m.Water = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Water |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Robot", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Robot = int64(v)
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Pk = append(m.Pk, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Pk) == 0 {
					m.Pk = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Pk = append(m.Pk, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pk", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameRound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameRound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameRound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			m.Room = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Room |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tab", wireType)
			}
			m.Tab = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tab |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bill", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bill = append(m.Bill, &GameBill{})
			if err := m.Bill[len(m.Bill)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ante", wireType)
			}
			m.Ante = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ante |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			m.Ring = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ring |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sum", wireType)
			}
			m.Sum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sum |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Win", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			m.Win = int64(v)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tax", wireType)
			}
			m.Tax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Water", wireType)
			}
			m.Water = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Water |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = append(m.Log, &ActionLog{})
			if err := m.Log[len(m.Log)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Note", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Note = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cheat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Cheat = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Players = append(m.Players, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Players) == 0 {
					m.Players = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Players = append(m.Players, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winners = append(m.Winners, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Winners) == 0 {
					m.Winners = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Winners = append(m.Winners, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Winners", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Opponent", wireType)
			}
			m.Opponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Opponent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ActionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bet", wireType)
			}
			m.Bet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bet |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Players = append(m.Players, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Players) == 0 {
					m.Players = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Players = append(m.Players, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winners = append(m.Winners, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Winners) == 0 {
					m.Winners = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Winners = append(m.Winners, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Winners", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameInitAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameInitAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameInitAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			m.Table = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Table |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ring", wireType)
			}
			m.Ring = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ring |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameStartAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameStartAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameStartAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pool", wireType)
			}
			m.Pool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Players = append(m.Players, &Player{})
			if err := m.Players[len(m.Players)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameResultAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameResultAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameResultAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Winner = append(m.Winner, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Winner) == 0 {
					m.Winner = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Winner = append(m.Winner, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Winner", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Prize = append(m.Prize, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthZjh
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthZjh
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Prize) == 0 {
					m.Prize = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowZjh
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Prize = append(m.Prize, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Prize", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coin", wireType)
			}
			m.Coin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Poker", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthZjh
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthZjh
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Poker = append(m.Poker[:0], dAtA[iNdEx:postIndex]...)
			if m.Poker == nil {
				m.Poker = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lucky", wireType)
			}
			m.Lucky = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lucky |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipZjh(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthZjh
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipZjh(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowZjh
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowZjh
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthZjh
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthZjh
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowZjh
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipZjh(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthZjh
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthZjh = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowZjh   = fmt.Errorf("proto: integer overflow")
)
